<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.12.0" xml:lang="en-US">
  <compounddef id="classcsl_1_1Lock" kind="class" language="C++" prot="public">
    <compoundname>csl::Lock</compoundname>
    <includes refid="lock_8h" local="no">lock.h</includes>
    <sectiondef kind="public-type">
      <memberdef kind="typedef" id="classcsl_1_1Lock_1a45cc1ab000114603f736bf41a933175a" prot="public" static="no">
        <type>int</type>
        <definition>using csl::Lock::ID_t =  int</definition>
        <argsstring></argsstring>
        <name>ID_t</name>
        <qualifiedname>csl::Lock::ID_t</qualifiedname>
        <briefdescription>
<para>Typedef for lock id. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/lock.h" line="50" column="5" bodyfile="src/csl/lock.h" bodystart="50" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classcsl_1_1Lock_1ac0a09608dfb2396fa8b48a33a27e800c" prot="public" static="no">
        <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt;</type>
        <definition>using csl::Lock::predicate =  std::function&lt;bool(Expr const &amp;)&gt;</definition>
        <argsstring></argsstring>
        <name>predicate</name>
        <qualifiedname>csl::Lock::predicate</qualifiedname>
        <briefdescription>
<para>Typedef for the boolean predicate. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/lock.h" line="54" column="5" bodyfile="src/csl/lock.h" bodystart="54" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-static-attrib">
      <memberdef kind="variable" id="classcsl_1_1Lock_1a35f6132c34a5e21a2d780cf765ecf1c7" prot="private" static="yes" mutable="no">
        <type>std::map&lt; <ref refid="classcsl_1_1Lock_1a45cc1ab000114603f736bf41a933175a" kindref="member">ID_t</ref>, std::string &gt;</type>
        <definition>std::map&lt;ID_t, std::string&gt; csl::Lock::lockName</definition>
        <argsstring></argsstring>
        <name>lockName</name>
        <qualifiedname>csl::Lock::lockName</qualifiedname>
        <briefdescription>
<para>Static map containing lock names as a function of their id. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/lock.h" line="161" column="28" bodyfile="src/csl/lock.h" bodystart="161" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classcsl_1_1Lock_1a4949307447d26c318e81fb9dbf3b96c3" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Lock::lock</definition>
        <argsstring>(Expr &amp;init, int lockId, predicate const &amp;f)</argsstring>
        <name>lock</name>
        <qualifiedname>csl::Lock::lock</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lockId</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Lock_1ac0a09608dfb2396fa8b48a33a27e800c" kindref="member">predicate</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Abbreviates all parts of an expression depending on a condition. </para>
        </briefdescription>
        <detaileddescription>
<para>Any sub expression <bold>sub</bold> in <bold>expr</bold> such that f(sub) == false is abbreviated. This allows to compress all the information that is not needed when performing a given calculation. Large parts of expressions may be totally useless and must be abbreviated in order to minimize their impact on memory and computation time. To be clear, <bold>f</bold> should return <bold>true</bold> on objects that are important for the calculation, i.e. that must not be abbreviated.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to lock. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lockID</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Lock" kindref="compound">Lock</ref> id, allows to differentiate different locks when unlocking. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean predicate.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="classcsl_1_1Lock_1a32bff0dd7b12378551d7c1638ca66583" kindref="member">unlock()</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/lock.h" line="74" column="17" bodyfile="src/csl/lock.cpp" bodystart="33" bodyend="38"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Lock_1a82a7a584ea0fc6a7ab18ab643923ba4c" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Lock::lock</definition>
        <argsstring>(Expr &amp;init, predicate const &amp;f)</argsstring>
        <name>lock</name>
        <qualifiedname>csl::Lock::lock</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Lock_1ac0a09608dfb2396fa8b48a33a27e800c" kindref="member">predicate</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Abbreviates all parts of an expression depending on a condition. </para>
        </briefdescription>
        <detaileddescription>
<para>Any sub expression <bold>sub</bold> in <bold>expr</bold> such that f(sub) == false is abbreviated. This allows to compress all the information that is not needed when performing a given calculation. Large parts of expressions may be totally useless and must be abbreviated in order to minimize their impact on memory and computation time. To be clear, <bold>f</bold> should return <bold>true</bold> on objects that are important for the calculation, i.e. that must not be abbreviated.</para>
<para><simplesect kind="note"><para>This overload does not take any id. It actually calls the first function with the default id 0.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to lock. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean predicate.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="classcsl_1_1Lock_1a32bff0dd7b12378551d7c1638ca66583" kindref="member">unlock()</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/lock.h" line="95" column="17" bodyfile="src/csl/lock.cpp" bodystart="40" bodyend="43"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Lock_1a32bff0dd7b12378551d7c1638ca66583" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Lock::unlock</definition>
        <argsstring>(Expr &amp;init, int lockId)</argsstring>
        <name>unlock</name>
        <qualifiedname>csl::Lock::unlock</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lockId</declname>
        </param>
        <briefdescription>
<para>Expand abbreviations from a previous lock. The lock id should be the same. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to unlock. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lockID</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Lock" kindref="compound">Lock</ref> id, allows to differentiate different locks when unlocking.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>Lock() </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/lock.h" line="107" column="17" bodyfile="src/csl/lock.cpp" bodystart="45" bodyend="48"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Lock_1a49f7a05c265582b69775d87ae9d7c75c" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Lock::unlock</definition>
        <argsstring>(Expr &amp;init)</argsstring>
        <name>unlock</name>
        <qualifiedname>csl::Lock::unlock</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <briefdescription>
<para>Expand abbreviations from a previous lock. The lock id should be the same. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to unlock.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This overload does not take any id. It actually calls the first function with the default id 0.</para>
</simplesect>
<simplesect kind="see"><para>Lock() </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/lock.h" line="120" column="17" bodyfile="src/csl/lock.cpp" bodystart="50" bodyend="53"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Lock_1a8c571e092eb5779ead4bf76a098169d2" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string csl::Lock::lockNameOf</definition>
        <argsstring>(ID_t id)</argsstring>
        <name>lockNameOf</name>
        <qualifiedname>csl::Lock::lockNameOf</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Lock_1a45cc1ab000114603f736bf41a933175a" kindref="member">ID_t</ref></type>
          <declname>id</declname>
        </param>
        <briefdescription>
<para>Returns the generic abbreviation name of a lock given its id. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>lockID</parametername>
</parameternamelist>
<parameterdescription>
<para>Id of the lock.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The name of abbreviations of lock with id <bold>id</bold>.</para>
</simplesect>
<simplesect kind="see"><para>Lock(), Unlock() </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/lock.h" line="131" column="24" bodyfile="src/csl/lock.cpp" bodystart="26" bodyend="31"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-static-func">
      <memberdef kind="function" id="classcsl_1_1Lock_1ac4b442c3a7d0d985ecd47cef299a351a" prot="private" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::Lock::doLock</definition>
        <argsstring>(Expr &amp;init, ID_t id, predicate const &amp;f)</argsstring>
        <name>doLock</name>
        <qualifiedname>csl::Lock::doLock</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Lock_1a45cc1ab000114603f736bf41a933175a" kindref="member">ID_t</ref></type>
          <declname>id</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Lock_1ac0a09608dfb2396fa8b48a33a27e800c" kindref="member">predicate</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Actually locks an expression. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to lock. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lockID</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Lock" kindref="compound">Lock</ref> id, allows to differentiate different locks when unlocking. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean predicate.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="classcsl_1_1Lock_1a4949307447d26c318e81fb9dbf3b96c3" kindref="member">lock()</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/lock.h" line="144" column="17" bodyfile="src/csl/lock.cpp" bodystart="55" bodyend="113"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Lock_1a053573b0dc9d7317966780c4bc308ec1" prot="private" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Lock::doUnlock</definition>
        <argsstring>(Expr &amp;init, ID_t id)</argsstring>
        <name>doUnlock</name>
        <qualifiedname>csl::Lock::doUnlock</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Lock_1a45cc1ab000114603f736bf41a933175a" kindref="member">ID_t</ref></type>
          <declname>id</declname>
        </param>
        <briefdescription>
<para>Actually unlocks the expression. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to unlock. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lockID</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Lock" kindref="compound">Lock</ref> id, allows to differentiate different locks when unlocking.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="classcsl_1_1Lock_1a32bff0dd7b12378551d7c1638ca66583" kindref="member">unlock()</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/lock.h" line="155" column="17" bodyfile="src/csl/lock.cpp" bodystart="115" bodyend="122"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>Static class allowing to compress expressions given a boolean predicate. </para>
    </briefdescription>
    <detaileddescription>
<para>When doing heavy calculations, many sub expressions are not needed and just slow down (while taking memory) the calculation. This class can, given a boolean predicate, abbreviate all these expressions (<ref refid="classcsl_1_1Lock_1a4949307447d26c318e81fb9dbf3b96c3" kindref="member">lock()</ref>). After the calculation, you may re-expand the abbreviations (<ref refid="classcsl_1_1Lock_1a32bff0dd7b12378551d7c1638ca66583" kindref="member">unlock()</ref>). </para>
    </detaileddescription>
    <location file="src/csl/lock.h" line="44" column="1" bodyfile="src/csl/lock.h" bodystart="44" bodyend="162"/>
    <listofallmembers>
      <member refid="classcsl_1_1Lock_1ac4b442c3a7d0d985ecd47cef299a351a" prot="private" virt="non-virtual"><scope>csl::Lock</scope><name>doLock</name></member>
      <member refid="classcsl_1_1Lock_1a053573b0dc9d7317966780c4bc308ec1" prot="private" virt="non-virtual"><scope>csl::Lock</scope><name>doUnlock</name></member>
      <member refid="classcsl_1_1Lock_1a45cc1ab000114603f736bf41a933175a" prot="public" virt="non-virtual"><scope>csl::Lock</scope><name>ID_t</name></member>
      <member refid="classcsl_1_1Lock_1a4949307447d26c318e81fb9dbf3b96c3" prot="public" virt="non-virtual"><scope>csl::Lock</scope><name>lock</name></member>
      <member refid="classcsl_1_1Lock_1a82a7a584ea0fc6a7ab18ab643923ba4c" prot="public" virt="non-virtual"><scope>csl::Lock</scope><name>lock</name></member>
      <member refid="classcsl_1_1Lock_1a35f6132c34a5e21a2d780cf765ecf1c7" prot="private" virt="non-virtual"><scope>csl::Lock</scope><name>lockName</name></member>
      <member refid="classcsl_1_1Lock_1a8c571e092eb5779ead4bf76a098169d2" prot="public" virt="non-virtual"><scope>csl::Lock</scope><name>lockNameOf</name></member>
      <member refid="classcsl_1_1Lock_1ac0a09608dfb2396fa8b48a33a27e800c" prot="public" virt="non-virtual"><scope>csl::Lock</scope><name>predicate</name></member>
      <member refid="classcsl_1_1Lock_1a32bff0dd7b12378551d7c1638ca66583" prot="public" virt="non-virtual"><scope>csl::Lock</scope><name>unlock</name></member>
      <member refid="classcsl_1_1Lock_1a49f7a05c265582b69775d87ae9d7c75c" prot="public" virt="non-virtual"><scope>csl::Lock</scope><name>unlock</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
