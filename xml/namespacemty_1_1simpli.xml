<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.12.0" xml:lang="en-US">
  <compounddef id="namespacemty_1_1simpli" kind="namespace" language="C++">
    <compoundname>mty::simpli</compoundname>
    <innerclass refid="structmty_1_1simpli_1_1FermionEOMData" prot="public">mty::simpli::FermionEOMData</innerclass>
    <sectiondef kind="enum">
      <memberdef kind="enum" id="namespacemty_1_1simpli_1a22014bda2756a975f0764a174914aff0" prot="public" static="no" strong="no">
        <type></type>
        <name>Mode</name>
        <qualifiedname>mty::simpli::Mode</qualifiedname>
        <enumvalue id="namespacemty_1_1simpli_1a22014bda2756a975f0764a174914aff0a517612889a9a16a060d7d9c67d8d9a01" prot="public">
          <name>FeynmanRule</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacemty_1_1simpli_1a22014bda2756a975f0764a174914aff0a7902b453524087e3270df95f1f5237f2" prot="public">
          <name>Amplitude</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacemty_1_1simpli_1a22014bda2756a975f0764a174914aff0a6c6e863bcd26c0b061ef9a9a0ec58d15" prot="public">
          <name>SquaredAmplitude</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacemty_1_1simpli_1a22014bda2756a975f0764a174914aff0a0d88d88e4dbabca535501877dc445bc1" prot="public">
          <name>WilsonCoefficient</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Mode for the main simplification routine specifying what calculation is done to adapt the simplification procedure. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.h" line="56" column="1" bodyfile="src/marty/core/amplitudeSimplification.h" bodystart="56" bodyend="56"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="func">
      <memberdef kind="function" id="namespacemty_1_1simpli_1af3705662b332fd0d37acd303d71a9a36" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool mty::simpli::mayBeSimplified</definition>
        <argsstring>(csl::Expr const &amp;expr)</argsstring>
        <name>mayBeSimplified</name>
        <qualifiedname>mty::simpli::mayBeSimplified</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="34" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="34" bodyend="50"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a40ab2ff08bec713b9e3fa2426de3ca00" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void mty::simpli::findExternalAbbreviation</definition>
        <argsstring>(csl::Expr &amp;expr)</argsstring>
        <name>findExternalAbbreviation</name>
        <qualifiedname>mty::simpli::findExternalAbbreviation</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Abbreviates external legs in the expression using the generic name &quot;EXT&quot;. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Dev Note : This function works only for external fields of type <ref refid="classmty_1_1PolarizationField" kindref="compound">PolarizationField</ref>. Could probably be extended very easily to <ref refid="classmty_1_1QuantumField" kindref="compound">QuantumField</ref> objects using the following condition <programlisting><codeline><highlight class="keyword">dynamic_cast&lt;</highlight><highlight class="normal"><ref refid="classmty_1_1QuantumField" kindref="compound">mty::QuantumField</ref><sp/>const*</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(sub[i].get())</highlight></codeline>
</programlisting></para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression ni which the abbreviation will be applied. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="52" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="52" bodyend="70" declfile="src/marty/core/amplitudeSimplification.h" declline="541" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a46f2c3811c175336abae7a6af361b219" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void mty::simpli::abbreviateIntegral</definition>
        <argsstring>(csl::Expr &amp;res)</argsstring>
        <name>abbreviateIntegral</name>
        <qualifiedname>mty::simpli::abbreviateIntegral</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>res</declname>
        </param>
        <briefdescription>
<para>Abbreviate scalar integrals (or combinations of them) into abbreviations with the generic name &quot;INT&quot;. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>res</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to abbreviate. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="72" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="72" bodyend="104" declfile="src/marty/core/amplitudeSimplification.h" declline="549" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a033712672b927c6567781a686ba783e7" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>static bool mty::simpli::isMomentum</definition>
        <argsstring>(csl::Expr &amp;tensor)</argsstring>
        <name>isMomentum</name>
        <qualifiedname>mty::simpli::isMomentum</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>tensor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="106" column="13" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="106" bodyend="117"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a09eca37490e2991fda8c422ec7827e44" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void mty::simpli::abbreviateAll</definition>
        <argsstring>(csl::Expr &amp;res)</argsstring>
        <name>abbreviateAll</name>
        <qualifiedname>mty::simpli::abbreviateAll</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>res</declname>
        </param>
        <briefdescription>
<para>Abbreviates all the sub-expressions that are relevant. </para>
        </briefdescription>
        <detaileddescription>
<para>This function is more powerful than <ref refid="namespacemty_1_1simpli_1a5958ac15eb3a1ddeceefb8f1e80eb6d4" kindref="member">findAbbreviations()</ref> as it will also find external abbreviations (&quot;EXT&quot;) and momentum abbreviations (&quot;P&quot;)</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>res</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to abbreviate. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="119" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="119" bodyend="171" declfile="src/marty/core/amplitudeSimplification.h" declline="560" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a5958ac15eb3a1ddeceefb8f1e80eb6d4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool mty::simpli::findAbbreviations</definition>
        <argsstring>(csl::Expr &amp;res)</argsstring>
        <name>findAbbreviations</name>
        <qualifiedname>mty::simpli::findAbbreviations</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>res</declname>
        </param>
        <briefdescription>
<para>Abbreviates all the sub-expressions that are relevant considering constant factors only. </para>
        </briefdescription>
        <detaileddescription>
<para>This function is simply searches for combination of factors than can be grouped into a unique abbreviation &quot;Ab&quot;.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>res</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to abbreviate. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="173" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="173" bodyend="213" declfile="src/marty/core/amplitudeSimplification.h" declline="571" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a737874f5827e787bb508383bcb318f2b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void mty::simpli::applyDerivativesInStructure</definition>
        <argsstring>(csl::Expr &amp;expr)</argsstring>
        <name>applyDerivativesInStructure</name>
        <qualifiedname>mty::simpli::applyDerivativesInStructure</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Searches in the expression derived fields and applies the derivatives in the fields themselves. </para>
        </briefdescription>
        <detaileddescription>
<para><ref refid="classmty_1_1QuantumField" kindref="compound">QuantumField</ref> objects may carry an additional derivative indicial structure, that is used here to get simple quantum field objects (no derivative) while keeping the information about the Minkowski derivatives to use in the quantum calculation. This is equivalent to the analytical replacement / definition:   <formula id="56">\[
     \partial _\mu \Phi _A(X) \equiv \Phi_{A;\mu}(X)
\]</formula></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression in which the the function is applied. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="215" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="215" bodyend="226" declfile="src/marty/core/amplitudeSimplification.h" declline="588" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a7d825acc1e6c28129f1d4343a3810a69" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void mty::simpli::suppressDiracDelta</definition>
        <argsstring>(csl::Expr &amp;expr, csl::Expr const &amp;PSum)</argsstring>
        <name>suppressDiracDelta</name>
        <qualifiedname>mty::simpli::suppressDiracDelta</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>PSum</declname>
        </param>
        <briefdescription>
<para>Removes a dirac delta sub-expression. </para>
        </briefdescription>
        <detaileddescription>
<para>This function is used at the end of a quantum calculation to remove the <formula id="57">$ \delta ^{(4)}(\sum _i p_i) $</formula> (with <formula id="58">$ p_i $</formula> external momenta) that appears naturally but does not enter the final amplitude result. The momentum sum in the dirac delta to remove must be provided.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression in which </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PSum</parametername>
</parameternamelist>
<parameterdescription>
<para>Momentum sum appearing in the dirac delta to remove. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="228" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="228" bodyend="236" declfile="src/marty/core/amplitudeSimplification.h" declline="601" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1af8b12e71be659bd636a37a0425fe1325" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcolor_1_1ColorSpace" kindref="compound">color::ColorSpace</ref> const *</type>
        <definition>color::ColorSpace const  * mty::simpli::inColorSpace</definition>
        <argsstring>(csl::Index const &amp;index)</argsstring>
        <name>inColorSpace</name>
        <qualifiedname>mty::simpli::inColorSpace</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref> const &amp;</type>
          <declname>index</declname>
        </param>
        <briefdescription>
<para>Returns the colorspace associated to an index (nullptr if the index does not live in any ColorSpace). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>Index form which the space is obtained.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The pointer to const ColorSpace if the index lives in such a vector space. </para>
</simplesect>
<simplesect kind="return"><para>nullptr else </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="244" column="25" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="244" bodyend="247" declfile="src/marty/core/amplitudeSimplification.h" declline="103" declcolumn="25"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a97d26ecdb1396caad7a6cc4e6e4ed06c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcolor_1_1ColorSpace" kindref="compound">color::ColorSpace</ref> const *</type>
        <definition>color::ColorSpace const  * mty::simpli::isColorStructure</definition>
        <argsstring>(csl::IndexStructure const &amp;structure)</argsstring>
        <name>isColorStructure</name>
        <qualifiedname>mty::simpli::isColorStructure</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1IndexStructure" kindref="compound">csl::IndexStructure</ref> const &amp;</type>
          <declname>structure</declname>
        </param>
        <briefdescription>
<para>Returns the adjoint colorspace for a generator, nullptr for another structure.o. </para>
        </briefdescription>
        <detaileddescription>
<para>All indices of the structure must lie in a color space otherwise it is not a generator and this function returns nullptr. This allows to select only the objects that may want to simplify with each other !</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>structure</parametername>
</parameternamelist>
<parameterdescription>
<para>The index structure of the tensor to test.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The adjoint colorspace if the indexstructure is the one of a group generator. </para>
</simplesect>
<simplesect kind="return"><para>nullptr else.</para>
</simplesect>
<simplesect kind="see"><para><ref refid="namespacemty_1_1simpli_1af8b12e71be659bd636a37a0425fe1325" kindref="member">inColorSpace()</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="249" column="25" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="249" bodyend="259" declfile="src/marty/core/amplitudeSimplification.h" declline="122" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a4528358cb3b65b9dc13f6bcfaeb6c208" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcolor_1_1ColorSpace" kindref="compound">color::ColorSpace</ref> const *</type>
        <definition>color::ColorSpace const  * mty::simpli::isColorStructure</definition>
        <argsstring>(csl::Expr const &amp;expr)</argsstring>
        <name>isColorStructure</name>
        <qualifiedname>mty::simpli::isColorStructure</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Returns a colorspace if the expression is a color structure. </para>
        </briefdescription>
        <detaileddescription>
<para>This function should not be used for mixed color / non color expressions. In a mixed case, the behaviour is not defined. Otherwise, a colorspace will be returned independently of the complexity of the expression (if it is a color structure).</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tensor</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to test.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The color space associated to the expression if there is one </para>
</simplesect>
<simplesect kind="return"><para>nullptr else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="261" column="25" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="261" bodyend="279" declfile="src/marty/core/amplitudeSimplification.h" declline="137" declcolumn="25"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1ad4a03a8f3034208337fce7ee8a3d9b67" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1IndexStructure" kindref="compound">csl::IndexStructure</ref></type>
        <definition>csl::IndexStructure mty::simpli::colorStructure</definition>
        <argsstring>(csl::Expr const &amp;node, color::ColorSpace const *color)</argsstring>
        <name>colorStructure</name>
        <qualifiedname>mty::simpli::colorStructure</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>node</declname>
        </param>
        <param>
          <type><ref refid="classcolor_1_1ColorSpace" kindref="compound">color::ColorSpace</ref> const *</type>
          <declname>color</declname>
        </param>
        <briefdescription>
<para>Returns all color indices found in an expression lying in a particular color space. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>node</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to explore. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>color</parametername>
</parameternamelist>
<parameterdescription>
<para>Color space for which this function searches indices.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The IndexStructure containing all found indices. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="281" column="21" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="281" bodyend="298" declfile="src/marty/core/amplitudeSimplification.h" declline="148" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a416a755e48c0b88697e0db2ebbb03c85" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool mty::simpli::factorIndicial</definition>
        <argsstring>(csl::Expr &amp;res)</argsstring>
        <name>factorIndicial</name>
        <qualifiedname>mty::simpli::factorIndicial</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>res</declname>
        </param>
        <briefdescription>
<para>Factors indicial expressions in a bigger expression. </para>
        </briefdescription>
        <detaileddescription>
<para>This function is there mostly to compensate the lack of such a general function in CSL, that factors indicial tensors. This function is yet not very general and can probably not be used reliably to this purpose in other contexts.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>res</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to factor</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if something has been changed (factored). </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="300" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="300" bodyend="364" declfile="src/marty/core/amplitudeSimplification.h" declline="164" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1aad7ee4b14922752b3c5799a50e285271" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref></type>
        <definition>csl::Expr mty::simpli::colorAbbreviation</definition>
        <argsstring>(std::vector&lt; csl::Expr &gt; const &amp;exprs, std::vector&lt; color::ColorSpace const * &gt; const &amp;spaces)</argsstring>
        <name>colorAbbreviation</name>
        <qualifiedname>mty::simpli::colorAbbreviation</qualifiedname>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt; const &amp;</type>
          <declname>exprs</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcolor_1_1ColorSpace" kindref="compound">color::ColorSpace</ref> const * &gt; const &amp;</type>
          <declname>spaces</declname>
        </param>
        <briefdescription>
<para>Abbreviates color structure in expressions under the generic name &quot;Color&quot;. </para>
        </briefdescription>
        <detaileddescription>
<para>For all different terms this function tries to simplify first the expression before abbreviating it. If after simplification there is still color indices the result is encapsulated into an abbreviation, otherwise it is left as is.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>exprs</parametername>
</parameternamelist>
<parameterdescription>
<para>Different expressions containing color structures. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>spaces</parametername>
</parameternamelist>
<parameterdescription>
<para>Color spaces corresponding to the different expressions ( must be the same size as exprs). )</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The product of all abbreviated expressions in exprs. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="367" column="1" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="367" bodyend="414" declfile="src/marty/core/amplitudeSimplification.h" declline="183" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a59260f77d341fca0ba6b318dbb2ad740" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool mty::simpli::commonIndex</definition>
        <argsstring>(std::vector&lt; size_t &gt; const &amp;A, std::vector&lt; size_t &gt; const &amp;B)</argsstring>
        <name>commonIndex</name>
        <qualifiedname>mty::simpli::commonIndex</qualifiedname>
        <param>
          <type>std::vector&lt; size_t &gt; const &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>std::vector&lt; size_t &gt; const &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="416" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="416" bodyend="421"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1adc017a698953147662fe2eb943b1b115" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void mty::simpli::mergeIn</definition>
        <argsstring>(std::vector&lt; size_t &gt; &amp;target, std::vector&lt; size_t &gt; const &amp;toCopy)</argsstring>
        <name>mergeIn</name>
        <qualifiedname>mty::simpli::mergeIn</qualifiedname>
        <param>
          <type>std::vector&lt; size_t &gt; &amp;</type>
          <declname>target</declname>
        </param>
        <param>
          <type>std::vector&lt; size_t &gt; const &amp;</type>
          <declname>toCopy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="423" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="423" bodyend="429"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1ac6f5e0ce7ad486fad418b20ed7235794" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::vector&lt; size_t &gt; &gt;</type>
        <definition>std::vector&lt; std::vector&lt; size_t &gt; &gt; mty::simpli::findStructureMatches</definition>
        <argsstring>(std::vector&lt; csl::IndexStructure &gt; const &amp;structures)</argsstring>
        <name>findStructureMatches</name>
        <qualifiedname>mty::simpli::findStructureMatches</qualifiedname>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1IndexStructure" kindref="compound">csl::IndexStructure</ref> &gt; const &amp;</type>
          <declname>structures</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="432" column="1" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="432" bodyend="466"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1aea843bb6bbc61dd33eaa00b602a4e816" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool mty::simpli::expandInProd</definition>
        <argsstring>(csl::Expr &amp;prod, std::function&lt; csl::IndexStructure(csl::Expr const &amp;)&gt; const &amp;structureGetter)</argsstring>
        <name>expandInProd</name>
        <qualifiedname>mty::simpli::expandInProd</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>prod</declname>
        </param>
        <param>
          <type>std::function&lt; <ref refid="classcsl_1_1IndexStructure" kindref="compound">csl::IndexStructure</ref>(<ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>structureGetter</declname>
        </param>
        <briefdescription>
<para>Expands indicial expressions in a way avoiding unnecessary terms, in particular not expanding expressions that have no common index. </para>
        </briefdescription>
        <detaileddescription>
<para>This function takes as parameter another function that must return, for any expression, the index structure relevant for expansion (e.g. returning only Minkowski indices if the purpose is to expand Minkowski metric terms). The expansion will be performed between two sub-expressions if they have at least one common index by this mean.</para>
<para><simplesect kind="note"><para>Dev note : This function could now probably be replaced by the much more powerful and general csl::DeepPartialExpand() that can be tuned as will. This function is now used only in <ref refid="namespacemty_1_1simpli_1a9c391c8145cce9a2bd64e6a7c41772f4" kindref="member">expandColorIndices()</ref>.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>prod</parametername>
</parameternamelist>
<parameterdescription>
<para>Prod in which the expansion must take place. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>structureGetter</parametername>
</parameternamelist>
<parameterdescription>
<para>Function that must return the index structure of an expression relevant for the expansion.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if something has been expanded </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="468" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="468" bodyend="504" declfile="src/marty/core/amplitudeSimplification.h" declline="206" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a9c391c8145cce9a2bd64e6a7c41772f4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool mty::simpli::expandColorIndices</definition>
        <argsstring>(csl::Expr &amp;res)</argsstring>
        <name>expandColorIndices</name>
        <qualifiedname>mty::simpli::expandColorIndices</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>res</declname>
        </param>
        <briefdescription>
<para>Expands expressions containing color indices to allow all algebra simplifications. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>res</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression in which color indexed structures must be expanded.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if something has been expanded. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="506" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="506" bodyend="526" declfile="src/marty/core/amplitudeSimplification.h" declline="219" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1adec5dcc03bf4f46e88495988497be3f4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool mty::simpli::simplifyColorWeights</definition>
        <argsstring>(csl::Expr &amp;expr)</argsstring>
        <name>simplifyColorWeights</name>
        <qualifiedname>mty::simpli::simplifyColorWeights</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Calculates color traces in an expression. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to simplify.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if a simplification has taken place. </para>
</simplesect>
<simplesect kind="return"><para><bold>Fasle</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="528" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="528" bodyend="540" declfile="src/marty/core/amplitudeSimplification.h" declline="229" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a591814722e0636b9a7a5e048d2ac5524" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool mty::simpli::findColorAbbreviation</definition>
        <argsstring>(csl::Expr &amp;expr)</argsstring>
        <name>findColorAbbreviation</name>
        <qualifiedname>mty::simpli::findColorAbbreviation</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Abbreviates color structures in an expression under the generic name &quot;Color&quot;. </para>
        </briefdescription>
        <detaileddescription>
<para>This function gathers all colorstructures of possibly different vector spaces and then calls <ref refid="namespacemty_1_1simpli_1aad7ee4b14922752b3c5799a50e285271" kindref="member">colorAbbreviation()</ref> to effectively determine an abbreviation for each different space.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to abbreviate.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if the expression has been abbreviated in some way. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="542" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="542" bodyend="568" declfile="src/marty/core/amplitudeSimplification.h" declline="244" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a1fb24f2984418e7b90de2c71ae24bf42" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>static bool mty::simpli::hasCommonIndex</definition>
        <argsstring>(csl::Expr const &amp;A, csl::Expr const &amp;B, csl::Space const *space=nullptr)</argsstring>
        <name>hasCommonIndex</name>
        <qualifiedname>mty::simpli::hasCommonIndex</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>B</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Space" kindref="compound">csl::Space</ref> const *</type>
          <declname>space</declname>
          <defval>nullptr</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="576" column="13" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="576" bodyend="596"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1ac542f571c9519f8914f232f4f8a513c2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool mty::simpli::expandMinkoStructures</definition>
        <argsstring>(csl::Expr &amp;expr)</argsstring>
        <name>expandMinkoStructures</name>
        <qualifiedname>mty::simpli::expandMinkoStructures</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Expands Minkowski structures to contract all possible indices. </para>
        </briefdescription>
        <detaileddescription>
<para>This function calls <ref refid="namespacemty_1_1simpli_1a0a44184cc5f79c73a5ef8b8979ee682c" kindref="member">expandMinkoMetric()</ref> and <ref refid="namespacemty_1_1simpli_1ae91acd9ead4caa5260fed816f468383d" kindref="member">expandMinkoEpsilon()</ref> successively.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression in which Minkowski structures must be expanded.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if something has been expanded. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="598" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="598" bodyend="603" declfile="src/marty/core/amplitudeSimplification.h" declline="263" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a0a44184cc5f79c73a5ef8b8979ee682c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool mty::simpli::expandMinkoMetric</definition>
        <argsstring>(csl::Expr &amp;expr)</argsstring>
        <name>expandMinkoMetric</name>
        <qualifiedname>mty::simpli::expandMinkoMetric</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Expands Minkowski metrics to contract all possible indices. </para>
        </briefdescription>
        <detaileddescription>
<para>This function only expand sub-terms that allow to contract one metric with another tensor that has a common index. All other terms are let in sums, not expanded.</para>
<para><simplesect kind="note"><para>Dev note : This is using the emitter / receiver pattern of csl::DeepPartialExpand(): to use without moderation !</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression in which Minkowski metric terms must be expanded.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if something has been expanded. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="605" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="605" bodyend="638" declfile="src/marty/core/amplitudeSimplification.h" declline="280" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1ae91acd9ead4caa5260fed816f468383d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool mty::simpli::expandMinkoEpsilon</definition>
        <argsstring>(csl::Expr &amp;expr)</argsstring>
        <name>expandMinkoEpsilon</name>
        <qualifiedname>mty::simpli::expandMinkoEpsilon</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Expands Minkowski epsilon symbols to contract all possible indices. </para>
        </briefdescription>
        <detaileddescription>
<para>This function only expand sub-terms that allow to contract one epsilon with another tensor that has a common index. All other terms are let in sums, not expanded.</para>
<para><simplesect kind="note"><para>Dev note : This is using the emitter / receiver pattern of csl::DeepPartialExpand(): to use without moderation !</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression in which Minkowski epsilon terms must be expanded.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if something has been expanded. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="640" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="640" bodyend="660" declfile="src/marty/core/amplitudeSimplification.h" declline="298" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1ad3d1e2cf63d4e03b3d5a9bf1d356c4e2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool mty::simpli::simplifyEpsilonInProd</definition>
        <argsstring>(csl::Expr &amp;prod, csl::IndexStructure &amp;indices)</argsstring>
        <name>simplifyEpsilonInProd</name>
        <qualifiedname>mty::simpli::simplifyEpsilonInProd</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>prod</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1IndexStructure" kindref="compound">csl::IndexStructure</ref> &amp;</type>
          <declname>indices</declname>
        </param>
        <briefdescription>
<para>Simplifies the contraction of an epsilon tensor with a symmetric structure index. </para>
        </briefdescription>
        <detaileddescription>
<para>This function is fully general and tries to swap indices that are contracted with the epsilon tensor to detect a symmetry. If a symmetry is detected, then the result is zero.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>prod</parametername>
</parameternamelist>
<parameterdescription>
<para>Product to simplify ni which the epsilon tensor has been removed. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>indices</parametername>
</parameternamelist>
<parameterdescription>
<para>Indices of the initial epsilon tensor.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if a simplification has been found (the result is zero). </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="662" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="662" bodyend="697" declfile="src/marty/core/amplitudeSimplification.h" declline="315" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a2ba6306b29a99b72b1d1f9e931eff273" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool mty::simpli::simplifyEpsilon</definition>
        <argsstring>(csl::Expr &amp;expr)</argsstring>
        <name>simplifyEpsilon</name>
        <qualifiedname>mty::simpli::simplifyEpsilon</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Simplifies epsilon contractions with symmetric indices in an expression. </para>
        </briefdescription>
        <detaileddescription>
<para>This function detects all epsilon tensors in a product and calls <ref refid="namespacemty_1_1simpli_1ad3d1e2cf63d4e03b3d5a9bf1d356c4e2" kindref="member">simplifyEpsilonInProd()</ref> to simplify it if it is contracted with symmetric indices.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to simplify.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if a simplification has been found. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="699" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="699" bodyend="724" declfile="src/marty/core/amplitudeSimplification.h" declline="330" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a09f3d94491ec0e4d66bf56b76d087761" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool mty::simpli::expandGammaMatrices</definition>
        <argsstring>(csl::Expr &amp;expr)</argsstring>
        <name>expandGammaMatrices</name>
        <qualifiedname>mty::simpli::expandGammaMatrices</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Expands gamma matrices in an expression to be able to simplify fermion chains (and traces). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to simplify.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if a simplification has been found. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="726" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="726" bodyend="746" declfile="src/marty/core/amplitudeSimplification.h" declline="341" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1aebe08dc0b5975fdba7c1016906abf1b8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool mty::simpli::simplifyFermionChains</definition>
        <argsstring>(csl::Expr &amp;expr)</argsstring>
        <name>simplifyFermionChains</name>
        <qualifiedname>mty::simpli::simplifyFermionChains</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Simplifies fermion chains using the <ref refid="classmty_1_1FermionChain" kindref="compound">mty::FermionChain</ref> utility. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to simplify.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if a simplification has been found. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="748" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="748" bodyend="766" declfile="src/marty/core/amplitudeSimplification.h" declline="351" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a91d05cacc04ad78fe84378a10d93f9f8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void mty::simpli::expandForFermionOrdering</definition>
        <argsstring>(csl::Expr &amp;expr)</argsstring>
        <name>expandForFermionOrdering</name>
        <qualifiedname>mty::simpli::expandForFermionOrdering</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Forces the ordering of external fermions by making sure that all Dirac structures are expanded. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to expand. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="768" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="768" bodyend="791" declfile="src/marty/core/amplitudeSimplification.h" declline="359" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a1fe3fc2697e4a3e79e8a7057d0891f5d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void mty::simpli::expandMomentaExperimental</definition>
        <argsstring>(csl::Expr &amp;res, std::vector&lt; csl::Tensor &gt; const &amp;momenta)</argsstring>
        <name>expandMomentaExperimental</name>
        <qualifiedname>mty::simpli::expandMomentaExperimental</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>res</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref> &gt; const &amp;</type>
          <declname>momenta</declname>
        </param>
        <briefdescription>
<para>Expands expressions containing momenta to contract all indices, typically replacing <formula id="50">$ p_i^\mu\cdot p_{j\mu} \mapsto s_{ij} $</formula>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>res</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to expand. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>momenta</parametername>
</parameternamelist>
<parameterdescription>
<para>Set of momenta involved. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="793" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="793" bodyend="816" declfile="src/marty/core/amplitudeSimplification.h" declline="374" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a8eadaa005ab2b8b01e1c0127dac486b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void mty::simpli::reduceTensorIntegrals</definition>
        <argsstring>(csl::Expr &amp;expr)</argsstring>
        <name>reduceTensorIntegrals</name>
        <qualifiedname>mty::simpli::reduceTensorIntegrals</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Replaces the one-loop momentum integrals by their reduced form depending on scalar integrals. </para>
        </briefdescription>
        <detaileddescription>
<para>The scalar integrals are later evaluated numerically using the LoopTools library.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to simplify. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="818" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="818" bodyend="834" declfile="src/marty/core/amplitudeSimplification.h" declline="385" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a2ad88b7f6d66d939229c04c6dbeef5f4" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>static bool mty::simpli::compareFields</definition>
        <argsstring>(QuantumField const &amp;A, QuantumField const &amp;B)</argsstring>
        <name>compareFields</name>
        <qualifiedname>mty::simpli::compareFields</qualifiedname>
        <param>
          <type><ref refid="classmty_1_1QuantumField" kindref="compound">QuantumField</ref> const &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classmty_1_1QuantumField" kindref="compound">QuantumField</ref> const &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="836" column="13" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="836" bodyend="843"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a6f1c7802c1057b62a864edae2ed3f965" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::pair&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref>, <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt;</type>
        <definition>std::pair&lt; csl::Expr, csl::Expr &gt; mty::simpli::getMomentumReplacement</definition>
        <argsstring>(std::vector&lt; mty::QuantumField &gt; const &amp;insertions, std::vector&lt; csl::Tensor &gt; const &amp;momenta, size_t posReplaced)</argsstring>
        <name>getMomentumReplacement</name>
        <qualifiedname>mty::simpli::getMomentumReplacement</qualifiedname>
        <param>
          <type>std::vector&lt; <ref refid="classmty_1_1QuantumField" kindref="compound">mty::QuantumField</ref> &gt; const &amp;</type>
          <declname>insertions</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref> &gt; const &amp;</type>
          <declname>momenta</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>posReplaced</declname>
        </param>
        <briefdescription>
<para>Creates the relevant replacement (using momentum conservation) to replace one particular momentum. </para>
        </briefdescription>
        <detaileddescription>
<para>The two elements returned in a pair can be used directly in a csl replacement function on a particular expression as presented in the following sample code <programlisting><codeline><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>[p,<sp/>momentumEquivalent]<sp/>=<sp/><ref refid="namespacemty_1_1simpli_1a6f1c7802c1057b62a864edae2ed3f965" kindref="member">getMomentumReplacement</ref>(args...);</highlight></codeline>
<codeline><highlight class="normal">csl::Replace(amplitude,<sp/>p,<sp/>momentumEquivalent);</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>insertions</parametername>
</parameternamelist>
<parameterdescription>
<para>Insertions for the process. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>momenta</parametername>
</parameternamelist>
<parameterdescription>
<para>Set of external momenta of the process. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>posReplaced</parametername>
</parameternamelist>
<parameterdescription>
<para>Position of the momentum (in <bold>momenta</bold>) that must be replaced by the relevant combination of the others.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A pair containing the momentum replacement to forward to csl::Replace(). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="846" column="1" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="846" bodyend="861" declfile="src/marty/core/amplitudeSimplification.h" declline="419" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a00baa52064602d01f64436b0ff9e61c9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void mty::simpli::replaceMomentum</definition>
        <argsstring>(csl::Expr &amp;init, std::vector&lt; mty::QuantumField &gt; const &amp;insertions, std::vector&lt; csl::Tensor &gt; const &amp;momenta, size_t posReplaced)</argsstring>
        <name>replaceMomentum</name>
        <qualifiedname>mty::simpli::replaceMomentum</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classmty_1_1QuantumField" kindref="compound">mty::QuantumField</ref> &gt; const &amp;</type>
          <declname>insertions</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref> &gt; const &amp;</type>
          <declname>momenta</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>posReplaced</declname>
        </param>
        <briefdescription>
<para>Applies the momentum conservation by replacing one of the external momenta by the combination of the others. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression in which the momentum conservation is applied. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>insertions</parametername>
</parameternamelist>
<parameterdescription>
<para>Insertions for the process. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>momenta</parametername>
</parameternamelist>
<parameterdescription>
<para>Set of external momenta of the process. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>posReplaced</parametername>
</parameternamelist>
<parameterdescription>
<para>Position of the momentum (in <bold>momenta</bold>) that must be replaced by the relevant combination of the others.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="namespacemty_1_1simpli_1a6f1c7802c1057b62a864edae2ed3f965" kindref="member">getMomentumReplacement()</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="863" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="863" bodyend="871" declfile="src/marty/core/amplitudeSimplification.h" declline="435" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1ae27b0f1a0f164eb80dab0a68ba0f74fe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void mty::simpli::simplifyImpulsions</definition>
        <argsstring>(csl::Expr &amp;init, std::vector&lt; mty::QuantumField &gt; const &amp;insertions, std::vector&lt; csl::Tensor &gt; const &amp;momenta)</argsstring>
        <name>simplifyImpulsions</name>
        <qualifiedname>mty::simpli::simplifyImpulsions</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classmty_1_1QuantumField" kindref="compound">mty::QuantumField</ref> &gt; const &amp;</type>
          <declname>insertions</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref> &gt; const &amp;</type>
          <declname>momenta</declname>
        </param>
        <briefdescription>
<para>Applies the momentum conservation by replacing one of the external momenta by the combination of the others. </para>
        </briefdescription>
        <detaileddescription>
<para>The momentum that is to be replaced is chosen automatically by this function following an ordering rule for the external fields. To maximize the possible simplifications, the momentum that are kept are those of on-shell fermions (because they can later be simplified later on through the Dirac equation). This function calls <ref refid="namespacemty_1_1simpli_1a00baa52064602d01f64436b0ff9e61c9" kindref="member">replaceMomentum()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression in which the momentum conservation is applied. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>insertions</parametername>
</parameternamelist>
<parameterdescription>
<para>Insertions for the process. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>momenta</parametername>
</parameternamelist>
<parameterdescription>
<para>Set of external momenta of the process. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="873" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="873" bodyend="883" declfile="src/marty/core/amplitudeSimplification.h" declline="455" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a693e77ff59ed0f4cc92e8391dcd62165" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void mty::simpli::applyEOM</definition>
        <argsstring>(csl::Expr &amp;ampl, std::vector&lt; FermionEOMData &gt; &amp;onShellFermions)</argsstring>
        <name>applyEOM</name>
        <qualifiedname>mty::simpli::applyEOM</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>ampl</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="structmty_1_1simpli_1_1FermionEOMData" kindref="compound">FermionEOMData</ref> &gt; &amp;</type>
          <declname>onShellFermions</declname>
        </param>
        <briefdescription>
<para>Applies the equations of motions in an expression. </para>
        </briefdescription>
        <detaileddescription>
<para>This function uses the SGL (Symbolic Gamma-matrices <ref refid="classmty_1_1Library" kindref="compound">Library</ref>), a module of MARTY specialized in this purpose, to apply the EOM in fermion currents.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ampl</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression in which the EOM must be applied. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>onShellFermions</parametername>
</parameternamelist>
<parameterdescription>
<para>On-shell fermions. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="885" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="885" bodyend="911" declfile="src/marty/core/amplitudeSimplification.h" declline="469" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a0ba14eddf9871870fedb0e8270747435" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void mty::simpli::applyEOM</definition>
        <argsstring>(csl::Expr &amp;ampl, std::vector&lt; mty::QuantumField &gt; const &amp;insertions, std::vector&lt; csl::Tensor &gt; const &amp;momenta)</argsstring>
        <name>applyEOM</name>
        <qualifiedname>mty::simpli::applyEOM</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>ampl</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classmty_1_1QuantumField" kindref="compound">mty::QuantumField</ref> &gt; const &amp;</type>
          <declname>insertions</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref> &gt; const &amp;</type>
          <declname>momenta</declname>
        </param>
        <briefdescription>
<para>Applies the equations of motion in an expression. </para>
        </briefdescription>
        <detaileddescription>
<para>This function detects all the on-shell fermions for the process and call the other overload of <ref refid="namespacemty_1_1simpli_1a693e77ff59ed0f4cc92e8391dcd62165" kindref="member">applyEOM()</ref> to effectively apply the Dirac equation.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ampl</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression in which the EOM must be applied. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>insertions</parametername>
</parameternamelist>
<parameterdescription>
<para>Field insertions for the process. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>momenta</parametername>
</parameternamelist>
<parameterdescription>
<para>External momenta corresponding to the field insertions. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="913" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="913" bodyend="940" declfile="src/marty/core/amplitudeSimplification.h" declline="482" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a742f9d537b200e8b089942c25cad7c93" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void mty::simpli::simplify</definition>
        <argsstring>(csl::Expr &amp;expr, std::vector&lt; mty::QuantumField &gt; const &amp;insertions, std::vector&lt; csl::Tensor &gt; const &amp;momenta, mty::FeynOptions const &amp;options, Mode mode)</argsstring>
        <name>simplify</name>
        <qualifiedname>mty::simpli::simplify</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classmty_1_1QuantumField" kindref="compound">mty::QuantumField</ref> &gt; const &amp;</type>
          <declname>insertions</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref> &gt; const &amp;</type>
          <declname>momenta</declname>
        </param>
        <param>
          <type><ref refid="classmty_1_1FeynOptions" kindref="compound">mty::FeynOptions</ref> const &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type><ref refid="namespacemty_1_1simpli_1a22014bda2756a975f0764a174914aff0" kindref="member">Mode</ref></type>
          <declname>mode</declname>
        </param>
        <briefdescription>
<para>Main simplification routine of MARTY, used for amplitudes, squared amplitude and <ref refid="structmty_1_1Wilson" kindref="compound">Wilson</ref> coefficients. </para>
        </briefdescription>
        <detaileddescription>
<para>This function for now is used for all calculations in MARTY with minor differences (handled through the mode given as a parameter). It calls directly or indirectly all the other functions in this file to simplify Dirac algebra, Group algebra, Equations of motions, momentum integrals, introducing abbreviations etc.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to simplify. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>insertions</parametername>
</parameternamelist>
<parameterdescription>
<para>Insertions of the process. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>momenta</parametername>
</parameternamelist>
<parameterdescription>
<para>External momenta corresponding to the field insertions. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>Simplification mode specifying if the expression is an amplitude, squared amplitude or <ref refid="structmty_1_1Wilson" kindref="compound">Wilson</ref> coefficient. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.cpp" line="942" column="6" bodyfile="src/marty/core/amplitudeSimplification.cpp" bodystart="942" bodyend="1055" declfile="src/marty/core/amplitudeSimplification.h" declline="81" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1aceea2d9d41cc57141e3ad47e08c216be" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void mty::simpli::addLocalTerms</definition>
        <argsstring>(csl::Expr &amp;res)</argsstring>
        <name>addLocalTerms</name>
        <qualifiedname>mty::simpli::addLocalTerms</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>res</declname>
        </param>
        <briefdescription>
<para>Adds the local terms in an expression. </para>
        </briefdescription>
        <detaileddescription>
<para>This function is defined in dimensionalRegularization.cpp but the declaration is reminded. Local terms are added when, in dim. reg., the Minkowki space dimension <formula id="51">$ D = 4 - 2\epsilon $</formula> is multiplied by a divergent integral  <formula id="52">$ I = \frac{a}{\epsilon}  + b +
\mathcal{O}(\epsilon)$</formula>, as the epsilon terms cancel each other to produce another constant term. In this simple case we obtain (removing the purely divergent term):  <formula id="53">\[ D\cdot I = (4 - 2\epsilon)(\frac{a}{\epsilon} + b) = 4b
+ Local, \]</formula> with <formula id="54">\[ Local = -2a. \]</formula></para>
<para><simplesect kind="warning"><para>This uses a simple algorithm to parse the total <formula id="55">$ D $</formula> factors mutiplying integrals but works only for non-factored expressions. This is fine as long as, in the main simplification chain, the amplitude is factored <bold>after</bold> this function is called.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>res</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression in which local terms are added. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/dimensionalRegularization.cpp" line="39" column="6" bodyfile="src/marty/core/dimensionalRegularization.cpp" bodystart="39" bodyend="81" declfile="src/marty/core/dimensionalRegularization.h" declline="32" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a7756b89c26ef28891e15b3790ed00379" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool mty::simpli::maybeSimplified</definition>
        <argsstring>(csl::Expr const &amp;expr)</argsstring>
        <name>maybeSimplified</name>
        <qualifiedname>mty::simpli::maybeSimplified</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Helper function that tells if an expression may be simplified in amplitudes. </para>
        </briefdescription>
        <detaileddescription>
<para>If this function returns false, the main simplification routines can remove the expression from the amplitude to pass all simplification steps and put it back at the end to save unnecessary calculations.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to check if it may be simplified.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if the expression must not be discarded. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/amplitudeSimplification.h" line="526" column="6" declfile="src/marty/core/amplitudeSimplification.h" declline="526" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacemty_1_1simpli_1a8a0baea395581f04d0f07936d5117b0f" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int mty::simpli::getDMinkoPower</definition>
        <argsstring>(csl::Expr const &amp;expr)</argsstring>
        <name>getDMinkoPower</name>
        <qualifiedname>mty::simpli::getDMinkoPower</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/marty/core/dimensionalRegularization.cpp" line="25" column="12" bodyfile="src/marty/core/dimensionalRegularization.cpp" bodystart="25" bodyend="37"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>Namespace containing the main simplification method for MARTY and all its dependencies. </para>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="src/marty/core/amplitudeSimplification.cpp" line="32" column="1"/>
  </compounddef>
</doxygen>
