<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.12.0" xml:lang="en-US">
  <compounddef id="classcsl_1_1AbstractFunc" kind="class" language="C++" prot="public">
    <compoundname>csl::AbstractFunc</compoundname>
    <basecompoundref refid="classcsl_1_1Abstract" prot="public" virt="non-virtual">csl::Abstract</basecompoundref>
    <derivedcompoundref refid="classcsl_1_1Operator" prot="public" virt="non-virtual">csl::Operator&lt; AbstractFunc &gt;</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1Operator" prot="public" virt="non-virtual">csl::Operator&lt; csl::AbstractFunc &gt;</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1ACos" prot="public" virt="non-virtual">csl::ACos</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1ACosh" prot="public" virt="non-virtual">csl::ACosh</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1ASin" prot="public" virt="non-virtual">csl::ASin</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1ASinh" prot="public" virt="non-virtual">csl::ASinh</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1ATan" prot="public" virt="non-virtual">csl::ATan</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1ATanh" prot="public" virt="non-virtual">csl::ATanh</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1Abs" prot="public" virt="non-virtual">csl::Abs</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1Cos" prot="public" virt="non-virtual">csl::Cos</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1Cosh" prot="public" virt="non-virtual">csl::Cosh</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1DiracDelta" prot="public" virt="non-virtual">csl::DiracDelta</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1Exp" prot="public" virt="non-virtual">csl::Exp</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1Factorial" prot="public" virt="non-virtual">csl::Factorial</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1Log" prot="public" virt="non-virtual">csl::Log</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1Sin" prot="public" virt="non-virtual">csl::Sin</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1Sinh" prot="public" virt="non-virtual">csl::Sinh</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1Tan" prot="public" virt="non-virtual">csl::Tan</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1Tanh" prot="public" virt="non-virtual">csl::Tanh</derivedcompoundref>
    <includes refid="scalarFunc_8h" local="no">scalarFunc.h</includes>
    <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="classcsl_1_1AbstractFunc_1a9ffcf8afbee0a103421280b82cfffe05" prot="protected" static="no" mutable="no">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::AbstractFunc::argument</definition>
        <argsstring></argsstring>
        <name>argument</name>
        <qualifiedname>csl::AbstractFunc::argument</qualifiedname>
        <briefdescription>
<para>Argument of the considered function. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="41" column="10" bodyfile="src/csl/scalarFunc.h" bodystart="41" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1a5fdb13c5df0c5d7201378c183acb31fa" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>csl::AbstractFunc::AbstractFunc</definition>
        <argsstring>()</argsstring>
        <name>AbstractFunc</name>
        <qualifiedname>csl::AbstractFunc::AbstractFunc</qualifiedname>
        <briefdescription>
<para>Default constructor. </para>
        </briefdescription>
        <detaileddescription>
<para>Initializes the argument to <bold>0</bold> (Number). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="47" column="5" bodyfile="src/csl/scalarFunc.h" bodystart="499" bodyend="501"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1af7f0cfa8c7fa35fe5cdadb16f4068c80" prot="public" static="no" const="no" explicit="yes" inline="yes" virt="non-virtual">
        <type></type>
        <definition>csl::AbstractFunc::AbstractFunc</definition>
        <argsstring>(const Expr &amp;t_argument)</argsstring>
        <name>AbstractFunc</name>
        <qualifiedname>csl::AbstractFunc::AbstractFunc</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>t_argument</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="49" column="14" bodyfile="src/csl/scalarFunc.h" bodystart="502" bodyend="505"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1a18df1a5dbd7c9c75b1704fe958a55a5d" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type><ref refid="namespacecsl_1a70046459ec0082db8cb97005c13c9a54" kindref="member">csl::PrimaryType</ref></type>
        <definition>csl::PrimaryType csl::AbstractFunc::getPrimaryType</definition>
        <argsstring>() const override</argsstring>
        <name>getPrimaryType</name>
        <qualifiedname>csl::AbstractFunc::getPrimaryType</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a8ab79682cdff4c7d7b52c2e70ac23d85">getPrimaryType</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Gives the <bold>primary type</bold> of an <ref refid="classcsl_1_1AbstractFunc" kindref="compound">AbstractFunc</ref>. <simplesect kind="return"><para><bold>20</bold> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="54" column="22" bodyfile="src/csl/scalarFunc.h" bodystart="54" bodyend="57"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1ab41faa67ed807f3cc2c95f5f175e9099" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::AbstractFunc::getCommutable</definition>
        <argsstring>() const override</argsstring>
        <name>getCommutable</name>
        <qualifiedname>csl::AbstractFunc::getCommutable</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a2263731ca94825f35281e69fb258cf87">getCommutable</reimplements>
        <reimplementedby refid="classcsl_1_1ImaginaryPart_1a2cb758975b92a34387f83895e261defe">getCommutable</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1aa26c6f1e6a43ab0d529c170466e810b0">getCommutable</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1aa26c6f1e6a43ab0d529c170466e810b0">getCommutable</reimplementedby>
        <reimplementedby refid="classcsl_1_1RealPart_1a0da475d679751428325bac460a651d85">getCommutable</reimplementedby>
        <briefdescription>
<para>Tells if the <ref refid="classcsl_1_1AbstractFunc" kindref="compound">AbstractFunc</ref> is commutable. </para>
        </briefdescription>
        <detaileddescription>
<para>The commutability of a function depends on the one of its <bold>argument</bold>. <simplesect kind="return"><para><bold>True</bold> if the <ref refid="classcsl_1_1AbstractFunc" kindref="compound">AbstractFunc</ref> is commutable. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="65" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="39" bodyend="42"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1a0d3f88b1d12d0900184101720f8e345b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::vector&lt; <ref refid="classcsl_1_1Parent" kindref="compound">csl::Parent</ref> &gt;</type>
        <definition>std::vector&lt; csl::Parent &gt; csl::AbstractFunc::getSubSymbols</definition>
        <argsstring>() const override</argsstring>
        <name>getSubSymbols</name>
        <qualifiedname>csl::AbstractFunc::getSubSymbols</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a4e69280b624b0e0c932f1cfa7417b55f">getSubSymbols</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="67" column="17" bodyfile="src/csl/scalarFunc.cpp" bodystart="44" bodyend="47"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1a25e37d9d40927ef216a5b10958fa83ba" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::AbstractFunc::isIndexed</definition>
        <argsstring>() const override</argsstring>
        <name>isIndexed</name>
        <qualifiedname>csl::AbstractFunc::isIndexed</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a216b7bd3930fbf047e5bf8f69e9b964c">isIndexed</reimplements>
        <reimplementedby refid="classcsl_1_1VectorIntegral_1ab3961d7313002bd6e4d0c342bd2cd9a1">isIndexed</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><bold>True</bold> if the expression is indexed. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="69" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="49" bodyend="52"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1ab02f71922f94812d9ef24766ce51aaa2" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>size_t</type>
        <definition>size_t csl::AbstractFunc::size</definition>
        <argsstring>() const override</argsstring>
        <name>size</name>
        <qualifiedname>csl::AbstractFunc::size</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a3794843945b8a39e2c1be073c9bacdf5">size</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="71" column="12" bodyfile="src/csl/scalarFunc.cpp" bodystart="34" bodyend="37"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1af16a648041a09ff87602427add048ee0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::AbstractFunc::compareWithDummy</definition>
        <argsstring>(Expr_info expr, std::map&lt; Index, Index &gt; &amp;constraints, bool keepAllCosntraints=false) const override</argsstring>
        <name>compareWithDummy</name>
        <qualifiedname>csl::AbstractFunc::compareWithDummy</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a7caee12abb451168149779a668dfc59e">compareWithDummy</reimplements>
        <reimplementedby refid="classcsl_1_1VectorIntegral_1a6a1e720e6db9d81db825d18cea8a334a">compareWithDummy</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::map&lt; <ref refid="classcsl_1_1Index" kindref="compound">Index</ref>, <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &gt; &amp;</type>
          <declname>constraints</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>keepAllCosntraints</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Comparison disregarding name of dummy indices, i.e. the two expressions * are equals even if dummy indices have not the same names in *this and * expr. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to compare.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>constraints</parametername>
</parameternamelist>
<parameterdescription>
<para>List of existing constraints between indices (it is modified in the function).</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if expr == *this taking constraints into account. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="73" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="54" bodyend="64"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1a53ef9c900304f02f54ce6ea1485b4537" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1IndexStructure" kindref="compound">IndexStructure</ref></type>
        <definition>IndexStructure csl::AbstractFunc::getIndexStructure</definition>
        <argsstring>() const override</argsstring>
        <name>getIndexStructure</name>
        <qualifiedname>csl::AbstractFunc::getIndexStructure</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1ae125a32b6f3d0368b6055d4e58c1ff3f">getIndexStructure</reimplements>
        <reimplementedby refid="classcsl_1_1VectorIntegral_1a2b23eb2012ae1b985e0e2318f11cf3f5">getIndexStructure</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The index structure of the <bold>Indicial</bold> expression </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="77" column="20" bodyfile="src/csl/scalarFunc.cpp" bodystart="66" bodyend="69"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1a9d3a9a67f2990981805efd146e6fc6fe" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor csl::AbstractFunc::getPoint</definition>
        <argsstring>() const override</argsstring>
        <name>getPoint</name>
        <qualifiedname>csl::AbstractFunc::getPoint</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a06b32036fea6a2583f506a6ef9508d74">getPoint</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="79" column="12" bodyfile="src/csl/scalarFunc.cpp" bodystart="71" bodyend="74"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1ae32e5909a9d7616ceac05b22a74b1284" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>int</type>
        <definition>int csl::AbstractFunc::getNArgs</definition>
        <argsstring>(int axis=0) const override</argsstring>
        <name>getNArgs</name>
        <qualifiedname>csl::AbstractFunc::getNArgs</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aa034448201c9e7998bbbb5e409636b30">getNArgs</reimplements>
        <param>
          <type>int</type>
          <declname>axis</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Returns the number of arguments of the expression. If the expression is a building block (<ref refid="classcsl_1_1AbstractBuildingBlock" kindref="compound">AbstractBuildingBlock</ref>), this function returns 0. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The number of arguments of the expression. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="81" column="9" bodyfile="src/csl/scalarFunc.cpp" bodystart="76" bodyend="79"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1adf8cb8650883f5ea7729cdabec2aeab0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
        <definition>Expr const  &amp; csl::AbstractFunc::getArgument</definition>
        <argsstring>(int iArg=0) const override</argsstring>
        <name>getArgument</name>
        <qualifiedname>csl::AbstractFunc::getArgument</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1ac33a42309d629d47bfdbede4e152414e">getArgument</reimplements>
        <param>
          <type>int</type>
          <declname>iArg</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Returns the <bold>argument</bold> of the function. </para>
        </briefdescription>
        <detaileddescription>
<para>The parameter <emphasis>iArg</emphasis> is usefull for <ref refid="classcsl_1_1AbstractMultiFunc" kindref="compound">AbstractMultiFunc</ref>. It is present ere in order to have only one access function for arguments in the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> class. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iArg</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> of the argument, silent here. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>argument</bold> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="90" column="16" bodyfile="src/csl/scalarFunc.cpp" bodystart="81" bodyend="84"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1af02355fee3c7cda15993cfcf553d6f92" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
        <definition>Expr &amp; csl::AbstractFunc::getArgument</definition>
        <argsstring>(int iArg=0) override</argsstring>
        <name>getArgument</name>
        <qualifiedname>csl::AbstractFunc::getArgument</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a06f542034e95744148f4fce5a4893e63">getArgument</reimplements>
        <param>
          <type>int</type>
          <declname>iArg</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="92" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="86" bodyend="89"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1ae6828f21be014625ca502d5f40981502" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::AbstractFunc::isReal</definition>
        <argsstring>() const override</argsstring>
        <name>isReal</name>
        <qualifiedname>csl::AbstractFunc::isReal</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1ac73aba0c48a4b5740f7bfa09e438ca99">isReal</reimplements>
        <reimplementedby refid="classcsl_1_1ImaginaryPart_1ae015127b4d5f86a99e0914b48b2d7e18">isReal</reimplementedby>
        <reimplementedby refid="classcsl_1_1RealPart_1afe8b4b055b05d67927ff177b8c5e0d94">isReal</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="94" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="91" bodyend="94"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1ade1aa692134fee323c2a20824932b506" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::AbstractFunc::isPurelyImaginary</definition>
        <argsstring>() const override</argsstring>
        <name>isPurelyImaginary</name>
        <qualifiedname>csl::AbstractFunc::isPurelyImaginary</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1acb67e8e96735b8f116d0e7ab33d7be77">isPurelyImaginary</reimplements>
        <reimplementedby refid="classcsl_1_1ImaginaryPart_1a0eaf96b5e9c097907357acb5cd637130">isPurelyImaginary</reimplementedby>
        <reimplementedby refid="classcsl_1_1RealPart_1a794e67cfc724500de30cf4de91f81d63">isPurelyImaginary</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="96" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="96" bodyend="99"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1ab1d0e4f2b4d063838158829972c2160a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>std::optional&lt; Expr &gt; csl::AbstractFunc::getRealPart</definition>
        <argsstring>() const override</argsstring>
        <name>getRealPart</name>
        <qualifiedname>csl::AbstractFunc::getRealPart</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a415f64fdddaae445014d5e052956f889">getRealPart</reimplements>
        <reimplementedby refid="classcsl_1_1ACos_1a16301f8ed54cac63ac5389fc179f24d6">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASin_1ac0f8218b321a2294612e25d3e57c2318">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cos_1addc14896700e9950baee3374a09b558d">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cosh_1a3d88db8dd64a46ef1cc70b1a0d19bca3">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1DiracDelta_1af86344bc4071f901591cc1b50b915257">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Exp_1a3e803100efb959d15e40b0e69aa9a369">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Log_1ab37426baaea4c8e148ee683b488d0fb2">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sin_1a35ffd397f83edf315fd120c96f44063a">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sinh_1a5888952203e8271368e1aa19681afac4">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tan_1a89fd2f3ff51edc27812a0440189da5cc">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tanh_1a64eca21f5e81ff0a85e9d2bbd919edcd">getRealPart</reimplementedby>
        <briefdescription>
<para><bold>Evaluates</bold> the <bold>real part</bold> of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> and returns it. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The real part of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="98" column="19" bodyfile="src/csl/scalarFunc.cpp" bodystart="101" bodyend="104"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1a24aee4ffda2255a56fd2eb2e04c9baad" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::AbstractFunc::getImaginaryPart</definition>
        <argsstring>() const override</argsstring>
        <name>getImaginaryPart</name>
        <qualifiedname>csl::AbstractFunc::getImaginaryPart</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a43f44bbb3685fc9f4a0402223b2e1004">getImaginaryPart</reimplements>
        <reimplementedby refid="classcsl_1_1ACos_1aab3e1ceb5273ff6ada3c1d0d207f75d3">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASin_1ab7c943492f3eb479cc7f846049e86811">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cos_1adfb13db23ecb0b199fd19ce03a68af09">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cosh_1a86f7a0850d4ee1968733701c27273fce">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1DiracDelta_1aea8385f39d0ddccf6b45caa1942ec3cd">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Exp_1a08b474f3f0dbf2255e4c142ad5e095e1">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Log_1a2c9e7604ea16b86991190c95a48b6819">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sin_1a84960733192e56a4335215ba5ebb6a65">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sinh_1aa9674cc4b3452c469d0c1314e3c8bd5b">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tan_1af3ffacb8a8af004785a01eb099d5c246">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tanh_1a6079ee469f697fb680639537590ebd0f">getImaginaryPart</reimplementedby>
        <briefdescription>
<para><bold>Evaluates</bold> the <bold>imaginary part</bold> of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> and returns it. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The imaginary part of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="100" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="106" bodyend="109"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1a83aa54cdff8a16f0a305358d992096f1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>std::optional&lt; Expr &gt; csl::AbstractFunc::getComplexModulus</definition>
        <argsstring>() const override</argsstring>
        <name>getComplexModulus</name>
        <qualifiedname>csl::AbstractFunc::getComplexModulus</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a859f792aec52ba1fe1181f81d1cc3451">getComplexModulus</reimplements>
        <reimplementedby refid="classcsl_1_1ACos_1a9363acfe89a647a562322a036fe68469">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASin_1a776b7c1794fe574114e1e3198d73fa18">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cos_1a7f26952b1462ae3b1cd2ee13ce5dcaff">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cosh_1a1eead10ed28b194fd75399d748a63254">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1DiracDelta_1acb4f35b6aef57ce0426f581f65ad7d68">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1Exp_1a6fd77dde2c403a67d2020966a14b0033">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1Log_1a130216294a13120423ff0d742321d4b1">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sin_1a34f3048a1f09a214bc240cb0030c2c11">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sinh_1a9c8562fa4fa0a8b9bfd299659b2948cf">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tan_1a34ccf0fdcfa2a43f5725e32e9c201aeb">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tanh_1ae5ecb5e85628afc42d25872291a718ed">getComplexModulus</reimplementedby>
        <briefdescription>
<para><bold>Evaluates</bold> the <bold>modulus in the complex plane</bold> of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> and returns it. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The modulus part of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="102" column="19" bodyfile="src/csl/scalarFunc.cpp" bodystart="111" bodyend="115"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1ae67e2d46dfb78e3278fc2134b7d039e4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>std::optional&lt; Expr &gt; csl::AbstractFunc::getComplexArgument</definition>
        <argsstring>() const override</argsstring>
        <name>getComplexArgument</name>
        <qualifiedname>csl::AbstractFunc::getComplexArgument</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a9cc64c66894acafc1f069dc40072084b">getComplexArgument</reimplements>
        <reimplementedby refid="classcsl_1_1ACos_1a745db1e3e6c7e9afb433a89b0f10b0a0">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASin_1a390673a164b5daae797188ebebc2a4fc">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cos_1aae93b65d1aa61e9c6a4422d5c168f617">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cosh_1a6efd3054c14922af72c0e057395869f2">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1DiracDelta_1a3dd7b9fb46af05be5d43baa83412ebac">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1Exp_1a9834c3827d1af36549c055f3a4f65c6d">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1Log_1a16aff9ed9a21cb6653deb96048f29225">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sin_1a91951762c50bbf889d5d0aa1cfd7847f">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sinh_1a596d1ee28a2d06a4e4c0bf55d7f12041">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tan_1a36c5713ba2b02de5da810bbdc1cf0cce">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tanh_1a3c66791362233e86cf739e907303d697">getComplexArgument</reimplementedby>
        <briefdescription>
<para><bold>Evaluates</bold> the <bold>argument in the complex plane</bold> of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> and returns it. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The argument part of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="104" column="19" bodyfile="src/csl/scalarFunc.cpp" bodystart="117" bodyend="120"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1a3a466c8804d5c855dd2b906be2b1be5f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::AbstractFunc::getComplexConjugate</definition>
        <argsstring>() const override</argsstring>
        <name>getComplexConjugate</name>
        <qualifiedname>csl::AbstractFunc::getComplexConjugate</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a03e8bdba20c6192a948892f212f09dbe">getComplexConjugate</reimplements>
        <reimplementedby refid="classcsl_1_1ImaginaryPart_1adfe21172f295b803952c5541750b338e">getComplexConjugate</reimplementedby>
        <reimplementedby refid="classcsl_1_1RealPart_1a1f8b200d737183f15a2edb7d923d464d">getComplexConjugate</reimplementedby>
        <briefdescription>
<para>Calculates and returns the complex conjugate of the expression. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>\bar{*this}. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="106" column="19" bodyfile="src/csl/scalarFunc.cpp" bodystart="122" bodyend="132"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1a2844b245ea8608c32be1ae2794a12858" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::AbstractFunc::findSubExpression</definition>
        <argsstring>(Expr_info subExpression, const Expr &amp;newExpression) const override</argsstring>
        <name>findSubExpression</name>
        <qualifiedname>csl::AbstractFunc::findSubExpression</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a299b1fd6c2b9d80ad90a08c7acef28d2">findSubExpression</reimplements>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>subExpression</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>newExpression</declname>
        </param>
        <briefdescription>
<para>Searches a sub-expression and replaces it. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>subExpression</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to search. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>newExpression</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression that replaces <bold>subExpression</bold> if it is found. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The expression with the replacement done. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="109" column="5" bodyfile="src/csl/scalarFunc.cpp" bodystart="134" bodyend="148"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1a701d14b482a47a85c6cd5266118604cb" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::AbstractFunc::setArgument</definition>
        <argsstring>(const Expr &amp;t_argument, int iArg=0) override</argsstring>
        <name>setArgument</name>
        <qualifiedname>csl::AbstractFunc::setArgument</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aab2d2ac186b56d17d2cc0a105e145b11">setArgument</reimplements>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>t_argument</declname>
        </param>
        <param>
          <type>int</type>
          <declname>iArg</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Replaced the <bold>argument</bold> of the <ref refid="classcsl_1_1AbstractFunc" kindref="compound">AbstractFunc</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>The parameter <emphasis>iArg</emphasis> is usefull for <ref refid="classcsl_1_1AbstractMultiFunc" kindref="compound">AbstractMultiFunc</ref>. It is present ere in order to have only one access function for arguments in the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> class. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t_argument</parametername>
</parameternamelist>
<parameterdescription>
<para>New <bold>argument</bold>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>iArg</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> of the <bold>argument</bold>, silent here. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="119" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="150" bodyend="153"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1a0714debb1e4fe6d8b6bf1b915771b30c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::AbstractFunc::replaceIndex</definition>
        <argsstring>(const Index &amp;indexToReplace, const Index &amp;newIndex, bool refresh=true) const override</argsstring>
        <name>replaceIndex</name>
        <qualifiedname>csl::AbstractFunc::replaceIndex</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1acc0eb077e25c9a67d15269cf8d5f0511">replaceIndex</reimplements>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>indexToReplace</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>newIndex</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>refresh</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>For indicial expressions, this function searches <bold>indexToContract</bold> and replaces it with newIndex. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>indexToContract</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> that is newly contracted. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>newIndex</parametername>
</parameternamelist>
<parameterdescription>
<para>Dummy new index that replaces <bold>indexToContract</bold> in the expression. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if the index has been found. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="121" column="27" bodyfile="src/csl/scalarFunc.cpp" bodystart="155" bodyend="169"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1ad1203eab976b86d48100179c93d05178" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>std::optional&lt; Expr &gt; csl::AbstractFunc::replaceIndices</definition>
        <argsstring>(std::vector&lt; csl::Index &gt; const &amp;oldIndices, std::vector&lt; csl::Index &gt; const &amp;newIndices, bool refresh=true, bool flipped=false) const override</argsstring>
        <name>replaceIndices</name>
        <qualifiedname>csl::AbstractFunc::replaceIndices</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1ac9e54a236015d14af42b0bcde41953f3">replaceIndices</reimplements>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref> &gt; const &amp;</type>
          <declname>oldIndices</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref> &gt; const &amp;</type>
          <declname>newIndices</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>refresh</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>flipped</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="127" column="5" bodyfile="src/csl/scalarFunc.cpp" bodystart="172" bodyend="187"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1ad13204b56adf098d9c4b886ea7b8681f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::AbstractFunc::factor</definition>
        <argsstring>(bool full=false) const override</argsstring>
        <name>factor</name>
        <qualifiedname>csl::AbstractFunc::factor</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a0bc0de9c4ce5f77fc716af0f502d13d3">factor</reimplements>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para><bold>Factors</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>This function tries to factor the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> wrt any <bold>factor</bold>. This will be more involved in calculation than the other factorizing function that takes the factor as a parameter. So this function <bold>must be used only</bold> if we don&apos;t know the factors we want at the end. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>full</parametername>
</parameternamelist>
<parameterdescription>
<para>If true the factorization is <bold>recursive</bold> through all the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="132" column="27" bodyfile="src/csl/scalarFunc.cpp" bodystart="188" bodyend="199"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1a281d2d19b84b9b5fec66dbf1eb89a27d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::AbstractFunc::factor</definition>
        <argsstring>(Expr_info expr, bool full=false) const override</argsstring>
        <name>factor</name>
        <qualifiedname>csl::AbstractFunc::factor</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a8fb3d657c65606d520688db6401fe650">factor</reimplements>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>factor</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para><bold>Factors</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> wrt a <bold>particular</bold> <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>factor</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> wrt which we try to factor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>full</parametername>
</parameternamelist>
<parameterdescription>
<para>If true the factorization is <bold>recursive</bold> through all the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="134" column="27" bodyfile="src/csl/scalarFunc.cpp" bodystart="201" bodyend="212"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1a2b1a66c3b926cd7a95060464a3bb6a62" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::AbstractFunc::collect</definition>
        <argsstring>(std::vector&lt; Expr &gt; const &amp;factors, bool full=false) const override</argsstring>
        <name>collect</name>
        <qualifiedname>csl::AbstractFunc::collect</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1ab3746f1d3667846824ea51b8a2e00d31">collect</reimplements>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; const &amp;</type>
          <declname>factors</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Collects terms in sum according to some factors given by the user. </para>
        </briefdescription>
        <detaileddescription>
<para>This function allows the factor with some specific scalar variables. For example, <formula id="6">$ ax + ay + by $</formula> can be factored in two ways. Either with <formula id="7">$ (a, b) $</formula> which gives <formula id="8">$ a(x+y) + by $</formula> ; or with <formula id="9">$ (x, y) $</formula> which gives <formula id="10">$ ax + (a+b)y $</formula>. With the collect function it is possible to choose precisely the set of variables that will be factored to express results in a standard way.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>factors</parametername>
</parameternamelist>
<parameterdescription>
<para>Factors to search in the expression. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>full</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean (default = false) that tells if the collection must be recursive (full expression depth).</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The collected expression if modifications have been done. </para>
</simplesect>
<simplesect kind="return"><para>std::nullopt else.</para>
</simplesect>
<simplesect kind="note"><para>This function will probably replace the <ref refid="classcsl_1_1AbstractFunc_1ad13204b56adf098d9c4b886ea7b8681f" kindref="member">factor()</ref> function in the future.</para>
</simplesect>
<simplesect kind="note"><para>For now, the collect function does not support factorization by indicial tensors, whereas <ref refid="classcsl_1_1AbstractFunc_1ad13204b56adf098d9c4b886ea7b8681f" kindref="member">factor()</ref> does. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="137" column="27" bodyfile="src/csl/scalarFunc.cpp" bodystart="214" bodyend="226"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1a8bc591288c134387b71c758229d65f54" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::AbstractFunc::expand</definition>
        <argsstring>(bool full=false, bool inPlace=false) const override</argsstring>
        <name>expand</name>
        <qualifiedname>csl::AbstractFunc::expand</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a3a87ab082152fea4fc2444659028b840">expand</reimplements>
        <reimplementedby refid="classcsl_1_1Exp_1a53d5fa8b9bf211862d9c6dde6fcad3a6">expand</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1a7e4ec8aa653557544dd3063af72d816f">expand</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1a7e4ec8aa653557544dd3063af72d816f">expand</reimplementedby>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>inPlace</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para><bold>Develops</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>This function concerns only products (and exponents) that will be flatten to give at the end a sum of independant terms.<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>full</parametername>
</parameternamelist>
<parameterdescription>
<para>If true the expandment is <bold>recursive</bold> through all the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The expand <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="140" column="19" bodyfile="src/csl/scalarFunc.cpp" bodystart="228" bodyend="239"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1a3be99a2a139aeb34596b598bafa9975d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::AbstractFunc::expand_if</definition>
        <argsstring>(std::function&lt; bool(Expr const &amp;)&gt; const &amp;f, bool full=false, bool inPlace=false) const override</argsstring>
        <name>expand_if</name>
        <qualifiedname>csl::AbstractFunc::expand_if</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aeb48aaaa856582b6359037fe94d2419b">expand_if</reimplements>
        <reimplementedby refid="classcsl_1_1Exp_1a0742b26f0efd5a82473f3d8b26524fcd">expand_if</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1a453d864df2f26dcedca00592cc49ea55">expand_if</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1a453d864df2f26dcedca00592cc49ea55">expand_if</reimplementedby>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>inPlace</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para><bold>Develops</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>This function concerns only products (and exponents) that will be flatten to give at the end a sum of independant terms.<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Functions that returns a boolean that determines which arguments must be expanded in products.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>full</parametername>
</parameternamelist>
<parameterdescription>
<para>If true the expandment is <bold>recursive</bold> through all the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The expand <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="151" column="5" bodyfile="src/csl/scalarFunc.cpp" bodystart="241" bodyend="253"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1a8c3e75947048293c9c6cc0c8e261049f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::AbstractFunc::dependsOn</definition>
        <argsstring>(Expr_info expr) const override</argsstring>
        <name>dependsOn</name>
        <qualifiedname>csl::AbstractFunc::dependsOn</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a40fe2ccf376dadd21b2d7a0f134d86c6">dependsOn</reimplements>
        <reimplementedby refid="classcsl_1_1AbstractIntegral_1a72eadc4f6452f7139be88c9bfe0c8649">dependsOn</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Check recursively if the expression depends on <bold>expr</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to search. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if a dependency in <bold>expr</bold> is found. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="155" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="262" bodyend="265"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1af6752c67bd61217583fb54a80cee65bc" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::AbstractFunc::dependsOn</definition>
        <argsstring>(const AbstractParent *parent) const override</argsstring>
        <name>dependsOn</name>
        <qualifiedname>csl::AbstractFunc::dependsOn</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1AbstractParent" kindref="compound">AbstractParent</ref> *</type>
          <declname>parent</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="157" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="267" bodyend="270"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1aa67b2133ef52393513ecbdc72e45acb0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::AbstractFunc::dependsExplicitlyOn</definition>
        <argsstring>(Expr_info expr) const override</argsstring>
        <name>dependsExplicitlyOn</name>
        <qualifiedname>csl::AbstractFunc::dependsExplicitlyOn</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1ac3c9887977249e4d71ea36c6377b3581">dependsExplicitlyOn</reimplements>
        <reimplementedby refid="classcsl_1_1AbstractIntegral_1ab675c7672e9523a8fdfaf71f9741bb93">dependsExplicitlyOn</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Check recursively if <bold>expr</bold> is present in the expression. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to search. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if <bold>expr</bold> is found. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="159" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="272" bodyend="275"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1aa5181cc8b11edcdb189ca7491cf6ba82" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::AbstractFunc::dependsExplicitlyOn</definition>
        <argsstring>(Parent_info expr) const override</argsstring>
        <name>dependsExplicitlyOn</name>
        <qualifiedname>csl::AbstractFunc::dependsExplicitlyOn</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a0b26ad7a44e497af296318287bac539a">dependsExplicitlyOn</reimplements>
        <param>
          <type><ref refid="classcsl_1_1AbstractParent" kindref="compound">Parent_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="161" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="277" bodyend="280"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1ae2422de442a3c2b7d3011012a5cb7a46" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::AbstractFunc::commutesWith</definition>
        <argsstring>(Expr_info expr, int sign=-1) const override</argsstring>
        <name>commutesWith</name>
        <qualifiedname>csl::AbstractFunc::commutesWith</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a3f68d0cd93dfe2ac02d6d4afc80fb41a">commutesWith</reimplements>
        <reimplementedby refid="classcsl_1_1Operator_1adc9dd8a7ee3c9092e6d94d88d3e9f9fe">commutesWith</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1adc9dd8a7ee3c9092e6d94d88d3e9f9fe">commutesWith</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>sign</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Tells if the object commutes with expr. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if <bold>*this</bold> commutes with <bold>expr</bold>. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="163" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="282" bodyend="285"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1a699c366fc3c292e8a70941e1c4ee5b0c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>int</type>
        <definition>int csl::AbstractFunc::isPolynomial</definition>
        <argsstring>(Expr_info expr) const override</argsstring>
        <name>isPolynomial</name>
        <qualifiedname>csl::AbstractFunc::isPolynomial</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1acae10d5685ccec295fbd9be7996073cb">isPolynomial</reimplements>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Determines if the expression is a mononomial term in <bold>expr</bold>, i.e. a term of the form C*expr^n with C independent of expr, n integer. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Variable" kindref="compound">Variable</ref> of the supposed mononomial. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The order of the exponent if there is one (n in the example). </para>
</simplesect>
<simplesect kind="return"><para>-1 else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="165" column="9" bodyfile="src/csl/scalarFunc.cpp" bodystart="287" bodyend="290"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1a224c6e6a26a42ac2dba35e30e2e7a521" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::AbstractFunc::evaluate</definition>
        <argsstring>(csl::eval::mode user_mode=csl::eval::base) const override</argsstring>
        <name>evaluate</name>
        <qualifiedname>csl::AbstractFunc::evaluate</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aa3a4cb7f30e2a422fe27a513e03d6600">evaluate</reimplements>
        <reimplementedby refid="classcsl_1_1AbstractIntegral_1a03f67aec1f7e9b74fd65383e0fc6600f">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACos_1a17e119e2f6d22f0b6c1f149e2ebefcd5">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACosh_1a1b3ac8c059d26ae9142d9f240f7aeb78">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASin_1afd6d69a61c924d596c1f7adb859893b0">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASinh_1a6489126c02c25e4cfb295db5d85cadd5">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATan_1a275592a7ba6a9985e921b3a791dc461f">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATanh_1ad9ee39eda573051de9b45699ed886f83">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cos_1a3baf3fecf9ea48db4ba1fbbfd3aee05b">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cosh_1ad40b853fb9959e63b514ed9c71b5bf2a">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Exp_1a9927422cac69f3ef722551ac4d37d33f">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Factorial_1ab104048896f3aafb93bf35a73d8fa783">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1ImaginaryPart_1a8423033a6934636a15e47b5ccb0df70e">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Log_1a6007d682abe9cd508476984a051c0844">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1RealPart_1aeb57b368c5ae7caa278ca998cb3a4782">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sin_1a9977b55ee7079bf9bc7205a57975dd5f">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sinh_1aa7b24dd1844a99aa1bf73f59829d6cb0">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tan_1a1c5025345411cb71d081394524492ae1">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tanh_1a094ae3e5b29e66a9d4319fb774b5bfcb">evaluate</reimplementedby>
        <reimplementedby refid="classmty_1_1Wick_1af4646e4a1567e6e87e3112f177d7aa52">evaluate</reimplementedby>
        <param>
          <type>csl::eval::mode</type>
          <declname>user_mode</declname>
          <defval>csl::eval::base</defval>
        </param>
        <briefdescription>
<para><bold>Evaluates</bold> the function after evaluating the <bold>argument</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para>Except particular cases (cos(0), exp(0) etc) this function returns the same <ref refid="classcsl_1_1AbstractFunc" kindref="compound">AbstractFunc</ref> with <bold>argument.evaluate()</bold> as argument. <simplesect kind="return"><para>The function of the evaluated <bold>argument</bold>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="172" column="19" bodyfile="src/csl/scalarFunc.cpp" bodystart="292" bodyend="309"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1af3afc58a715c978290e4860101fb3c27" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
        <definition>Expr const  &amp; csl::AbstractFunc::operator[]</definition>
        <argsstring>(int i) const override</argsstring>
        <name>operator[]</name>
        <qualifiedname>csl::AbstractFunc::operator[]</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aa8331053065d1be2da89e70c45d24863">operator[]</reimplements>
        <param>
          <type>int</type>
          <declname>iArg</declname>
        </param>
        <briefdescription>
<para>Access operator for multi-argument expressions, equivalent to the function <ref refid="classcsl_1_1AbstractFunc_1adf8cb8650883f5ea7729cdabec2aeab0" kindref="member">getArgument()</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iArg</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> of the argument to get. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>argument</bold>[iArg]. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="175" column="16" bodyfile="src/csl/scalarFunc.cpp" bodystart="311" bodyend="318"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1ab6a82539b4c61521f13b39bf1b230e68" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
        <definition>Expr &amp; csl::AbstractFunc::operator[]</definition>
        <argsstring>(int i) override</argsstring>
        <name>operator[]</name>
        <qualifiedname>csl::AbstractFunc::operator[]</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a560aa9993d506551c54a8c02d1445814">operator[]</reimplements>
        <param>
          <type>int</type>
          <declname>iArg</declname>
        </param>
        <briefdescription>
<para>Access operator for multi-argument expressions, returns a reference so this function is not const. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iArg</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> of the argument to get. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A reference to <bold>argument</bold>[iArg]. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="177" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="320" bodyend="327"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1a7ccf43edff01ef8c6500b5117ac42213" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::AbstractFunc::operator==</definition>
        <argsstring>(Expr_info expr) const override</argsstring>
        <name>operator==</name>
        <qualifiedname>csl::AbstractFunc::operator==</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a3775f3088e784cc924cb7d26e118660e">operator==</reimplements>
        <reimplementedby refid="classcsl_1_1DiracDelta_1aa66032c002b1c5d95bb4499093fa19cc">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1ImaginaryPart_1a52a90d231dbb0518eebb65e5f21e24eb">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1RealPart_1adac617913cdfa2354a085002f443f123">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1ScalarIntegral_1a86a7f329d187d9abddb819dacf61d5e3">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1VectorIntegral_1a2e912283405785f512234ada336ca5dd">operator==</reimplementedby>
        <reimplementedby refid="classmty_1_1Wick_1ae82d659cd5fa09a1b3b4a7284e4c282a">operator==</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Compares</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> with another. </para>
        </briefdescription>
        <detaileddescription>
<para>Here if two Abstracts have the same name, the function will return <bold>true</bold> even if they are <bold>not</bold> <bold>mathematically</bold> <bold>equal</bold>. So beware not to name different things the same way. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> to compare. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if the two Abstracts are the same (or have the same name). </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="179" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="329" bodyend="338"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1a48bd4d1a491e8dd5e555a332c824aff7" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::AbstractFunc::operator&lt;</definition>
        <argsstring>(const Abstract *expr) const override</argsstring>
        <name>operator&lt;</name>
        <qualifiedname>csl::AbstractFunc::operator&lt;</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="181" column="5" bodyfile="src/csl/simplification.cpp" bodystart="606" bodyend="640"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="protected-func">
      <memberdef kind="function" id="classcsl_1_1AbstractFunc_1ab3f59cae46f77a34ecd0965c853e0287" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::AbstractFunc::evalNumerical</definition>
        <argsstring>(Expr const &amp;argument) const</argsstring>
        <name>evalNumerical</name>
        <qualifiedname>csl::AbstractFunc::evalNumerical</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>argument</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="184" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="255" bodyend="260"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>Base class for <bold>scalar functions of one argument.</bold> </para>
    </briefdescription>
    <detaileddescription>
<para>From this class will derive functions with a <bold>unique argument</bold>. In particular all mathematical functions will be derived classes. In the case of the call of a simplification function, if recursive, the function will be first applied on the <bold>argument</bold>, then to the function itself. </para>
    </detaileddescription>
    <inheritancegraph>
      <node id="11">
        <label>csl::ACos</label>
        <link refid="classcsl_1_1ACos"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="12">
        <label>csl::ACosh</label>
        <link refid="classcsl_1_1ACosh"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="13">
        <label>csl::ASin</label>
        <link refid="classcsl_1_1ASin"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="14">
        <label>csl::ASinh</label>
        <link refid="classcsl_1_1ASinh"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="15">
        <label>csl::ATan</label>
        <link refid="classcsl_1_1ATan"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="16">
        <label>csl::ATanh</label>
        <link refid="classcsl_1_1ATanh"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="17">
        <label>csl::Abs</label>
        <link refid="classcsl_1_1Abs"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>csl::Abstract</label>
        <link refid="classcsl_1_1Abstract"/>
      </node>
      <node id="1">
        <label>csl::AbstractFunc</label>
        <link refid="classcsl_1_1AbstractFunc"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="4">
        <label>csl::AbstractIntegral</label>
        <link refid="classcsl_1_1AbstractIntegral"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
      <node id="18">
        <label>csl::Cos</label>
        <link refid="classcsl_1_1Cos"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="19">
        <label>csl::Cosh</label>
        <link refid="classcsl_1_1Cosh"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="20">
        <label>csl::DiracDelta</label>
        <link refid="classcsl_1_1DiracDelta"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="21">
        <label>csl::Exp</label>
        <link refid="classcsl_1_1Exp"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="22">
        <label>csl::Factorial</label>
        <link refid="classcsl_1_1Factorial"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="7">
        <label>csl::ImaginaryPart</label>
        <link refid="classcsl_1_1ImaginaryPart"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
      <node id="23">
        <label>csl::Log</label>
        <link refid="classcsl_1_1Log"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="3">
        <label>csl::Operator&lt; AbstractFunc &gt;</label>
        <link refid="classcsl_1_1Operator"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="9">
        <label>csl::Operator&lt; csl::AbstractFunc &gt;</label>
        <link refid="classcsl_1_1Operator"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="8">
        <label>csl::RealPart</label>
        <link refid="classcsl_1_1RealPart"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
      <node id="5">
        <label>csl::ScalarIntegral</label>
        <link refid="classcsl_1_1ScalarIntegral"/>
        <childnode refid="4" relation="public-inheritance">
        </childnode>
      </node>
      <node id="24">
        <label>csl::Sin</label>
        <link refid="classcsl_1_1Sin"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="25">
        <label>csl::Sinh</label>
        <link refid="classcsl_1_1Sinh"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="26">
        <label>csl::Tan</label>
        <link refid="classcsl_1_1Tan"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="27">
        <label>csl::Tanh</label>
        <link refid="classcsl_1_1Tanh"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="6">
        <label>csl::VectorIntegral</label>
        <link refid="classcsl_1_1VectorIntegral"/>
        <childnode refid="4" relation="public-inheritance">
        </childnode>
      </node>
      <node id="10">
        <label>mty::Wick</label>
        <link refid="classmty_1_1Wick"/>
        <childnode refid="9" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="2">
        <label>csl::Abstract</label>
        <link refid="classcsl_1_1Abstract"/>
      </node>
      <node id="1">
        <label>csl::AbstractFunc</label>
        <link refid="classcsl_1_1AbstractFunc"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
        <childnode refid="3" relation="usage">
          <edgelabel>argument</edgelabel>
        </childnode>
      </node>
      <node id="3">
        <label>csl::Expr</label>
        <link refid="classcsl_1_1Expr"/>
        <childnode refid="4" relation="public-inheritance">
        </childnode>
      </node>
      <node id="4">
        <label>std::shared_ptr&lt; csl::Abstract &gt;</label>
        <link refid="classstd_1_1shared__ptr"/>
      </node>
    </collaborationgraph>
    <location file="src/csl/scalarFunc.h" line="38" column="1" bodyfile="src/csl/scalarFunc.h" bodystart="38" bodyend="185"/>
    <listofallmembers>
      <member refid="classcsl_1_1Abstract_1ad5fee68c1f3dcbda0e936926fed17616" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>Abstract</name></member>
      <member refid="classcsl_1_1AbstractFunc_1a5fdb13c5df0c5d7201378c183acb31fa" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>AbstractFunc</name></member>
      <member refid="classcsl_1_1AbstractFunc_1af7f0cfa8c7fa35fe5cdadb16f4068c80" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>AbstractFunc</name></member>
      <member refid="classcsl_1_1Abstract_1a5549ac0c186b3c6febf332245a25a82c" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>addAntiSymmetry</name></member>
      <member refid="classcsl_1_1Abstract_1abbab11282e5c6ac46b018642ff129f47" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>addDependency</name></member>
      <member refid="classcsl_1_1Abstract_1a101219973341a39cf15f07e5e1aa388f" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>addition_own</name></member>
      <member refid="classcsl_1_1Abstract_1ad431770faa4291116a50175193a11a88" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>addSymmetry</name></member>
      <member refid="classcsl_1_1Abstract_1acd972aed8326d4c13534594e061ee6da" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>antisymmetrise</name></member>
      <member refid="classcsl_1_1Abstract_1a61d3ab932182226f4670a62bbb22af4e" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>applyDiracDelta</name></member>
      <member refid="classcsl_1_1Abstract_1a316956fea77627a716500a2bbfc1f3b7" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>applyOperator</name></member>
      <member refid="classcsl_1_1Abstract_1a6305ce90c795bfb416d8e958c62f905c" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>applySelfStructureOn</name></member>
      <member refid="classcsl_1_1AbstractFunc_1a9ffcf8afbee0a103421280b82cfffe05" prot="protected" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>argument</name></member>
      <member refid="classcsl_1_1Abstract_1a27ad666bf7d533607da9675b0c645ee9" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>askTerm</name></member>
      <member refid="classcsl_1_1Abstract_1aad54ed41b2ce9bad3364fe30ad1a0d71" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>begin</name></member>
      <member refid="classcsl_1_1Abstract_1adff373df9477d4e38581d09cc6d2fee4" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>begin</name></member>
      <member refid="classcsl_1_1Abstract_1aa4cba37520821432f37e212fefbc2534" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>breakSpace</name></member>
      <member refid="classcsl_1_1Abstract_1af0f40b77914e45f56bf87839d00211d7" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>breakSpace</name></member>
      <member refid="classcsl_1_1Abstract_1afd9d0336808e8adf4ccdccb51587ed8c" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>checkIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1a1ebd84082bb93418408cc0babe2dffe2" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>checkIndexStructure</name></member>
      <member refid="classcsl_1_1AbstractFunc_1a2b1a66c3b926cd7a95060464a3bb6a62" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>collect</name></member>
      <member refid="classcsl_1_1AbstractFunc_1ae2422de442a3c2b7d3011012a5cb7a46" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>commutesWith</name></member>
      <member refid="classcsl_1_1AbstractFunc_1af16a648041a09ff87602427add048ee0" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>compareWithDummy</name></member>
      <member refid="classcsl_1_1Abstract_1a0f16fda9fe72a89c61ece36101a11d95" prot="public" virt="non-virtual" ambiguityscope="csl::Abstract::"><scope>csl::AbstractFunc</scope><name>compareWithDummy</name></member>
      <member refid="classcsl_1_1Abstract_1aed79d20a0821205e6430c80a474117d3" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>contractIndex</name></member>
      <member refid="classcsl_1_1Abstract_1ad874fc858295a737e6ce884530f1109b" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>contraction</name></member>
      <member refid="classcsl_1_1Abstract_1abd35096982e92b669ea55d960c5f44be" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>contraction</name></member>
      <member refid="classcsl_1_1Abstract_1af29c2898c5d3ba96de8018a0838c402c" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>copy</name></member>
      <member refid="classcsl_1_1Abstract_1aaa996819710adc3b7529c74a628be623" prot="public" virt="pure-virtual"><scope>csl::AbstractFunc</scope><name>copy_unique</name></member>
      <member refid="classcsl_1_1Abstract_1a09648782dcf2e81abb5b864f476cc410" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>deepCopy</name></member>
      <member refid="classcsl_1_1Abstract_1a10358c33402ed520dc5888b25bb26af3" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>deepRefresh</name></member>
      <member refid="classcsl_1_1AbstractFunc_1aa67b2133ef52393513ecbdc72e45acb0" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>dependsExplicitlyOn</name></member>
      <member refid="classcsl_1_1AbstractFunc_1aa5181cc8b11edcdb189ca7491cf6ba82" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>dependsExplicitlyOn</name></member>
      <member refid="classcsl_1_1AbstractFunc_1a8c3e75947048293c9c6cc0c8e261049f" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>dependsOn</name></member>
      <member refid="classcsl_1_1AbstractFunc_1af6752c67bd61217583fb54a80cee65bc" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>dependsOn</name></member>
      <member refid="classcsl_1_1Abstract_1a9d7d8586a0df66ba8da33528d6400e66" prot="public" virt="virtual" ambiguityscope="csl::Abstract::"><scope>csl::AbstractFunc</scope><name>dependsOn</name></member>
      <member refid="classcsl_1_1Abstract_1aecab8c872023a2d0771e7e4f83bb05f8" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>derive</name></member>
      <member refid="classcsl_1_1Abstract_1aeb08811cf370616477a92075e4a218ee" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>determinant</name></member>
      <member refid="classcsl_1_1Abstract_1a1578c74aee1050b806a67e7a81a67f5c" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>division_own</name></member>
      <member refid="classcsl_1_1Abstract_1a4cc7a46deaa3eaa7593909d74e76d4af" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>dot</name></member>
      <member refid="classcsl_1_1Abstract_1a0c3c3fe5010f24e8a8765ea06415c003" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>empty</name></member>
      <member refid="classcsl_1_1Abstract_1a61e4e80d998a888a1a74d9ea3e10c0f1" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>end</name></member>
      <member refid="classcsl_1_1Abstract_1ae2761d54f13310e13f5076d565edd7ef" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>end</name></member>
      <member refid="classcsl_1_1AbstractFunc_1ab3f59cae46f77a34ecd0965c853e0287" prot="protected" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>evalNumerical</name></member>
      <member refid="classcsl_1_1AbstractFunc_1a224c6e6a26a42ac2dba35e30e2e7a521" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>evaluate</name></member>
      <member refid="classcsl_1_1Abstract_1a543d5a4f0432e166b492ad28a860a65f" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>evaluateScalar</name></member>
      <member refid="classcsl_1_1AbstractFunc_1a8bc591288c134387b71c758229d65f54" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>expand</name></member>
      <member refid="classcsl_1_1AbstractFunc_1a3be99a2a139aeb34596b598bafa9975d" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>expand_if</name></member>
      <member refid="classcsl_1_1Abstract_1aa2696a0feb43766ef54e1e3dd3d6d134" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>exponentiation_own</name></member>
      <member refid="classcsl_1_1AbstractFunc_1ad13204b56adf098d9c4b886ea7b8681f" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>factor</name></member>
      <member refid="classcsl_1_1AbstractFunc_1a281d2d19b84b9b5fec66dbf1eb89a27d" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>factor</name></member>
      <member refid="classcsl_1_1AbstractFunc_1a2844b245ea8608c32be1ae2794a12858" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>findSubExpression</name></member>
      <member refid="classcsl_1_1Abstract_1a021946e84d8c1a019908cac578b16fe8" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getAllDependencies</name></member>
      <member refid="classcsl_1_1AbstractFunc_1adf8cb8650883f5ea7729cdabec2aeab0" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getArgument</name></member>
      <member refid="classcsl_1_1AbstractFunc_1af02355fee3c7cda15993cfcf553d6f92" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a898d6cf2a7f348feacab189447bee1eb" prot="public" virt="virtual" ambiguityscope="csl::Abstract::"><scope>csl::AbstractFunc</scope><name>getArgument</name></member>
      <member refid="classcsl_1_1Abstract_1aa689fb64eecb86edbde6c745d1ce756b" prot="public" virt="virtual" ambiguityscope="csl::Abstract::"><scope>csl::AbstractFunc</scope><name>getArgument</name></member>
      <member refid="classcsl_1_1Abstract_1afeb26e1382411448ce3c65d50fefd8bb" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getCanonicalPermutation</name></member>
      <member refid="classcsl_1_1AbstractFunc_1ab41faa67ed807f3cc2c95f5f175e9099" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getCommutable</name></member>
      <member refid="classcsl_1_1AbstractFunc_1ae67e2d46dfb78e3278fc2134b7d039e4" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getComplexArgument</name></member>
      <member refid="classcsl_1_1AbstractFunc_1a3a466c8804d5c855dd2b906be2b1be5f" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getComplexConjugate</name></member>
      <member refid="classcsl_1_1AbstractFunc_1a83aa54cdff8a16f0a305358d992096f1" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getComplexModulus</name></member>
      <member refid="classcsl_1_1Abstract_1a470d9f1267fba4a82e13af4a39470f81" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getComplexProperty</name></member>
      <member refid="classcsl_1_1Abstract_1af04c0e4426f0bf9df365afe0148d59df" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getContractedPair</name></member>
      <member refid="classcsl_1_1Abstract_1aec707d949f0f98e08ab4642c93dd9eb5" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getContractionProperties</name></member>
      <member refid="classcsl_1_1Abstract_1aa22f0e4c9c91f43b5cd61cbb873869eb" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getDeltaMinus</name></member>
      <member refid="classcsl_1_1Abstract_1a69a657baf1c35ed581e9db2c47a71c99" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getDeltaPlus</name></member>
      <member refid="classcsl_1_1Abstract_1a9531d78d67c82e288c0130da5b1ba80b" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getDenom</name></member>
      <member refid="classcsl_1_1Abstract_1a5856c3d55a6d1406970f3656e61efe8e" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getDim</name></member>
      <member refid="classcsl_1_1Abstract_1a77e067fc57c0c2e70d141079455fdbd7" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getElementary</name></member>
      <member refid="classcsl_1_1Abstract_1ac513c930caa9939c2b9557f36a34ee69" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getExponents</name></member>
      <member refid="classcsl_1_1Abstract_1ac34c9c6f05e692faeed2f030514787ad" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getFactors</name></member>
      <member refid="classcsl_1_1Abstract_1aa4136dc23f1fba4bf897b54c8592ccfc" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getFreeIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1aa5b707a5efdaef7c7945cbd921c3f526" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getHermitianConjugate</name></member>
      <member refid="classcsl_1_1Abstract_1aff5cca2b2c8190e59f6e34cb1e383d36" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getHermitianConjugate</name></member>
      <member refid="classcsl_1_1AbstractFunc_1a24aee4ffda2255a56fd2eb2e04c9baad" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getImaginaryPart</name></member>
      <member refid="classcsl_1_1Abstract_1a3234ce243f6a2e11950be42f10100943" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getIndex</name></member>
      <member refid="classcsl_1_1AbstractFunc_1a53ef9c900304f02f54ce6ea1485b4537" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1ae6a9a9ef3efd6bb83b62c0a353742d25" prot="public" virt="non-virtual" ambiguityscope="csl::Abstract::"><scope>csl::AbstractFunc</scope><name>getIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1addb848bf4cdea207484a71e9b1006ead" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getIndexStructureView</name></member>
      <member refid="classcsl_1_1Abstract_1a632e28530a68539fadacd7ab7ffc8be1" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getIndexStructureView</name></member>
      <member refid="classcsl_1_1Abstract_1a3d6b1e294cf24dea17c3c4361226138b" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getInfBoundary</name></member>
      <member refid="classcsl_1_1Abstract_1a9c4a302d1a3cbf4dd9394f5e5880d343" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getLatexName</name></member>
      <member refid="classcsl_1_1Abstract_1a652101e34b2efa43114150e9af3c79d5" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getLibDependency</name></member>
      <member refid="classcsl_1_1Abstract_1af7f5e7466e754984a2c4394a112464f7" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getName</name></member>
      <member refid="classcsl_1_1AbstractFunc_1ae32e5909a9d7616ceac05b22a74b1284" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getNArgs</name></member>
      <member refid="classcsl_1_1Abstract_1a42125e9765a771c47819548d342b0b28" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getNContractedPairs</name></member>
      <member refid="classcsl_1_1Abstract_1a204dbd37b63432cb08932b995f49d3f4" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getNFactor</name></member>
      <member refid="classcsl_1_1Abstract_1add364193f7a78ac28f7001c7f4036453" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getNIndices</name></member>
      <member refid="classcsl_1_1Abstract_1a6aa6bcc7cb8ee1574f29dc6ab6c6f0ed" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getNum</name></member>
      <member refid="classcsl_1_1Abstract_1aad25c117c8dfc4d9718ba41e8d3f33a6" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getNumericalFactor</name></member>
      <member refid="classcsl_1_1Abstract_1a9c3ec3dfe1fbd8ead5c8d9aca421a863" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getOperand</name></member>
      <member refid="classcsl_1_1Abstract_1a9500a21d75d03c695ec0c76493600b38" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getOrder</name></member>
      <member refid="classcsl_1_1Abstract_1ae89eb7b1a9e0259a60154563f3315907" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getOrderOf</name></member>
      <member refid="classcsl_1_1Abstract_1ab150130c9f67daaf6aba52b9f6b90941" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getParent</name></member>
      <member refid="classcsl_1_1Abstract_1a15f775b5add9af8727ead2cfaab78ba2" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getParent_info</name></member>
      <member refid="classcsl_1_1Abstract_1aea8459b3206eb3a2297eeea7688e9520" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getParity</name></member>
      <member refid="classcsl_1_1Abstract_1a946d175d946da102c5f4cc91840703cb" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getPermutations</name></member>
      <member refid="classcsl_1_1AbstractFunc_1a9d3a9a67f2990981805efd146e6fc6fe" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getPoint</name></member>
      <member refid="classcsl_1_1Abstract_1ade540a127da7304f2b7282f4dcaffc7f" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getPolynomialTerm</name></member>
      <member refid="classcsl_1_1AbstractFunc_1a18df1a5dbd7c9c75b1704fe958a55a5d" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getPrimaryType</name></member>
      <member refid="classcsl_1_1Abstract_1a07489d0569bc983718796d21c73f34b3" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getProduct</name></member>
      <member refid="classcsl_1_1AbstractFunc_1ab1d0e4f2b4d063838158829972c2160a" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getRealPart</name></member>
      <member refid="classcsl_1_1Abstract_1a5b77f008f4b95030641224877004f06c" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getRegularExpression</name></member>
      <member refid="classcsl_1_1Abstract_1a625efe55a17b97a1c0f085bdbf3a962a" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getShape</name></member>
      <member refid="classcsl_1_1Abstract_1aa83df1d9dc202457113e5b38bd694fae" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getSign</name></member>
      <member refid="classcsl_1_1AbstractFunc_1a0d3f88b1d12d0900184101720f8e345b" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getSubSymbols</name></member>
      <member refid="classcsl_1_1Abstract_1a7dcdc11b64c8c515933882168d0792ef" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1a413c50b2663f57d38c1d3ec3cfeaa3ce" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1a26a0854bca4c47e84a1da36a3de8c49f" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1a29261a946b3398b6129237620754a8b9" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1a8a067b70756c4eef758aa88076a95162" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1aeaf8154e39ff211b12e6382e675ccaad" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getSum</name></member>
      <member refid="classcsl_1_1Abstract_1a2fcc223dbf5d880e923c07df142df5c8" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getSupBoundary</name></member>
      <member refid="classcsl_1_1Abstract_1a1d36e7a5acc50766d5cd3f6d59df978d" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getTerm</name></member>
      <member refid="classcsl_1_1Abstract_1a404c5e89a3aad8a8dabcb56d4120c0fe" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getTransposed</name></member>
      <member refid="classcsl_1_1Abstract_1aca3debb143668fd3ab75a27a47dd0c13" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getTransposed</name></member>
      <member refid="classcsl_1_1Abstract_1aa781456c3f801b37ce169c83514c51c1" prot="public" virt="pure-virtual"><scope>csl::AbstractFunc</scope><name>getType</name></member>
      <member refid="classcsl_1_1Abstract_1a78f98ba06476e464e3fd2fce0d1f8243" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getValue</name></member>
      <member refid="classcsl_1_1Abstract_1a628563238145f3a9acc331f1a89ce32f" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getValued</name></member>
      <member refid="classcsl_1_1Abstract_1ae85f810bbadbc792210c958e8f1b2ffb" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getVariable</name></member>
      <member refid="classcsl_1_1Abstract_1ac83c44ae1e5315a38083bdb7acd8f3fa" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getVectorArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a0188b049736016c970a2513ed9f6931f" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>getVectorialModulus</name></member>
      <member refid="classcsl_1_1Abstract_1a94bf1455397fdd2df8dbbc3b41c2f3f4" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>hasChainContractionProperty</name></member>
      <member refid="classcsl_1_1Abstract_1aa31e08c251d96b8ea8ec8d385895c1ff" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>hasContractionProperty</name></member>
      <member refid="classcsl_1_1Abstract_1a8c42723e8bc6334c99f00898cc1d59d7" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>hermitian</name></member>
      <member refid="classcsl_1_1Abstract_1a5437e7f685edf8549e6d3b34572343f8" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>insert</name></member>
      <member refid="classcsl_1_1Abstract_1a1b68943aa7ecf60a63af0f2f368eef8f" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>inverseMatrix</name></member>
      <member refid="classcsl_1_1Abstract_1a9347e75b0cd0b75e0f0a38db93b29d83" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>isAnOperator</name></member>
      <member refid="classcsl_1_1Abstract_1ac09992d147b39388c8936b3bff648930" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>isArbitrary</name></member>
      <member refid="classcsl_1_1Abstract_1ad74c068f1da78856321932b6b6ae17dc" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>isBuildingBlock</name></member>
      <member refid="classcsl_1_1Abstract_1a22a594845a29429c9b4f19c92bd18cad" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>isComplexConjugate</name></member>
      <member refid="classcsl_1_1Abstract_1a464f4f0613db9b4b0a4efe26a3a03d60" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>isEmpty</name></member>
      <member refid="classcsl_1_1Abstract_1af2ce38838e35c5785f92373a1d830668" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>isHermitianConjugate</name></member>
      <member refid="classcsl_1_1AbstractFunc_1a25e37d9d40927ef216a5b10958fa83ba" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>isIndexed</name></member>
      <member refid="classcsl_1_1Abstract_1a9a014bfd266b5f8471f23580e271979b" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>isInteger</name></member>
      <member refid="classcsl_1_1AbstractFunc_1a699c366fc3c292e8a70941e1c4ee5b0c" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>isPolynomial</name></member>
      <member refid="classcsl_1_1AbstractFunc_1ade1aa692134fee323c2a20824932b506" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>isPurelyImaginary</name></member>
      <member refid="classcsl_1_1AbstractFunc_1ae6828f21be014625ca502d5f40981502" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>isReal</name></member>
      <member refid="classcsl_1_1Abstract_1ab79c1d8df9e6b1a3eca66958f7dc489d" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>matchShape</name></member>
      <member refid="classcsl_1_1Abstract_1ac3978c71035bf1cda50f5b9031d631af" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>memoryOverhead</name></member>
      <member refid="classcsl_1_1Abstract_1a4f5ed458ba62f5b4cf61a9e1f8568af1" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>multiplication_own</name></member>
      <member refid="classcsl_1_1Abstract_1af5b62a6308638064c42da80e9cc2cb7e" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1af4fd1b57df371dac7ccfd5a909620e49" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1a96de5935a58a96d4c5b1e47966488923" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1ac99a619abde7e4c58f39e14d4d20fcf5" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1a45206de7c7773b3cb150451ee3eb379e" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1a0d3495220202bd417c1b58249c923f39" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1AbstractFunc_1a48bd4d1a491e8dd5e555a332c824aff7" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>operator&lt;</name></member>
      <member refid="classcsl_1_1Abstract_1a5c1ba8dce7fbc19eb98807bd15a279c9" prot="public" virt="pure-virtual" ambiguityscope="csl::Abstract::"><scope>csl::AbstractFunc</scope><name>operator&lt;</name></member>
      <member refid="classcsl_1_1Abstract_1a6e19587260a07dba65cf2a985e05516b" prot="public" virt="non-virtual" ambiguityscope="csl::Abstract::"><scope>csl::AbstractFunc</scope><name>operator&lt;</name></member>
      <member refid="classcsl_1_1Abstract_1a2a1660498f2638f5e490d6e512eb32f4" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>operator&lt;=</name></member>
      <member refid="classcsl_1_1Abstract_1afbcac6df2fd7ac11f336189cf215124b" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>operator&lt;=</name></member>
      <member refid="classcsl_1_1Abstract_1a59ff2950fc8ca319f87a730450f14545" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>operator=</name></member>
      <member refid="classcsl_1_1AbstractFunc_1a7ccf43edff01ef8c6500b5117ac42213" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a8334e14cd5789168b037d3888ed60edd" prot="public" virt="virtual" ambiguityscope="csl::Abstract::"><scope>csl::AbstractFunc</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a12d929e34039e817e464abc560bd4a9d" prot="public" virt="virtual" ambiguityscope="csl::Abstract::"><scope>csl::AbstractFunc</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a1f78f0cce24c93def3050743bc5f2845" prot="public" virt="non-virtual" ambiguityscope="csl::Abstract::"><scope>csl::AbstractFunc</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1aed43debcac4a19e0da44986774c522bc" prot="public" virt="non-virtual" ambiguityscope="csl::Abstract::"><scope>csl::AbstractFunc</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a2376f08c0aa5ffe783090381d102d3ae" prot="public" virt="non-virtual" ambiguityscope="csl::Abstract::"><scope>csl::AbstractFunc</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a485c6f3e10db539a70416cd0766b117d" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>operator&gt;</name></member>
      <member refid="classcsl_1_1Abstract_1ab305bdf49212f03781e7f98024faeb66" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>operator&gt;</name></member>
      <member refid="classcsl_1_1Abstract_1a4c8883df19d7538b68fa96aadac9dfa9" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>operator&gt;=</name></member>
      <member refid="classcsl_1_1Abstract_1a6b931f7b159d57bad26ca9c9ea729aa1" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>operator&gt;=</name></member>
      <member refid="classcsl_1_1AbstractFunc_1af3afc58a715c978290e4860101fb3c27" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>operator[]</name></member>
      <member refid="classcsl_1_1AbstractFunc_1ab6a82539b4c61521f13b39bf1b230e68" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>operator[]</name></member>
      <member refid="classcsl_1_1Abstract_1a75d9abfa88d9d09a89d3a4becd9e6429" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>operatorAppliesOn</name></member>
      <member refid="classcsl_1_1Abstract_1abe9aceabbc0a99642e84c9025dbdc767" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>permut</name></member>
      <member refid="classcsl_1_1Abstract_1aed56cb85894209a9bbc9b8bdada5e6ab" prot="public" virt="pure-virtual"><scope>csl::AbstractFunc</scope><name>print</name></member>
      <member refid="classcsl_1_1Abstract_1a2910dd30d90915c11d48c01cab618dda" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>printCode</name></member>
      <member refid="classcsl_1_1Abstract_1a89e45ffc7b65f92e77e592f76f70934c" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>printExplicit</name></member>
      <member refid="classcsl_1_1Abstract_1aa067d4a97135bfe2052a7e21c28f75be" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>printLaTeX</name></member>
      <member refid="classcsl_1_1Abstract_1a0645745feacf93470963b55f93cae1c0" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>printProp</name></member>
      <member refid="classcsl_1_1Abstract_1aaeab3809e91989adbdf29c3f56d905b6" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>refresh</name></member>
      <member refid="classcsl_1_1Abstract_1a8aab87c41acafaf1b1837b922495560d" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>regularLiteral</name></member>
      <member refid="classcsl_1_1Abstract_1a2fe749450d2e610199801b189dc3d0f8" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>regularLiteral</name></member>
      <member refid="classcsl_1_1Abstract_1aba5ef083016b2f3d9e6271f864b9b063" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>regularName</name></member>
      <member refid="classcsl_1_1Abstract_1a1a8421d402d5ba82257188b545e8d668" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>regularName</name></member>
      <member refid="classcsl_1_1Abstract_1a0e778c682b6cb02642b90e8ec8765441" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>removeDependency</name></member>
      <member refid="classcsl_1_1AbstractFunc_1a0714debb1e4fe6d8b6bf1b915771b30c" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>replaceIndex</name></member>
      <member refid="classcsl_1_1Abstract_1a9372ddd521fa661c5d3371e0d8d4dfc3" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>replaceIndexInPlace</name></member>
      <member refid="classcsl_1_1AbstractFunc_1ad1203eab976b86d48100179c93d05178" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>replaceIndices</name></member>
      <member refid="classcsl_1_1Abstract_1af0d95f3edc0562b1d75d60b670119842" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>resetIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1a5c796713828ebfb74a7d8787d7802a76" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>self</name></member>
      <member refid="classcsl_1_1Abstract_1aa6a40ceb6eb1aa79711ca126d5bdda02" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>setAllDependencies</name></member>
      <member refid="classcsl_1_1AbstractFunc_1a701d14b482a47a85c6cd5266118604cb" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>setArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a45c3adb7ba4e2b8442247246a3792b44" prot="public" virt="virtual" ambiguityscope="csl::Abstract::"><scope>csl::AbstractFunc</scope><name>setArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a7bb29d316b8f64652cef472a6c23f001" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>setCommutable</name></member>
      <member refid="classcsl_1_1Abstract_1ae35385480a1be08f5e7433535b58ac0b" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>setComplexProperty</name></member>
      <member refid="classcsl_1_1Abstract_1a37ebc247831d6629d44117a490fca120" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>setConjugated</name></member>
      <member refid="classcsl_1_1Abstract_1aa6a04bb56578e7da143b3cd8d8fb7b26" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>setElementary</name></member>
      <member refid="classcsl_1_1Abstract_1afa50c743b8e7e76e637e98f165ad4e5d" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>setEmpty</name></member>
      <member refid="classcsl_1_1Abstract_1ac318016372d14b795893fe7e59199084" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>setFullyAntiSymmetric</name></member>
      <member refid="classcsl_1_1Abstract_1a4f90ebb7cf7c26782bd36bc2a67fc5d4" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>setFullySymmetric</name></member>
      <member refid="classcsl_1_1Abstract_1a70f946f9c59df045ef7416320ade89c7" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>setIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1a5ecdb6ce7a2d9643da2f6161a06dfbbf" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>setInfBoundary</name></member>
      <member refid="classcsl_1_1Abstract_1a867135c96776248add60018f4aa7a578" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>setName</name></member>
      <member refid="classcsl_1_1Abstract_1a70df7be4486affa8dc891e3f25bf499f" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>setOperand</name></member>
      <member refid="classcsl_1_1Abstract_1ae7b8a14fc746ed72e4d5abd63373c5ba" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>setOperandPrivate</name></member>
      <member refid="classcsl_1_1Abstract_1a3003698af4978e774eeb2e62038f7432" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>setParent</name></member>
      <member refid="classcsl_1_1Abstract_1a3c175411df619e7504feb6d888fc82f1" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>setPoint</name></member>
      <member refid="classcsl_1_1Abstract_1aad7104a5b8855272a92a47c58f29e958" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>setSupBoundary</name></member>
      <member refid="classcsl_1_1Abstract_1aaf7f0692cb84ca861a5b3b641bea518b" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>setValue</name></member>
      <member refid="classcsl_1_1Abstract_1aa49c51bd285830e724f103e9fb61c464" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>setValue</name></member>
      <member refid="classcsl_1_1Abstract_1aa47ddab3aa047e86be34c70358d53548" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>setVariable</name></member>
      <member refid="classcsl_1_1Abstract_1a83fee8ed28079bcac107455d58be9d5d" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>setVectorArgument</name></member>
      <member refid="classcsl_1_1AbstractFunc_1ab02f71922f94812d9ef24766ce51aaa2" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>size</name></member>
      <member refid="classcsl_1_1Abstract_1a4eeedaeaa39e75facf1060dce7c57a8f" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>suppressExponent</name></member>
      <member refid="classcsl_1_1Abstract_1a43520e1d6d5fdad9b50f77c6e027f928" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>suppressTerm</name></member>
      <member refid="classcsl_1_1Abstract_1a4faf1ffd8cb3b6c721e128980c0303d8" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>symmetrise</name></member>
      <member refid="classcsl_1_1Abstract_1a7b83c6a13716688f45b02e6291d39aba" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>tensordot</name></member>
      <member refid="classcsl_1_1Abstract_1aee4fa41a5e014f067395467542ee8831" prot="public" virt="non-virtual"><scope>csl::AbstractFunc</scope><name>testDummy</name></member>
      <member refid="classcsl_1_1Abstract_1a9a86d21f5c5f65eb7e524a8f8002c0e7" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>trace</name></member>
      <member refid="classcsl_1_1Abstract_1aacab43e551e9259a39a79378373ce49c" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>trace</name></member>
      <member refid="classcsl_1_1Abstract_1a1e97712696e5c40b28bc1e35987fea94" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>transpose</name></member>
      <member refid="classcsl_1_1Abstract_1a40bdc4c76fdbbf3cbac3af4dce8286ed" prot="public" virt="virtual"><scope>csl::AbstractFunc</scope><name>~Abstract</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
