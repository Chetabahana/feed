<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.12.0" xml:lang="en-US">
  <compounddef id="classcsl_1_1IProd" kind="class" language="C++" prot="public">
    <compoundname>csl::IProd</compoundname>
    <basecompoundref refid="classcsl_1_1Prod" prot="public" virt="non-virtual">csl::Prod</basecompoundref>
    <includes refid="indicial_8h" local="no">indicial.h</includes>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="classcsl_1_1IProd_1a1b5a6696cf9b3c05bff2fc0b55c520ac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>csl::IProd::IProd</definition>
        <argsstring>()</argsstring>
        <name>IProd</name>
        <qualifiedname>csl::IProd::IProd</qualifiedname>
        <briefdescription>
<para>Default constructor. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="1087" column="5" bodyfile="src/csl/indicial.cpp" bodystart="3403" bodyend="3405"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1IProd_1af98f5daa6ce50924e3e3da95ca85f7a9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>csl::IProd::IProd</definition>
        <argsstring>(const csl::vector_expr &amp;t_argument, bool explicitProd=0)</argsstring>
        <name>IProd</name>
        <qualifiedname>csl::IProd::IProd</qualifiedname>
        <param>
          <type>const csl::vector_expr &amp;</type>
          <declname>t_argument</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>explicitProd</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Constructor for a vector of arguments, and the explicitProd parameter (if <bold>true</bold>, we do not execute for <ref refid="classcsl_1_1IProd_1a0ceb2414cba9609088bc2b0461ba2191" kindref="member">mergeTerms()</ref>, and the vector of arguments stays as it is. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t_argument</parametername>
</parameternamelist>
<parameterdescription>
<para>std::vector of arguments in the product. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>explicitProd</parametername>
</parameternamelist>
<parameterdescription>
<para>Tells if the product is explicit or not, if it must stay as this explicit list of arguments or not. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="1098" column="5" bodyfile="src/csl/indicial.cpp" bodystart="3407" bodyend="3420"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1IProd_1ac37a0c740077c5d3c4bb71c806a27b43" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>csl::IProd::IProd</definition>
        <argsstring>(const Expr &amp;leftOperand, const Expr &amp;rightOperand, bool explicitProd=0)</argsstring>
        <name>IProd</name>
        <qualifiedname>csl::IProd::IProd</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>leftOperand</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>rightOperand</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>explicitProd</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Constructor with a left and right operands for the product. The explicitProd variable has the same meaning as for the other constructor. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>leftOperand</parametername>
</parameternamelist>
<parameterdescription>
<para>Left operand. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rightOperand</parametername>
</parameternamelist>
<parameterdescription>
<para>Right Operand. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>explicitProd</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="1109" column="5" bodyfile="src/csl/indicial.cpp" bodystart="3422" bodyend="3451"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1IProd_1a046bd2f7ea7fb90fdf1dadad1a69af64" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::IProd::isIndexed</definition>
        <argsstring>() const override</argsstring>
        <name>isIndexed</name>
        <qualifiedname>csl::IProd::isIndexed</qualifiedname>
        <reimplements refid="classcsl_1_1Prod_1acb1ea1810e83874623d07f370efde5c2">isIndexed</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><bold>True</bold> if the expression is indexed. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="1120" column="10" bodyfile="src/csl/indicial.cpp" bodystart="3453" bodyend="3456"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1IProd_1ae5870d95277493876ab0464e98d30c6a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1IndexStructure" kindref="compound">IndexStructure</ref></type>
        <definition>IndexStructure csl::IProd::getIndexStructure</definition>
        <argsstring>() const override</argsstring>
        <name>getIndexStructure</name>
        <qualifiedname>csl::IProd::getIndexStructure</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1ae125a32b6f3d0368b6055d4e58c1ff3f">getIndexStructure</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The index structure of the <bold>Indicial</bold> expression </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="1122" column="20" bodyfile="src/csl/indicial.cpp" bodystart="3458" bodyend="3469"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1IProd_1aca4461b782859509b8a9a1deb3846bc3" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::IProd::suppressTerm</definition>
        <argsstring>(Expr_info term) const override</argsstring>
        <name>suppressTerm</name>
        <qualifiedname>csl::IProd::suppressTerm</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a43520e1d6d5fdad9b50f77c6e027f928">suppressTerm</reimplements>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Remove a factor from an expr, that must have been determined before. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>factor</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to remove </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The expr in which <bold>factor</bold> has been removed </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="1124" column="10" bodyfile="src/csl/indicial.cpp" bodystart="3471" bodyend="3511"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1IProd_1a9c6895c9d37d17614f54e3baeec96585" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::IProd::setArgument</definition>
        <argsstring>(const Expr &amp;arg, int iArg=0) override</argsstring>
        <name>setArgument</name>
        <qualifiedname>csl::IProd::setArgument</qualifiedname>
        <reimplements refid="classcsl_1_1AbstractMultiFunc_1a6cf9bbbcd0b0b3f75121f1c0a5cf4d57">setArgument</reimplements>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>t_argument</declname>
        </param>
        <param>
          <type>int</type>
          <declname>iArg</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Replaces one particular <bold>argument</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t_argument</parametername>
</parameternamelist>
<parameterdescription>
<para>New argument. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>iArg(default=0)</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> of the argument to replace with t_argument. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="1126" column="10" bodyfile="src/csl/indicial.cpp" bodystart="3513" bodyend="3522"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1IProd_1ac336baabde24424fc39efd66acc084ca" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::IProd::evaluate</definition>
        <argsstring>(csl::eval::mode user_mode=csl::eval::base) const override</argsstring>
        <name>evaluate</name>
        <qualifiedname>csl::IProd::evaluate</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aa3a4cb7f30e2a422fe27a513e03d6600">evaluate</reimplements>
        <param>
          <type>csl::eval::mode</type>
          <declname>user_mode</declname>
          <defval>csl::eval::base</defval>
        </param>
        <briefdescription>
<para><bold>Evaluates</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>Replaces all variables by their value and evaluating. This function must be used instead of <ref refid="classcsl_1_1Prod_1a3bfdd94f06244aa5af7027901d9e00dd" kindref="member">evaluateScalar()</ref> when treating not only real scalars.* In particular (x=2, y=3) x+iy evaluates to 3+ 3i whereas <ref refid="classcsl_1_1Prod_1a3bfdd94f06244aa5af7027901d9e00dd" kindref="member">evaluateScalar()</ref> would return 3. <simplesect kind="return"><para>The abstract result of the evaluation. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="1128" column="19" bodyfile="src/csl/indicial.cpp" bodystart="3561" bodyend="3610"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1IProd_1ac637d764dc5944b74427194fc885bbe7" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::IProd::getTransposed</definition>
        <argsstring>(const Space *space, bool applyProp=true) const override</argsstring>
        <name>getTransposed</name>
        <qualifiedname>csl::IProd::getTransposed</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a404c5e89a3aad8a8dabcb56d4120c0fe">getTransposed</reimplements>
        <param>
          <type>const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> *</type>
          <declname>space</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>applyProp</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="1131" column="19" bodyfile="src/csl/indicial.cpp" bodystart="3740" bodyend="3743"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1IProd_1a4f00332faae45fd8f1e2226ec4600c2a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::IProd::getTransposed</definition>
        <argsstring>(const std::vector&lt; const Space * &gt; &amp;spaces, bool applyProp=true) const override</argsstring>
        <name>getTransposed</name>
        <qualifiedname>csl::IProd::getTransposed</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aca3debb143668fd3ab75a27a47dd0c13">getTransposed</reimplements>
        <param>
          <type>const std::vector&lt; const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> * &gt; &amp;</type>
          <declname>spaces</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>applyProp</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="1134" column="19" bodyfile="src/csl/indicial.cpp" bodystart="3745" bodyend="3765"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1IProd_1a8f32fd847835d145cc8b4ff062d03c7d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::IProd::replaceIndex</definition>
        <argsstring>(const Index &amp;indexToReplace, const Index &amp;newIndex, bool refresh=true) const override</argsstring>
        <name>replaceIndex</name>
        <qualifiedname>csl::IProd::replaceIndex</qualifiedname>
        <reimplements refid="classcsl_1_1AbstractMultiFunc_1a636313fd58465a56d3b41cb74f9ffaff">replaceIndex</reimplements>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>indexToReplace</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>newIndex</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>refresh</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>For indicial expressions, this function searches <bold>indexToContract</bold> and replaces it with newIndex. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>indexToContract</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> that is newly contracted. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>newIndex</parametername>
</parameternamelist>
<parameterdescription>
<para>Dummy new index that replaces <bold>indexToContract</bold> in the expression. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if the index has been found. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="1137" column="19" bodyfile="src/csl/indicial.cpp" bodystart="3841" bodyend="3857"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1IProd_1abfe07d5009e2813511d936c662ddbef3" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::IProd::replaceIndices</definition>
        <argsstring>(std::vector&lt; Index &gt; const &amp;indexToReplace, std::vector&lt; Index &gt; const &amp;newIndex, bool refresh=true, bool flipped=false) const override</argsstring>
        <name>replaceIndices</name>
        <qualifiedname>csl::IProd::replaceIndices</qualifiedname>
        <reimplements refid="classcsl_1_1AbstractMultiFunc_1a3db6d93888f6b8bb5719549e522a4afa">replaceIndices</reimplements>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &gt; const &amp;</type>
          <declname>indexToReplace</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &gt; const &amp;</type>
          <declname>newIndex</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>refresh</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>flipped</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="1142" column="5" bodyfile="src/csl/indicial.cpp" bodystart="3859" bodyend="3877"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1IProd_1a1af490741907446eb7839206e4546846" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>csl::vector_expr</type>
        <definition>csl::vector_expr csl::IProd::breakSpace</definition>
        <argsstring>(const Space *brokenSpace, const std::vector&lt; const Space * &gt; &amp;newSpaces, const std::vector&lt; std::string &gt; &amp;indexNames) const override</argsstring>
        <name>breakSpace</name>
        <qualifiedname>csl::IProd::breakSpace</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1af0f40b77914e45f56bf87839d00211d7">breakSpace</reimplements>
        <param>
          <type>const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> *</type>
          <declname>brokenSpace</declname>
        </param>
        <param>
          <type>const std::vector&lt; const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> * &gt; &amp;</type>
          <declname>newSpaces</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::string &gt; &amp;</type>
          <declname>indexNames</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="1148" column="5" bodyfile="src/csl/indicial.cpp" bodystart="4030" bodyend="4110"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1IProd_1a0ceb2414cba9609088bc2b0461ba2191" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::IProd::mergeTerms</definition>
        <argsstring>() override</argsstring>
        <name>mergeTerms</name>
        <qualifiedname>csl::IProd::mergeTerms</qualifiedname>
        <reimplements refid="classcsl_1_1Prod_1a6fd5885a37a7e6492ec7777121e23944">mergeTerms</reimplements>
        <briefdescription>
<para>Merge identical terms. </para>
        </briefdescription>
        <detaileddescription>
<para>When identical terms (identical to a numerical factor) appear this function merge them in the same term. Example: x*y*x^2 -&gt; x^3+y. <simplesect kind="return"><para><bold>True</bold> if terms have been merged. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="1152" column="10" bodyfile="src/csl/indicial.cpp" bodystart="4216" bodyend="4273"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1IProd_1a5931b2beabc59ad1724b9704d5cc934f" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::IProd::leftInsert</definition>
        <argsstring>(const Expr &amp;expr) override</argsstring>
        <name>leftInsert</name>
        <qualifiedname>csl::IProd::leftInsert</qualifiedname>
        <reimplements refid="classcsl_1_1Prod_1a25c92e6737d3ca9f449535f90d97d3da">leftInsert</reimplements>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="1154" column="10" bodyfile="src/csl/indicial.cpp" bodystart="4112" bodyend="4162"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1IProd_1a5c240d3e6eeea0de1c95ab49b2891063" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::IProd::rightInsert</definition>
        <argsstring>(const Expr &amp;expr) override</argsstring>
        <name>rightInsert</name>
        <qualifiedname>csl::IProd::rightInsert</qualifiedname>
        <reimplements refid="classcsl_1_1Prod_1af7f0a0b4fb87b06466360b81094469a1">rightInsert</reimplements>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="1156" column="10" bodyfile="src/csl/indicial.cpp" bodystart="4163" bodyend="4214"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1IProd_1a55b05e348d5a51d47d119059659b0ccb" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::IProd::compareWithDummy</definition>
        <argsstring>(Expr_info expr, std::map&lt; Index, Index &gt; &amp;constraints, bool keepAllCosntraints=false) const override</argsstring>
        <name>compareWithDummy</name>
        <qualifiedname>csl::IProd::compareWithDummy</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a7caee12abb451168149779a668dfc59e">compareWithDummy</reimplements>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::map&lt; <ref refid="classcsl_1_1Index" kindref="compound">Index</ref>, <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &gt; &amp;</type>
          <declname>constraints</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>keepAllCosntraints</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Comparison disregarding name of dummy indices, i.e. the two expressions * are equals even if dummy indices have not the same names in *this and * expr. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to compare.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>constraints</parametername>
</parameternamelist>
<parameterdescription>
<para>List of existing constraints between indices (it is modified in the function).</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if expr == *this taking constraints into account. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="1158" column="10" bodyfile="src/csl/indicial.cpp" bodystart="4275" bodyend="4360"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1IProd_1af45bd102ad6a062167330ab8715daf78" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::IProd::operator==</definition>
        <argsstring>(Expr_info expr) const override</argsstring>
        <name>operator==</name>
        <qualifiedname>csl::IProd::operator==</qualifiedname>
        <reimplements refid="classcsl_1_1Prod_1a1a2c0f67a8aa5798dd9226d721237a8a">operator==</reimplements>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Compares</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> with another. </para>
        </briefdescription>
        <detaileddescription>
<para>Here if two Abstracts have the same name, the function will return <bold>true</bold> even if they are <bold>not</bold> <bold>mathematically</bold> <bold>equal</bold>. So beware not to name different things the same way. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> to compare. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if the two Abstracts are the same (or have the same name). </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="1162" column="10" bodyfile="src/csl/indicial.cpp" bodystart="4362" bodyend="4384"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="protected-func">
      <memberdef kind="function" id="classcsl_1_1IProd_1a0d8d2b4422c919a70caf945c1ea35984" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::IProd::selfCheckIndexStructure</definition>
        <argsstring>(bool explicitTimes=false)</argsstring>
        <name>selfCheckIndexStructure</name>
        <qualifiedname>csl::IProd::selfCheckIndexStructure</qualifiedname>
        <param>
          <type>bool</type>
          <declname>explicitTimes</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Checks for index contractions in the product. Applies Einstein&apos;s summation convention and sums automatically repeated indices. This function is called after the construction in order to leave a correct expression. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="1171" column="10" bodyfile="src/csl/indicial.cpp" bodystart="3626" bodyend="3738"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1IProd_1a27022cfc001b941db7af2a0b8d593965" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::IProd::partialComparison</definition>
        <argsstring>(Expr_info expr) const override</argsstring>
        <name>partialComparison</name>
        <qualifiedname>csl::IProd::partialComparison</qualifiedname>
        <reimplements refid="classcsl_1_1Prod_1a06a4864e62023461f8b986e805d5cd51">partialComparison</reimplements>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="1173" column="10" bodyfile="src/csl/indicial.cpp" bodystart="4386" bodyend="4445"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1IProd_1a4c2d3428d645ad166076573569786af9" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::IProd::applyContractionChains</definition>
        <argsstring>()</argsstring>
        <name>applyContractionChains</name>
        <qualifiedname>csl::IProd::applyContractionChains</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="1175" column="10" bodyfile="src/csl/indicial.cpp" bodystart="3767" bodyend="3790"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1IProd_1ac058b092d3180d0e6b6a2e0f945d560b" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IProd::hasSeparableIndicialDenominator</definition>
        <argsstring>() const</argsstring>
        <name>hasSeparableIndicialDenominator</name>
        <qualifiedname>csl::IProd::hasSeparableIndicialDenominator</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="1177" column="10" bodyfile="src/csl/indicial.cpp" bodystart="3792" bodyend="3812"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1IProd_1a2e262fdb83cc4f69d7e0ed0a6f74bfd9" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IProd::compareDenominatorSeparately</definition>
        <argsstring>(Expr_info other) const</argsstring>
        <name>compareDenominatorSeparately</name>
        <qualifiedname>csl::IProd::compareDenominatorSeparately</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="1179" column="10" bodyfile="src/csl/indicial.cpp" bodystart="3814" bodyend="3839"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>Specialization of a <ref refid="classcsl_1_1Prod" kindref="compound">Prod</ref> object to handle <ref refid="classcsl_1_1TensorElement" kindref="compound">TensorElement</ref> objects in the product (apply contraction of indices etc). </para>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <inheritancegraph>
      <node id="4">
        <label>csl::Abstract</label>
        <link refid="classcsl_1_1Abstract"/>
      </node>
      <node id="3">
        <label>csl::AbstractMultiFunc</label>
        <link refid="classcsl_1_1AbstractMultiFunc"/>
        <childnode refid="4" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1">
        <label>csl::IProd</label>
        <link refid="classcsl_1_1IProd"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>csl::Prod</label>
        <link refid="classcsl_1_1Prod"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="4">
        <label>csl::Abstract</label>
        <link refid="classcsl_1_1Abstract"/>
      </node>
      <node id="3">
        <label>csl::AbstractMultiFunc</label>
        <link refid="classcsl_1_1AbstractMultiFunc"/>
        <childnode refid="4" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1">
        <label>csl::IProd</label>
        <link refid="classcsl_1_1IProd"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>csl::Prod</label>
        <link refid="classcsl_1_1Prod"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
    </collaborationgraph>
    <location file="src/csl/indicial.h" line="1081" column="1" bodyfile="src/csl/indicial.h" bodystart="1081" bodyend="1180"/>
    <listofallmembers>
      <member refid="classcsl_1_1Abstract_1ad5fee68c1f3dcbda0e936926fed17616" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>Abstract</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1ad7c6d28772b2684c20a42bbfcb8cf257" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>AbstractMultiFunc</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1a7ccbae6ee27d3e2e26187ef3ea8f92b8" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>AbstractMultiFunc</name></member>
      <member refid="classcsl_1_1Abstract_1a5549ac0c186b3c6febf332245a25a82c" prot="public" virt="virtual"><scope>csl::IProd</scope><name>addAntiSymmetry</name></member>
      <member refid="classcsl_1_1Abstract_1abbab11282e5c6ac46b018642ff129f47" prot="public" virt="virtual"><scope>csl::IProd</scope><name>addDependency</name></member>
      <member refid="classcsl_1_1Abstract_1a101219973341a39cf15f07e5e1aa388f" prot="public" virt="virtual"><scope>csl::IProd</scope><name>addition_own</name></member>
      <member refid="classcsl_1_1Abstract_1ad431770faa4291116a50175193a11a88" prot="public" virt="virtual"><scope>csl::IProd</scope><name>addSymmetry</name></member>
      <member refid="classcsl_1_1Abstract_1acd972aed8326d4c13534594e061ee6da" prot="public" virt="virtual"><scope>csl::IProd</scope><name>antisymmetrise</name></member>
      <member refid="classcsl_1_1IProd_1a4c2d3428d645ad166076573569786af9" prot="protected" virt="non-virtual"><scope>csl::IProd</scope><name>applyContractionChains</name></member>
      <member refid="classcsl_1_1Abstract_1a61d3ab932182226f4670a62bbb22af4e" prot="public" virt="virtual"><scope>csl::IProd</scope><name>applyDiracDelta</name></member>
      <member refid="classcsl_1_1Abstract_1a316956fea77627a716500a2bbfc1f3b7" prot="public" virt="virtual"><scope>csl::IProd</scope><name>applyOperator</name></member>
      <member refid="classcsl_1_1Abstract_1a6305ce90c795bfb416d8e958c62f905c" prot="public" virt="virtual"><scope>csl::IProd</scope><name>applySelfStructureOn</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1a8e44404eb3e6c23f7c7ddf10cdd3a152" prot="protected" virt="non-virtual"><scope>csl::IProd</scope><name>argument</name></member>
      <member refid="classcsl_1_1Prod_1adb2f82801fb73fb0baaaa18079e6cfa5" prot="public" virt="virtual"><scope>csl::IProd</scope><name>askTerm</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1a6236c27a797993973fb45dc9f4906962" prot="public" virt="virtual"><scope>csl::IProd</scope><name>begin</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1aa405a3e5cd03bb390ce3e804fe8af806" prot="public" virt="virtual"><scope>csl::IProd</scope><name>begin</name></member>
      <member refid="classcsl_1_1IProd_1a1af490741907446eb7839206e4546846" prot="public" virt="virtual"><scope>csl::IProd</scope><name>breakSpace</name></member>
      <member refid="classcsl_1_1Abstract_1aa4cba37520821432f37e212fefbc2534" prot="public" virt="non-virtual" ambiguityscope="csl::Prod::"><scope>csl::IProd</scope><name>breakSpace</name></member>
      <member refid="classcsl_1_1Abstract_1afd9d0336808e8adf4ccdccb51587ed8c" prot="public" virt="virtual"><scope>csl::IProd</scope><name>checkIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1a1ebd84082bb93418408cc0babe2dffe2" prot="public" virt="virtual"><scope>csl::IProd</scope><name>checkIndexStructure</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1accd66bc16179cf88684a6db68e277921" prot="public" virt="virtual"><scope>csl::IProd</scope><name>collect</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1ac54eff0c503e2c2947b232622261c998" prot="public" virt="virtual"><scope>csl::IProd</scope><name>commutesWith</name></member>
      <member refid="classcsl_1_1IProd_1a2e262fdb83cc4f69d7e0ed0a6f74bfd9" prot="protected" virt="non-virtual"><scope>csl::IProd</scope><name>compareDenominatorSeparately</name></member>
      <member refid="classcsl_1_1IProd_1a55b05e348d5a51d47d119059659b0ccb" prot="public" virt="virtual"><scope>csl::IProd</scope><name>compareWithDummy</name></member>
      <member refid="classcsl_1_1Abstract_1a0f16fda9fe72a89c61ece36101a11d95" prot="public" virt="non-virtual" ambiguityscope="csl::Prod::"><scope>csl::IProd</scope><name>compareWithDummy</name></member>
      <member refid="classcsl_1_1Abstract_1aed79d20a0821205e6430c80a474117d3" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>contractIndex</name></member>
      <member refid="classcsl_1_1Abstract_1ad874fc858295a737e6ce884530f1109b" prot="public" virt="virtual"><scope>csl::IProd</scope><name>contraction</name></member>
      <member refid="classcsl_1_1Abstract_1abd35096982e92b669ea55d960c5f44be" prot="public" virt="virtual"><scope>csl::IProd</scope><name>contraction</name></member>
      <member refid="classcsl_1_1Abstract_1af29c2898c5d3ba96de8018a0838c402c" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>copy</name></member>
      <member refid="classcsl_1_1Prod_1a6432de87c86ccfa67a36f0f8e0b351a1" prot="public" virt="virtual"><scope>csl::IProd</scope><name>copy_unique</name></member>
      <member refid="classcsl_1_1Prod_1a6c78b513ad84145b6429d067e637e51d" prot="public" virt="virtual"><scope>csl::IProd</scope><name>deepCopy</name></member>
      <member refid="classcsl_1_1Prod_1a864b6337e4d97c072b8276bca9b4b0f0" prot="public" virt="virtual"><scope>csl::IProd</scope><name>deepRefresh</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1ad072ccb3f8007430a6d6dce53f32b441" prot="public" virt="virtual"><scope>csl::IProd</scope><name>dependsExplicitlyOn</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1a7c3599e88ef45e1abc9c878432c67ade" prot="public" virt="virtual"><scope>csl::IProd</scope><name>dependsExplicitlyOn</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1a9d64fefa1c3718d1fe431edfa4934e71" prot="public" virt="virtual"><scope>csl::IProd</scope><name>dependsOn</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1a32bbf7b44a59c1efe7e73961da575af4" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>dependsOn</name></member>
      <member refid="classcsl_1_1Abstract_1a9d7d8586a0df66ba8da33528d6400e66" prot="public" virt="virtual" ambiguityscope="csl::Abstract::"><scope>csl::IProd</scope><name>dependsOn</name></member>
      <member refid="classcsl_1_1Prod_1a3830459faf91d3cf17c7fa401fb00557" prot="public" virt="virtual"><scope>csl::IProd</scope><name>derive</name></member>
      <member refid="classcsl_1_1Abstract_1aeb08811cf370616477a92075e4a218ee" prot="public" virt="virtual"><scope>csl::IProd</scope><name>determinant</name></member>
      <member refid="classcsl_1_1Abstract_1a1578c74aee1050b806a67e7a81a67f5c" prot="public" virt="virtual"><scope>csl::IProd</scope><name>division_own</name></member>
      <member refid="classcsl_1_1Abstract_1a4cc7a46deaa3eaa7593909d74e76d4af" prot="public" virt="virtual"><scope>csl::IProd</scope><name>dot</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1ada1ce81d61672e15a142fe8d3bee98bd" prot="public" virt="virtual"><scope>csl::IProd</scope><name>empty</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1a178ccaec7d4546873084591d93398153" prot="public" virt="virtual"><scope>csl::IProd</scope><name>end</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1a42f8f99108068dca2bd7a259577a0bcf" prot="public" virt="virtual"><scope>csl::IProd</scope><name>end</name></member>
      <member refid="classcsl_1_1IProd_1ac336baabde24424fc39efd66acc084ca" prot="public" virt="virtual"><scope>csl::IProd</scope><name>evaluate</name></member>
      <member refid="classcsl_1_1Prod_1a3bfdd94f06244aa5af7027901d9e00dd" prot="public" virt="virtual"><scope>csl::IProd</scope><name>evaluateScalar</name></member>
      <member refid="classcsl_1_1Prod_1a2c508afc1d4a74cd1ca69b1f900993d5" prot="public" virt="virtual"><scope>csl::IProd</scope><name>expand</name></member>
      <member refid="classcsl_1_1Prod_1aa6bb716b3dea854dd7e897976cf08788" prot="public" virt="virtual"><scope>csl::IProd</scope><name>expand_if</name></member>
      <member refid="classcsl_1_1Abstract_1aa2696a0feb43766ef54e1e3dd3d6d134" prot="public" virt="virtual"><scope>csl::IProd</scope><name>exponentiation_own</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1ad9eed372c276bc55ce8614a94962fef6" prot="public" virt="virtual"><scope>csl::IProd</scope><name>factor</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1a71ffe88901a200f59bdb88d4adf09a44" prot="public" virt="virtual"><scope>csl::IProd</scope><name>factor</name></member>
      <member refid="classcsl_1_1Prod_1a6658c74878dc31902a45b75994baef85" prot="public" virt="virtual"><scope>csl::IProd</scope><name>findSubExpression</name></member>
      <member refid="classcsl_1_1Abstract_1a021946e84d8c1a019908cac578b16fe8" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getAllDependencies</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1a75ae783c1bd8e55ccc005af538599def" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getArgument</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1af168c84e071262cc48108cf991526651" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a898d6cf2a7f348feacab189447bee1eb" prot="public" virt="virtual" ambiguityscope="csl::Abstract::"><scope>csl::IProd</scope><name>getArgument</name></member>
      <member refid="classcsl_1_1Abstract_1aa689fb64eecb86edbde6c745d1ce756b" prot="public" virt="virtual" ambiguityscope="csl::Abstract::"><scope>csl::IProd</scope><name>getArgument</name></member>
      <member refid="classcsl_1_1Abstract_1afeb26e1382411448ce3c65d50fefd8bb" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getCanonicalPermutation</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1a2bc449bd37728479b8c6b0a9eea3bccf" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getCommutable</name></member>
      <member refid="classcsl_1_1Prod_1aad33ce50bdda177231353749abb24b71" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getComplexArgument</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1abd84cb1aa54ef9875bae6f806ed1d753" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getComplexConjugate</name></member>
      <member refid="classcsl_1_1Prod_1af42fef880d91a3705f0a86065f53560d" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getComplexModulus</name></member>
      <member refid="classcsl_1_1Abstract_1a470d9f1267fba4a82e13af4a39470f81" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getComplexProperty</name></member>
      <member refid="classcsl_1_1Abstract_1af04c0e4426f0bf9df365afe0148d59df" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getContractedPair</name></member>
      <member refid="classcsl_1_1Abstract_1aec707d949f0f98e08ab4642c93dd9eb5" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getContractionProperties</name></member>
      <member refid="classcsl_1_1Abstract_1aa22f0e4c9c91f43b5cd61cbb873869eb" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getDeltaMinus</name></member>
      <member refid="classcsl_1_1Abstract_1a69a657baf1c35ed581e9db2c47a71c99" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getDeltaPlus</name></member>
      <member refid="classcsl_1_1Abstract_1a9531d78d67c82e288c0130da5b1ba80b" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getDenom</name></member>
      <member refid="classcsl_1_1Abstract_1a5856c3d55a6d1406970f3656e61efe8e" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getDim</name></member>
      <member refid="classcsl_1_1Abstract_1a77e067fc57c0c2e70d141079455fdbd7" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getElementary</name></member>
      <member refid="classcsl_1_1Prod_1a1b3dfc8deb0baece750b925ef1a95402" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getExponents</name></member>
      <member refid="classcsl_1_1Prod_1aaa4dca91f1ce4fc9d6f04d528e07db90" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getFactors</name></member>
      <member refid="classcsl_1_1Abstract_1aa4136dc23f1fba4bf897b54c8592ccfc" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getFreeIndexStructure</name></member>
      <member refid="classcsl_1_1Prod_1a71e5bf0f4ece0fec6e4aa0eb7a70f7be" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getHermitianConjugate</name></member>
      <member refid="classcsl_1_1Prod_1a52f6516bb7bbea2ad5a4fe7754acc0a8" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getHermitianConjugate</name></member>
      <member refid="classcsl_1_1Prod_1add2e178b9370eba2bd70d3ed17512a0c" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getImaginaryPart</name></member>
      <member refid="classcsl_1_1Abstract_1a3234ce243f6a2e11950be42f10100943" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getIndex</name></member>
      <member refid="classcsl_1_1IProd_1ae5870d95277493876ab0464e98d30c6a" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1ae6a9a9ef3efd6bb83b62c0a353742d25" prot="public" virt="non-virtual" ambiguityscope="csl::Prod::"><scope>csl::IProd</scope><name>getIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1addb848bf4cdea207484a71e9b1006ead" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getIndexStructureView</name></member>
      <member refid="classcsl_1_1Abstract_1a632e28530a68539fadacd7ab7ffc8be1" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getIndexStructureView</name></member>
      <member refid="classcsl_1_1Abstract_1a3d6b1e294cf24dea17c3c4361226138b" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getInfBoundary</name></member>
      <member refid="classcsl_1_1Abstract_1a9c4a302d1a3cbf4dd9394f5e5880d343" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getLatexName</name></member>
      <member refid="classcsl_1_1Abstract_1a652101e34b2efa43114150e9af3c79d5" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getLibDependency</name></member>
      <member refid="classcsl_1_1Abstract_1af7f5e7466e754984a2c4394a112464f7" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getName</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1af12bbdfb8a1b45d722d37f2444443457" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getNArgs</name></member>
      <member refid="classcsl_1_1Abstract_1a42125e9765a771c47819548d342b0b28" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getNContractedPairs</name></member>
      <member refid="classcsl_1_1Prod_1a065a0b483082e58a478016d0821427ab" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getNFactor</name></member>
      <member refid="classcsl_1_1Abstract_1add364193f7a78ac28f7001c7f4036453" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getNIndices</name></member>
      <member refid="classcsl_1_1Abstract_1a6aa6bcc7cb8ee1574f29dc6ab6c6f0ed" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getNum</name></member>
      <member refid="classcsl_1_1Prod_1a31991415ad6e7e8e5e9b703f9128af39" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getNumericalFactor</name></member>
      <member refid="classcsl_1_1Abstract_1a9c3ec3dfe1fbd8ead5c8d9aca421a863" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getOperand</name></member>
      <member refid="classcsl_1_1Abstract_1a9500a21d75d03c695ec0c76493600b38" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getOrder</name></member>
      <member refid="classcsl_1_1Prod_1abbd390d2c92c1b3187355c77ad3404c7" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getOrderOf</name></member>
      <member refid="classcsl_1_1Abstract_1ab150130c9f67daaf6aba52b9f6b90941" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getParent</name></member>
      <member refid="classcsl_1_1Abstract_1a15f775b5add9af8727ead2cfaab78ba2" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getParent_info</name></member>
      <member refid="classcsl_1_1Prod_1a68dff5c0b393ad75f5e7e0ac97d229dc" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getParity</name></member>
      <member refid="classcsl_1_1Abstract_1a946d175d946da102c5f4cc91840703cb" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getPermutations</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1aa82b52395acc9570f21ecca507dde7e2" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getPoint</name></member>
      <member refid="classcsl_1_1Prod_1ab552c778033130c31c476b2e1939e84e" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getPolynomialTerm</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1a1b6044133a95c411324d20afe460c55b" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getPrimaryType</name></member>
      <member refid="classcsl_1_1Abstract_1a07489d0569bc983718796d21c73f34b3" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getProduct</name></member>
      <member refid="classcsl_1_1Prod_1a74b08ed837b9be3299e99b5b355cb4d4" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getRealPart</name></member>
      <member refid="classcsl_1_1Abstract_1a5b77f008f4b95030641224877004f06c" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getRegularExpression</name></member>
      <member refid="classcsl_1_1Abstract_1a625efe55a17b97a1c0f085bdbf3a962a" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getShape</name></member>
      <member refid="classcsl_1_1Abstract_1aa83df1d9dc202457113e5b38bd694fae" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getSign</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1af5fc70d8f2b9e7df0dfff973a754432a" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getSubSymbols</name></member>
      <member refid="classcsl_1_1Abstract_1a7dcdc11b64c8c515933882168d0792ef" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1a413c50b2663f57d38c1d3ec3cfeaa3ce" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1a26a0854bca4c47e84a1da36a3de8c49f" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1a29261a946b3398b6129237620754a8b9" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1a8a067b70756c4eef758aa88076a95162" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1aeaf8154e39ff211b12e6382e675ccaad" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getSum</name></member>
      <member refid="classcsl_1_1Abstract_1a2fcc223dbf5d880e923c07df142df5c8" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getSupBoundary</name></member>
      <member refid="classcsl_1_1Prod_1a428ffb91c3529b4835d6bfa6289765d8" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getTerm</name></member>
      <member refid="classcsl_1_1IProd_1ac637d764dc5944b74427194fc885bbe7" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getTransposed</name></member>
      <member refid="classcsl_1_1IProd_1a4f00332faae45fd8f1e2226ec4600c2a" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getTransposed</name></member>
      <member refid="classcsl_1_1Prod_1af0bd5312033ca6006d54e117503cc52b" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getType</name></member>
      <member refid="classcsl_1_1Abstract_1a78f98ba06476e464e3fd2fce0d1f8243" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getValue</name></member>
      <member refid="classcsl_1_1Abstract_1a628563238145f3a9acc331f1a89ce32f" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getValued</name></member>
      <member refid="classcsl_1_1Abstract_1ae85f810bbadbc792210c958e8f1b2ffb" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getVariable</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1a5e910beb3bdf8459306fe0cda78c1c76" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getVectorArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a0188b049736016c970a2513ed9f6931f" prot="public" virt="virtual"><scope>csl::IProd</scope><name>getVectorialModulus</name></member>
      <member refid="classcsl_1_1Abstract_1a94bf1455397fdd2df8dbbc3b41c2f3f4" prot="public" virt="virtual"><scope>csl::IProd</scope><name>hasChainContractionProperty</name></member>
      <member refid="classcsl_1_1Abstract_1aa31e08c251d96b8ea8ec8d385895c1ff" prot="public" virt="virtual"><scope>csl::IProd</scope><name>hasContractionProperty</name></member>
      <member refid="classcsl_1_1IProd_1ac058b092d3180d0e6b6a2e0f945d560b" prot="protected" virt="non-virtual"><scope>csl::IProd</scope><name>hasSeparableIndicialDenominator</name></member>
      <member refid="classcsl_1_1Abstract_1a8c42723e8bc6334c99f00898cc1d59d7" prot="public" virt="virtual"><scope>csl::IProd</scope><name>hermitian</name></member>
      <member refid="classcsl_1_1Prod_1ae065e3860edfd408a1cdef2bfb259b2e" prot="public" virt="virtual"><scope>csl::IProd</scope><name>insert</name></member>
      <member refid="classcsl_1_1Abstract_1a1b68943aa7ecf60a63af0f2f368eef8f" prot="public" virt="virtual"><scope>csl::IProd</scope><name>inverseMatrix</name></member>
      <member refid="classcsl_1_1IProd_1a1b5a6696cf9b3c05bff2fc0b55c520ac" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>IProd</name></member>
      <member refid="classcsl_1_1IProd_1af98f5daa6ce50924e3e3da95ca85f7a9" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>IProd</name></member>
      <member refid="classcsl_1_1IProd_1ac37a0c740077c5d3c4bb71c806a27b43" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>IProd</name></member>
      <member refid="classcsl_1_1Abstract_1a9347e75b0cd0b75e0f0a38db93b29d83" prot="public" virt="virtual"><scope>csl::IProd</scope><name>isAnOperator</name></member>
      <member refid="classcsl_1_1Abstract_1ac09992d147b39388c8936b3bff648930" prot="public" virt="virtual"><scope>csl::IProd</scope><name>isArbitrary</name></member>
      <member refid="classcsl_1_1Abstract_1ad74c068f1da78856321932b6b6ae17dc" prot="public" virt="virtual"><scope>csl::IProd</scope><name>isBuildingBlock</name></member>
      <member refid="classcsl_1_1Abstract_1a22a594845a29429c9b4f19c92bd18cad" prot="public" virt="virtual"><scope>csl::IProd</scope><name>isComplexConjugate</name></member>
      <member refid="classcsl_1_1Abstract_1a464f4f0613db9b4b0a4efe26a3a03d60" prot="public" virt="virtual"><scope>csl::IProd</scope><name>isEmpty</name></member>
      <member refid="classcsl_1_1Abstract_1af2ce38838e35c5785f92373a1d830668" prot="public" virt="virtual"><scope>csl::IProd</scope><name>isHermitianConjugate</name></member>
      <member refid="classcsl_1_1IProd_1a046bd2f7ea7fb90fdf1dadad1a69af64" prot="public" virt="virtual"><scope>csl::IProd</scope><name>isIndexed</name></member>
      <member refid="classcsl_1_1Abstract_1a9a014bfd266b5f8471f23580e271979b" prot="public" virt="virtual"><scope>csl::IProd</scope><name>isInteger</name></member>
      <member refid="classcsl_1_1Prod_1ad52e8f95508d38377324e9ef8fb4c28d" prot="public" virt="virtual"><scope>csl::IProd</scope><name>isPolynomial</name></member>
      <member refid="classcsl_1_1Prod_1a1ae03daccbb1d0ff134d51f8b2a64fb4" prot="public" virt="virtual"><scope>csl::IProd</scope><name>isPurelyImaginary</name></member>
      <member refid="classcsl_1_1Prod_1ae0608fd2fa4b22da81d692483f01b9fb" prot="public" virt="virtual"><scope>csl::IProd</scope><name>isReal</name></member>
      <member refid="classcsl_1_1IProd_1a5931b2beabc59ad1724b9704d5cc934f" prot="public" virt="virtual"><scope>csl::IProd</scope><name>leftInsert</name></member>
      <member refid="classcsl_1_1Abstract_1ab79c1d8df9e6b1a3eca66958f7dc489d" prot="public" virt="virtual"><scope>csl::IProd</scope><name>matchShape</name></member>
      <member refid="classcsl_1_1Abstract_1ac3978c71035bf1cda50f5b9031d631af" prot="public" virt="virtual"><scope>csl::IProd</scope><name>memoryOverhead</name></member>
      <member refid="classcsl_1_1Prod_1a39c0e506ddcbe6912bfb37b0ea55144f" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>mergeNumericals</name></member>
      <member refid="classcsl_1_1Prod_1a6f78613f8125446c9128906ab490c18c" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>mergeProducts</name></member>
      <member refid="classcsl_1_1IProd_1a0ceb2414cba9609088bc2b0461ba2191" prot="public" virt="virtual"><scope>csl::IProd</scope><name>mergeTerms</name></member>
      <member refid="classcsl_1_1Abstract_1a4f5ed458ba62f5b4cf61a9e1f8568af1" prot="public" virt="virtual"><scope>csl::IProd</scope><name>multiplication_own</name></member>
      <member refid="classcsl_1_1Abstract_1af5b62a6308638064c42da80e9cc2cb7e" prot="public" virt="virtual"><scope>csl::IProd</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1af4fd1b57df371dac7ccfd5a909620e49" prot="public" virt="virtual"><scope>csl::IProd</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1a96de5935a58a96d4c5b1e47966488923" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1ac99a619abde7e4c58f39e14d4d20fcf5" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1a45206de7c7773b3cb150451ee3eb379e" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1a0d3495220202bd417c1b58249c923f39" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Prod_1a056eb7df43a68c75f9a498583bd00e6b" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>operator&lt;</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1ad4be44fbde5ebd97065a575992d498c2" prot="public" virt="virtual" ambiguityscope="csl::AbstractMultiFunc::"><scope>csl::IProd</scope><name>operator&lt;</name></member>
      <member refid="classcsl_1_1Abstract_1a6e19587260a07dba65cf2a985e05516b" prot="public" virt="non-virtual" ambiguityscope="csl::Abstract::"><scope>csl::IProd</scope><name>operator&lt;</name></member>
      <member refid="classcsl_1_1Abstract_1a2a1660498f2638f5e490d6e512eb32f4" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>operator&lt;=</name></member>
      <member refid="classcsl_1_1Abstract_1afbcac6df2fd7ac11f336189cf215124b" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>operator&lt;=</name></member>
      <member refid="classcsl_1_1Abstract_1a59ff2950fc8ca319f87a730450f14545" prot="public" virt="virtual"><scope>csl::IProd</scope><name>operator=</name></member>
      <member refid="classcsl_1_1IProd_1af45bd102ad6a062167330ab8715daf78" prot="public" virt="virtual"><scope>csl::IProd</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a8334e14cd5789168b037d3888ed60edd" prot="public" virt="virtual" ambiguityscope="csl::AbstractMultiFunc::"><scope>csl::IProd</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a12d929e34039e817e464abc560bd4a9d" prot="public" virt="virtual" ambiguityscope="csl::AbstractMultiFunc::"><scope>csl::IProd</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a1f78f0cce24c93def3050743bc5f2845" prot="public" virt="non-virtual" ambiguityscope="csl::AbstractMultiFunc::"><scope>csl::IProd</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1aed43debcac4a19e0da44986774c522bc" prot="public" virt="non-virtual" ambiguityscope="csl::AbstractMultiFunc::"><scope>csl::IProd</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a2376f08c0aa5ffe783090381d102d3ae" prot="public" virt="non-virtual" ambiguityscope="csl::AbstractMultiFunc::"><scope>csl::IProd</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a485c6f3e10db539a70416cd0766b117d" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>operator&gt;</name></member>
      <member refid="classcsl_1_1Abstract_1ab305bdf49212f03781e7f98024faeb66" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>operator&gt;</name></member>
      <member refid="classcsl_1_1Abstract_1a4c8883df19d7538b68fa96aadac9dfa9" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>operator&gt;=</name></member>
      <member refid="classcsl_1_1Abstract_1a6b931f7b159d57bad26ca9c9ea729aa1" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>operator&gt;=</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1a26979a899fab4621102645d0f8366457" prot="public" virt="virtual"><scope>csl::IProd</scope><name>operator[]</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1ae4922013ae4c2b23e6fab8bc9056ab42" prot="public" virt="virtual"><scope>csl::IProd</scope><name>operator[]</name></member>
      <member refid="classcsl_1_1Abstract_1a75d9abfa88d9d09a89d3a4becd9e6429" prot="public" virt="virtual"><scope>csl::IProd</scope><name>operatorAppliesOn</name></member>
      <member refid="classcsl_1_1Prod_1a1620a57a9851d95851d7f099d5b56d03" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>orderTerms</name></member>
      <member refid="classcsl_1_1IProd_1a27022cfc001b941db7af2a0b8d593965" prot="protected" virt="virtual"><scope>csl::IProd</scope><name>partialComparison</name></member>
      <member refid="classcsl_1_1Abstract_1abe9aceabbc0a99642e84c9025dbdc767" prot="public" virt="virtual"><scope>csl::IProd</scope><name>permut</name></member>
      <member refid="classcsl_1_1Prod_1a6f7a134346d64c86bbc3bf855321a568" prot="public" virt="virtual"><scope>csl::IProd</scope><name>print</name></member>
      <member refid="classcsl_1_1Prod_1a6e232ef31360d821242f56794a558c15" prot="public" virt="virtual"><scope>csl::IProd</scope><name>printCode</name></member>
      <member refid="classcsl_1_1Abstract_1a89e45ffc7b65f92e77e592f76f70934c" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>printExplicit</name></member>
      <member refid="classcsl_1_1Prod_1a3bcfa6d3a4b9a8d1ab4255f01fe7edfd" prot="public" virt="virtual"><scope>csl::IProd</scope><name>printLaTeX</name></member>
      <member refid="classcsl_1_1Abstract_1a0645745feacf93470963b55f93cae1c0" prot="public" virt="virtual"><scope>csl::IProd</scope><name>printProp</name></member>
      <member refid="classcsl_1_1Prod_1ab942e9b327bb3b766a647126faf0937f" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>Prod</name></member>
      <member refid="classcsl_1_1Prod_1ae6bb0fe561daa5930fb62e2dc0fc9c50" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>Prod</name></member>
      <member refid="classcsl_1_1Prod_1aadee4caca89f50c6ed7ad9dce7c69003" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>Prod</name></member>
      <member refid="classcsl_1_1Prod_1a77738ecfdfe91ca3ca95c95b725be576" prot="public" virt="virtual"><scope>csl::IProd</scope><name>refresh</name></member>
      <member refid="classcsl_1_1Abstract_1a8aab87c41acafaf1b1837b922495560d" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>regularLiteral</name></member>
      <member refid="classcsl_1_1Abstract_1a2fe749450d2e610199801b189dc3d0f8" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>regularLiteral</name></member>
      <member refid="classcsl_1_1Abstract_1aba5ef083016b2f3d9e6271f864b9b063" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>regularName</name></member>
      <member refid="classcsl_1_1Abstract_1a1a8421d402d5ba82257188b545e8d668" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>regularName</name></member>
      <member refid="classcsl_1_1Abstract_1a0e778c682b6cb02642b90e8ec8765441" prot="public" virt="virtual"><scope>csl::IProd</scope><name>removeDependency</name></member>
      <member refid="classcsl_1_1IProd_1a8f32fd847835d145cc8b4ff062d03c7d" prot="public" virt="virtual"><scope>csl::IProd</scope><name>replaceIndex</name></member>
      <member refid="classcsl_1_1Abstract_1a9372ddd521fa661c5d3371e0d8d4dfc3" prot="public" virt="virtual"><scope>csl::IProd</scope><name>replaceIndexInPlace</name></member>
      <member refid="classcsl_1_1IProd_1abfe07d5009e2813511d936c662ddbef3" prot="public" virt="virtual"><scope>csl::IProd</scope><name>replaceIndices</name></member>
      <member refid="classcsl_1_1Abstract_1af0d95f3edc0562b1d75d60b670119842" prot="public" virt="virtual"><scope>csl::IProd</scope><name>resetIndexStructure</name></member>
      <member refid="classcsl_1_1IProd_1a5c240d3e6eeea0de1c95ab49b2891063" prot="public" virt="virtual"><scope>csl::IProd</scope><name>rightInsert</name></member>
      <member refid="classcsl_1_1Abstract_1a5c796713828ebfb74a7d8787d7802a76" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>self</name></member>
      <member refid="classcsl_1_1IProd_1a0d8d2b4422c919a70caf945c1ea35984" prot="protected" virt="non-virtual"><scope>csl::IProd</scope><name>selfCheckIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1aa6a40ceb6eb1aa79711ca126d5bdda02" prot="public" virt="virtual"><scope>csl::IProd</scope><name>setAllDependencies</name></member>
      <member refid="classcsl_1_1IProd_1a9c6895c9d37d17614f54e3baeec96585" prot="public" virt="virtual"><scope>csl::IProd</scope><name>setArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a45c3adb7ba4e2b8442247246a3792b44" prot="public" virt="virtual" ambiguityscope="csl::Abstract::"><scope>csl::IProd</scope><name>setArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a7bb29d316b8f64652cef472a6c23f001" prot="public" virt="virtual"><scope>csl::IProd</scope><name>setCommutable</name></member>
      <member refid="classcsl_1_1Abstract_1ae35385480a1be08f5e7433535b58ac0b" prot="public" virt="virtual"><scope>csl::IProd</scope><name>setComplexProperty</name></member>
      <member refid="classcsl_1_1Abstract_1a37ebc247831d6629d44117a490fca120" prot="public" virt="virtual"><scope>csl::IProd</scope><name>setConjugated</name></member>
      <member refid="classcsl_1_1Abstract_1aa6a04bb56578e7da143b3cd8d8fb7b26" prot="public" virt="virtual"><scope>csl::IProd</scope><name>setElementary</name></member>
      <member refid="classcsl_1_1Abstract_1afa50c743b8e7e76e637e98f165ad4e5d" prot="public" virt="virtual"><scope>csl::IProd</scope><name>setEmpty</name></member>
      <member refid="classcsl_1_1Abstract_1ac318016372d14b795893fe7e59199084" prot="public" virt="virtual"><scope>csl::IProd</scope><name>setFullyAntiSymmetric</name></member>
      <member refid="classcsl_1_1Abstract_1a4f90ebb7cf7c26782bd36bc2a67fc5d4" prot="public" virt="virtual"><scope>csl::IProd</scope><name>setFullySymmetric</name></member>
      <member refid="classcsl_1_1Abstract_1a70f946f9c59df045ef7416320ade89c7" prot="public" virt="virtual"><scope>csl::IProd</scope><name>setIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1a5ecdb6ce7a2d9643da2f6161a06dfbbf" prot="public" virt="virtual"><scope>csl::IProd</scope><name>setInfBoundary</name></member>
      <member refid="classcsl_1_1Abstract_1a867135c96776248add60018f4aa7a578" prot="public" virt="virtual"><scope>csl::IProd</scope><name>setName</name></member>
      <member refid="classcsl_1_1Abstract_1a70df7be4486affa8dc891e3f25bf499f" prot="public" virt="virtual"><scope>csl::IProd</scope><name>setOperand</name></member>
      <member refid="classcsl_1_1Abstract_1ae7b8a14fc746ed72e4d5abd63373c5ba" prot="public" virt="virtual"><scope>csl::IProd</scope><name>setOperandPrivate</name></member>
      <member refid="classcsl_1_1Abstract_1a3003698af4978e774eeb2e62038f7432" prot="public" virt="virtual"><scope>csl::IProd</scope><name>setParent</name></member>
      <member refid="classcsl_1_1Abstract_1a3c175411df619e7504feb6d888fc82f1" prot="public" virt="virtual"><scope>csl::IProd</scope><name>setPoint</name></member>
      <member refid="classcsl_1_1Abstract_1aad7104a5b8855272a92a47c58f29e958" prot="public" virt="virtual"><scope>csl::IProd</scope><name>setSupBoundary</name></member>
      <member refid="classcsl_1_1Abstract_1aaf7f0692cb84ca861a5b3b641bea518b" prot="public" virt="virtual"><scope>csl::IProd</scope><name>setValue</name></member>
      <member refid="classcsl_1_1Abstract_1aa49c51bd285830e724f103e9fb61c464" prot="public" virt="virtual"><scope>csl::IProd</scope><name>setValue</name></member>
      <member refid="classcsl_1_1Abstract_1aa47ddab3aa047e86be34c70358d53548" prot="public" virt="virtual"><scope>csl::IProd</scope><name>setVariable</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1a8e6df749f2e0afdbe8ae0993235dda54" prot="public" virt="virtual"><scope>csl::IProd</scope><name>setVectorArgument</name></member>
      <member refid="classcsl_1_1AbstractMultiFunc_1a773f619ff0c678e3d1e8e34559a00d50" prot="public" virt="virtual"><scope>csl::IProd</scope><name>size</name></member>
      <member refid="classcsl_1_1Prod_1a3b491384c2717ae8b618d91dd8db39f1" prot="public" virt="virtual"><scope>csl::IProd</scope><name>suppressExponent</name></member>
      <member refid="classcsl_1_1IProd_1aca4461b782859509b8a9a1deb3846bc3" prot="public" virt="virtual"><scope>csl::IProd</scope><name>suppressTerm</name></member>
      <member refid="classcsl_1_1Abstract_1a4faf1ffd8cb3b6c721e128980c0303d8" prot="public" virt="virtual"><scope>csl::IProd</scope><name>symmetrise</name></member>
      <member refid="classcsl_1_1Abstract_1a7b83c6a13716688f45b02e6291d39aba" prot="public" virt="virtual"><scope>csl::IProd</scope><name>tensordot</name></member>
      <member refid="classcsl_1_1Abstract_1aee4fa41a5e014f067395467542ee8831" prot="public" virt="non-virtual"><scope>csl::IProd</scope><name>testDummy</name></member>
      <member refid="classcsl_1_1Abstract_1a9a86d21f5c5f65eb7e524a8f8002c0e7" prot="public" virt="virtual"><scope>csl::IProd</scope><name>trace</name></member>
      <member refid="classcsl_1_1Abstract_1aacab43e551e9259a39a79378373ce49c" prot="public" virt="virtual"><scope>csl::IProd</scope><name>trace</name></member>
      <member refid="classcsl_1_1Abstract_1a1e97712696e5c40b28bc1e35987fea94" prot="public" virt="virtual"><scope>csl::IProd</scope><name>transpose</name></member>
      <member refid="classcsl_1_1Abstract_1a40bdc4c76fdbbf3cbac3af4dce8286ed" prot="public" virt="virtual"><scope>csl::IProd</scope><name>~Abstract</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
