<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.12.0" xml:lang="en-US">
  <compounddef id="classcsl_1_1AbstractDuoFunc" kind="class" language="C++" prot="public">
    <compoundname>csl::AbstractDuoFunc</compoundname>
    <basecompoundref refid="classcsl_1_1Abstract" prot="public" virt="non-virtual">csl::Abstract</basecompoundref>
    <derivedcompoundref refid="classcsl_1_1Operator" prot="public" virt="non-virtual">csl::Operator&lt; AbstractDuoFunc &gt;</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1Angle" prot="public" virt="non-virtual">csl::Angle</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1Commutator" prot="public" virt="non-virtual">csl::Commutator</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1Pow" prot="public" virt="non-virtual">csl::Pow</derivedcompoundref>
    <derivedcompoundref refid="classmty_1_1FermionPropStruct" prot="public" virt="non-virtual">mty::FermionPropStruct</derivedcompoundref>
    <includes refid="scalarFunc_8h" local="no">scalarFunc.h</includes>
    <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="classcsl_1_1AbstractDuoFunc_1aa3958b228b6f0ba7b0761abf42a4608e" prot="protected" static="no" mutable="no">
        <type>std::array&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref>, 2 &gt;</type>
        <definition>std::array&lt;Expr, 2&gt; csl::AbstractDuoFunc::argument</definition>
        <argsstring></argsstring>
        <name>argument</name>
        <qualifiedname>csl::AbstractDuoFunc::argument</qualifiedname>
        <briefdescription>
<para>std::array containing the arguments. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="196" column="9" bodyfile="src/csl/scalarFunc.h" bodystart="196" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1a1c4814f068da0301ed0f0088739f3c99" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>csl::AbstractDuoFunc::AbstractDuoFunc</definition>
        <argsstring>()</argsstring>
        <name>AbstractDuoFunc</name>
        <qualifiedname>csl::AbstractDuoFunc::AbstractDuoFunc</qualifiedname>
        <briefdescription>
<para>Default Constructor, initializes the std::array argument empty. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="201" column="5" bodyfile="src/csl/scalarFunc.h" bodystart="507" bodyend="511"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1afc5b6550543ba68b2a8f7d7708d120ce" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>csl::AbstractDuoFunc::AbstractDuoFunc</definition>
        <argsstring>(const Expr &amp;left, const Expr &amp;right)</argsstring>
        <name>AbstractDuoFunc</name>
        <qualifiedname>csl::AbstractDuoFunc::AbstractDuoFunc</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="203" column="5" bodyfile="src/csl/scalarFunc.h" bodystart="513" bodyend="518"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1a96910b875bda50dd7111e0f03477e36d" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type><ref refid="namespacecsl_1ace591865c69b6315c533a1a325777312" kindref="member">csl::Type</ref></type>
        <definition>csl::Type csl::AbstractDuoFunc::getType</definition>
        <argsstring>() const override</argsstring>
        <name>getType</name>
        <qualifiedname>csl::AbstractDuoFunc::getType</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aa781456c3f801b37ce169c83514c51c1">getType</reimplements>
        <reimplementedby refid="classcsl_1_1Angle_1a2a0a138a9196c8c5f195a822f7a8a982">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Commutator_1adac744ad959f7f67f5274f6725efd2b6">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Derivative_1afede83f7ca9724579f293d4289857d00">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integral_1af4eedf08f912f9fbb576a01778eecaea">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1a8d7c1cdb87061dd7aa472ed9fe344a8b">getType</reimplementedby>
        <briefdescription>
<para>Gives the <bold>type</bold> of <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>In the program this function is very often called. It allows different functions to know what type of expr they are manipulating (cos, product, number, etc) in order to do special treatments or simplifications. <simplesect kind="return"><para>type (a non memorized integer corresponding to the type of abstract) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="205" column="15" bodyfile="src/csl/scalarFunc.h" bodystart="205" bodyend="208"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1abafb2415e1952440db4b16c6138d6313" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type><ref refid="namespacecsl_1a70046459ec0082db8cb97005c13c9a54" kindref="member">csl::PrimaryType</ref></type>
        <definition>csl::PrimaryType csl::AbstractDuoFunc::getPrimaryType</definition>
        <argsstring>() const override</argsstring>
        <name>getPrimaryType</name>
        <qualifiedname>csl::AbstractDuoFunc::getPrimaryType</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a8ab79682cdff4c7d7b52c2e70ac23d85">getPrimaryType</reimplements>
        <briefdescription>
<para>Gives the <bold>primary type</bold> of an <ref refid="classcsl_1_1AbstractDuoFunc" kindref="compound">AbstractDuoFunc</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>10 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="212" column="22" bodyfile="src/csl/scalarFunc.h" bodystart="212" bodyend="215"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1a032adea087db90b6ed2c222942fdebd6" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::AbstractDuoFunc::getCommutable</definition>
        <argsstring>() const override</argsstring>
        <name>getCommutable</name>
        <qualifiedname>csl::AbstractDuoFunc::getCommutable</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a2263731ca94825f35281e69fb258cf87">getCommutable</reimplements>
        <reimplementedby refid="classcsl_1_1Operator_1aa26c6f1e6a43ab0d529c170466e810b0">getCommutable</reimplementedby>
        <briefdescription>
<para>Tells if the <ref refid="classcsl_1_1AbstractDuoFunc" kindref="compound">AbstractDuoFunc</ref> is commutable. </para>
        </briefdescription>
        <detaileddescription>
<para>The commutability of a multi-function depends on the one of its <bold>arguments</bold> and the properties of the multi-function itself. <simplesect kind="return"><para><bold>True</bold> if the <ref refid="classcsl_1_1AbstractFunc" kindref="compound">AbstractFunc</ref> is commutable. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="223" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="351" bodyend="354"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1ad855f9c5253c25f631c6646e3d28ae4b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::vector&lt; <ref refid="classcsl_1_1Parent" kindref="compound">csl::Parent</ref> &gt;</type>
        <definition>std::vector&lt; csl::Parent &gt; csl::AbstractDuoFunc::getSubSymbols</definition>
        <argsstring>() const override</argsstring>
        <name>getSubSymbols</name>
        <qualifiedname>csl::AbstractDuoFunc::getSubSymbols</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a4e69280b624b0e0c932f1cfa7417b55f">getSubSymbols</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="225" column="17" bodyfile="src/csl/scalarFunc.cpp" bodystart="356" bodyend="364"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1a3c528c48d0b95db2e506f1d6959c5e67" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::AbstractDuoFunc::isIndexed</definition>
        <argsstring>() const override</argsstring>
        <name>isIndexed</name>
        <qualifiedname>csl::AbstractDuoFunc::isIndexed</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a216b7bd3930fbf047e5bf8f69e9b964c">isIndexed</reimplements>
        <reimplementedby refid="classmty_1_1FermionPropStruct_1a87eedca3ca384eee83372ecaef79e372">isIndexed</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><bold>True</bold> if the expression is indexed. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="227" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="366" bodyend="369"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1a7b6c806179b294bbbcd606cb9257fd99" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1IndexStructure" kindref="compound">IndexStructure</ref></type>
        <definition>IndexStructure csl::AbstractDuoFunc::getIndexStructure</definition>
        <argsstring>() const override</argsstring>
        <name>getIndexStructure</name>
        <qualifiedname>csl::AbstractDuoFunc::getIndexStructure</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1ae125a32b6f3d0368b6055d4e58c1ff3f">getIndexStructure</reimplements>
        <reimplementedby refid="classmty_1_1FermionPropStruct_1a1c804a9b083017522ea907130f9ddda9">getIndexStructure</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The index structure of the <bold>Indicial</bold> expression </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="229" column="20" bodyfile="src/csl/scalarFunc.cpp" bodystart="371" bodyend="377"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1a1e789c914e462e7f289e56f55ef83076" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor csl::AbstractDuoFunc::getPoint</definition>
        <argsstring>() const override</argsstring>
        <name>getPoint</name>
        <qualifiedname>csl::AbstractDuoFunc::getPoint</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a06b32036fea6a2583f506a6ef9508d74">getPoint</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="231" column="12" bodyfile="src/csl/scalarFunc.cpp" bodystart="379" bodyend="383"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1a2effb7bc0153b8c4e6d3c695d3b245cb" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>int</type>
        <definition>int csl::AbstractDuoFunc::getNArgs</definition>
        <argsstring>(int axis=0) const override</argsstring>
        <name>getNArgs</name>
        <qualifiedname>csl::AbstractDuoFunc::getNArgs</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aa034448201c9e7998bbbb5e409636b30">getNArgs</reimplements>
        <param>
          <type>int</type>
          <declname>axis</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Returns the <bold>number of arguments</bold> of the <ref refid="classcsl_1_1AbstractDuoFunc" kindref="compound">AbstractDuoFunc</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><bold>nArgs</bold> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="236" column="9" bodyfile="src/csl/scalarFunc.cpp" bodystart="346" bodyend="349"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1a0c134489522dacd21756e7faaafed79c" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>size_t</type>
        <definition>size_t csl::AbstractDuoFunc::size</definition>
        <argsstring>() const override</argsstring>
        <name>size</name>
        <qualifiedname>csl::AbstractDuoFunc::size</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a3794843945b8a39e2c1be073c9bacdf5">size</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="238" column="12" bodyfile="src/csl/scalarFunc.h" bodystart="238" bodyend="241"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1a6db2c19ea96bee60189534d583fc2af3" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
        <definition>Expr const  &amp; csl::AbstractDuoFunc::getArgument</definition>
        <argsstring>(int iArg=0) const override</argsstring>
        <name>getArgument</name>
        <qualifiedname>csl::AbstractDuoFunc::getArgument</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1ac33a42309d629d47bfdbede4e152414e">getArgument</reimplements>
        <param>
          <type>int</type>
          <declname>iArg</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Returns one particular <bold>argument</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iArg(default=0)</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> of the argument to return in the std::array <bold>argument</bold>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>argument</bold>[iArg] </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="248" column="16" bodyfile="src/csl/scalarFunc.cpp" bodystart="385" bodyend="388"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1abd56e93ef0544827fa7931f68b8edd06" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
        <definition>Expr &amp; csl::AbstractDuoFunc::getArgument</definition>
        <argsstring>(int iArg=0) override</argsstring>
        <name>getArgument</name>
        <qualifiedname>csl::AbstractDuoFunc::getArgument</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a06f542034e95744148f4fce5a4893e63">getArgument</reimplements>
        <param>
          <type>int</type>
          <declname>iArg</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="250" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="390" bodyend="393"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1a86ac8ca4a6eed274d004d989f3a65f3d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::AbstractDuoFunc::findSubExpression</definition>
        <argsstring>(Expr_info subExpression, const Expr &amp;newExpression) const override</argsstring>
        <name>findSubExpression</name>
        <qualifiedname>csl::AbstractDuoFunc::findSubExpression</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a299b1fd6c2b9d80ad90a08c7acef28d2">findSubExpression</reimplements>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>subExpression</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>newExpression</declname>
        </param>
        <briefdescription>
<para>Searches a sub-expression and replaces it. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>subExpression</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to search. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>newExpression</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression that replaces <bold>subExpression</bold> if it is found. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The expression with the replacement done. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="253" column="5" bodyfile="src/csl/scalarFunc.cpp" bodystart="396" bodyend="413"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1ab9ed03e7424e97a17464fb76e14bb213" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::AbstractDuoFunc::setArgument</definition>
        <argsstring>(const Expr &amp;t_argument, int iArg=0) override</argsstring>
        <name>setArgument</name>
        <qualifiedname>csl::AbstractDuoFunc::setArgument</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aab2d2ac186b56d17d2cc0a105e145b11">setArgument</reimplements>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>t_argument</declname>
        </param>
        <param>
          <type>int</type>
          <declname>iArg</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Replaces one particular <bold>argument</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t_argument</parametername>
</parameternamelist>
<parameterdescription>
<para>New argument. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>iArg(default=0)</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> of the argument to replace with t_argument. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="260" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="415" bodyend="418"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1afcc87b9f871955a482fa7c435c5ab68c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::AbstractDuoFunc::isReal</definition>
        <argsstring>() const override</argsstring>
        <name>isReal</name>
        <qualifiedname>csl::AbstractDuoFunc::isReal</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1ac73aba0c48a4b5740f7bfa09e438ca99">isReal</reimplements>
        <reimplementedby refid="classcsl_1_1Pow_1a06954004fdc62d399847915ced3431c2">isReal</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="262" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="420" bodyend="423"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1ab71346e18c63f56e01526b34783d34cc" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::AbstractDuoFunc::isPurelyImaginary</definition>
        <argsstring>() const override</argsstring>
        <name>isPurelyImaginary</name>
        <qualifiedname>csl::AbstractDuoFunc::isPurelyImaginary</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1acb67e8e96735b8f116d0e7ab33d7be77">isPurelyImaginary</reimplements>
        <reimplementedby refid="classcsl_1_1Pow_1a217c3b0f93aa2cbb24bca5a70dbe7384">isPurelyImaginary</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="264" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="425" bodyend="428"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1abccb4ba9f313edd3a3939c317afbc14e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>std::optional&lt; Expr &gt; csl::AbstractDuoFunc::getRealPart</definition>
        <argsstring>() const override</argsstring>
        <name>getRealPart</name>
        <qualifiedname>csl::AbstractDuoFunc::getRealPart</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a415f64fdddaae445014d5e052956f889">getRealPart</reimplements>
        <briefdescription>
<para><bold>Evaluates</bold> the <bold>real part</bold> of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> and returns it. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The real part of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="266" column="19" bodyfile="src/csl/scalarFunc.cpp" bodystart="430" bodyend="433"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1a484a42c8d029d02f2def2df2bf24c7c0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::AbstractDuoFunc::getImaginaryPart</definition>
        <argsstring>() const override</argsstring>
        <name>getImaginaryPart</name>
        <qualifiedname>csl::AbstractDuoFunc::getImaginaryPart</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a43f44bbb3685fc9f4a0402223b2e1004">getImaginaryPart</reimplements>
        <briefdescription>
<para><bold>Evaluates</bold> the <bold>imaginary part</bold> of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> and returns it. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The imaginary part of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="268" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="435" bodyend="438"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1ab8d3db6601adde22f9cfcaa5b046bcbe" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>std::optional&lt; Expr &gt; csl::AbstractDuoFunc::getComplexModulus</definition>
        <argsstring>() const override</argsstring>
        <name>getComplexModulus</name>
        <qualifiedname>csl::AbstractDuoFunc::getComplexModulus</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a859f792aec52ba1fe1181f81d1cc3451">getComplexModulus</reimplements>
        <briefdescription>
<para><bold>Evaluates</bold> the <bold>modulus in the complex plane</bold> of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> and returns it. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The modulus part of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="270" column="19" bodyfile="src/csl/scalarFunc.cpp" bodystart="440" bodyend="444"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1a14a9ddd387b869c129c48dfaea5974ad" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>std::optional&lt; Expr &gt; csl::AbstractDuoFunc::getComplexArgument</definition>
        <argsstring>() const override</argsstring>
        <name>getComplexArgument</name>
        <qualifiedname>csl::AbstractDuoFunc::getComplexArgument</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a9cc64c66894acafc1f069dc40072084b">getComplexArgument</reimplements>
        <briefdescription>
<para><bold>Evaluates</bold> the <bold>argument in the complex plane</bold> of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> and returns it. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The argument part of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="272" column="19" bodyfile="src/csl/scalarFunc.cpp" bodystart="446" bodyend="449"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1a04866fe8e757f391e79d6aaa18885221" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::AbstractDuoFunc::getComplexConjugate</definition>
        <argsstring>() const override</argsstring>
        <name>getComplexConjugate</name>
        <qualifiedname>csl::AbstractDuoFunc::getComplexConjugate</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a03e8bdba20c6192a948892f212f09dbe">getComplexConjugate</reimplements>
        <briefdescription>
<para>Calculates and returns the complex conjugate of the expression. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>\bar{*this}. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="274" column="19" bodyfile="src/csl/scalarFunc.cpp" bodystart="451" bodyend="462"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1aeaa65642df3b0311a2f0056335011ab9" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::AbstractDuoFunc::replaceIndex</definition>
        <argsstring>(const Index &amp;indexToReplace, const Index &amp;newIndex, bool refresh=true) const override</argsstring>
        <name>replaceIndex</name>
        <qualifiedname>csl::AbstractDuoFunc::replaceIndex</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1acc0eb077e25c9a67d15269cf8d5f0511">replaceIndex</reimplements>
        <reimplementedby refid="classmty_1_1FermionPropStruct_1ad2f7566f463b5a34fa80ccf66bf08650">replaceIndex</reimplementedby>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>indexToReplace</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>newIndex</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>refresh</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>For indicial expressions, this function searches <bold>indexToContract</bold> and replaces it with newIndex. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>indexToContract</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> that is newly contracted. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>newIndex</parametername>
</parameternamelist>
<parameterdescription>
<para>Dummy new index that replaces <bold>indexToContract</bold> in the expression. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if the index has been found. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="276" column="27" bodyfile="src/csl/scalarFunc.cpp" bodystart="464" bodyend="481"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1aa0da071b14916bfbe1b12a388346e415" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>std::optional&lt; Expr &gt; csl::AbstractDuoFunc::replaceIndices</definition>
        <argsstring>(std::vector&lt; csl::Index &gt; const &amp;oldIndices, std::vector&lt; csl::Index &gt; const &amp;newIndices, bool refresh=true, bool flipped=false) const override</argsstring>
        <name>replaceIndices</name>
        <qualifiedname>csl::AbstractDuoFunc::replaceIndices</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1ac9e54a236015d14af42b0bcde41953f3">replaceIndices</reimplements>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref> &gt; const &amp;</type>
          <declname>oldIndices</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref> &gt; const &amp;</type>
          <declname>newIndices</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>refresh</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>flipped</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="282" column="5" bodyfile="src/csl/scalarFunc.cpp" bodystart="484" bodyend="502"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1a0a9110ce4150f135902865efdd99c130" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::AbstractDuoFunc::factor</definition>
        <argsstring>(bool full=false) const override</argsstring>
        <name>factor</name>
        <qualifiedname>csl::AbstractDuoFunc::factor</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a0bc0de9c4ce5f77fc716af0f502d13d3">factor</reimplements>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para><bold>Factors</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>This function tries to factor the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> wrt any <bold>factor</bold>. This will be more involved in calculation than the other factorizing function that takes the factor as a parameter. So this function <bold>must be used only</bold> if we don&apos;t know the factors we want at the end. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>full</parametername>
</parameternamelist>
<parameterdescription>
<para>If true the factorization is <bold>recursive</bold> through all the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="287" column="27" bodyfile="src/csl/scalarFunc.cpp" bodystart="504" bodyend="518"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1a8bfd43c575fadc19e46948953af5f2a5" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::AbstractDuoFunc::factor</definition>
        <argsstring>(Expr_info expr, bool full=false) const override</argsstring>
        <name>factor</name>
        <qualifiedname>csl::AbstractDuoFunc::factor</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a8fb3d657c65606d520688db6401fe650">factor</reimplements>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>factor</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para><bold>Factors</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> wrt a <bold>particular</bold> <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>factor</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> wrt which we try to factor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>full</parametername>
</parameternamelist>
<parameterdescription>
<para>If true the factorization is <bold>recursive</bold> through all the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="289" column="27" bodyfile="src/csl/scalarFunc.cpp" bodystart="520" bodyend="534"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1ac4f47febdbe3b773bce05b39d506e452" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::AbstractDuoFunc::collect</definition>
        <argsstring>(std::vector&lt; Expr &gt; const &amp;factors, bool full=false) const override</argsstring>
        <name>collect</name>
        <qualifiedname>csl::AbstractDuoFunc::collect</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1ab3746f1d3667846824ea51b8a2e00d31">collect</reimplements>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; const &amp;</type>
          <declname>factors</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Collects terms in sum according to some factors given by the user. </para>
        </briefdescription>
        <detaileddescription>
<para>This function allows the factor with some specific scalar variables. For example, <formula id="6">$ ax + ay + by $</formula> can be factored in two ways. Either with <formula id="7">$ (a, b) $</formula> which gives <formula id="8">$ a(x+y) + by $</formula> ; or with <formula id="9">$ (x, y) $</formula> which gives <formula id="10">$ ax + (a+b)y $</formula>. With the collect function it is possible to choose precisely the set of variables that will be factored to express results in a standard way.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>factors</parametername>
</parameternamelist>
<parameterdescription>
<para>Factors to search in the expression. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>full</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean (default = false) that tells if the collection must be recursive (full expression depth).</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The collected expression if modifications have been done. </para>
</simplesect>
<simplesect kind="return"><para>std::nullopt else.</para>
</simplesect>
<simplesect kind="note"><para>This function will probably replace the <ref refid="classcsl_1_1AbstractDuoFunc_1a0a9110ce4150f135902865efdd99c130" kindref="member">factor()</ref> function in the future.</para>
</simplesect>
<simplesect kind="note"><para>For now, the collect function does not support factorization by indicial tensors, whereas <ref refid="classcsl_1_1AbstractDuoFunc_1a0a9110ce4150f135902865efdd99c130" kindref="member">factor()</ref> does. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="292" column="27" bodyfile="src/csl/scalarFunc.cpp" bodystart="536" bodyend="551"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1a5dbc9bf69fbe0beb1034b21f83ba6aba" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::AbstractDuoFunc::expand</definition>
        <argsstring>(bool full=false, bool inPlace=false) const override</argsstring>
        <name>expand</name>
        <qualifiedname>csl::AbstractDuoFunc::expand</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a3a87ab082152fea4fc2444659028b840">expand</reimplements>
        <reimplementedby refid="classcsl_1_1Operator_1a7e4ec8aa653557544dd3063af72d816f">expand</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1ad5d18f22f9eed16868b1e8e14a0797c3">expand</reimplementedby>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>inPlace</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para><bold>Develops</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>This function concerns only products (and exponents) that will be flatten to give at the end a sum of independant terms.<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>full</parametername>
</parameternamelist>
<parameterdescription>
<para>If true the expandment is <bold>recursive</bold> through all the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The expand <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="295" column="27" bodyfile="src/csl/scalarFunc.cpp" bodystart="553" bodyend="567"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1adda5dcff671af0afed2ce13d81b1a903" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::AbstractDuoFunc::expand_if</definition>
        <argsstring>(std::function&lt; bool(Expr const &amp;)&gt; const &amp;f, bool full=false, bool inPlace=false) const override</argsstring>
        <name>expand_if</name>
        <qualifiedname>csl::AbstractDuoFunc::expand_if</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aeb48aaaa856582b6359037fe94d2419b">expand_if</reimplements>
        <reimplementedby refid="classcsl_1_1Operator_1a453d864df2f26dcedca00592cc49ea55">expand_if</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1a9b2bb69232d43c764369d8859662ecda">expand_if</reimplementedby>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>inPlace</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para><bold>Develops</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>This function concerns only products (and exponents) that will be flatten to give at the end a sum of independant terms.<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Functions that returns a boolean that determines which arguments must be expanded in products.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>full</parametername>
</parameternamelist>
<parameterdescription>
<para>If true the expandment is <bold>recursive</bold> through all the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The expand <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="306" column="5" bodyfile="src/csl/scalarFunc.cpp" bodystart="569" bodyend="584"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1a423dcc1eccb833f88b3f98caa52189a9" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::AbstractDuoFunc::dependsOn</definition>
        <argsstring>(Expr_info expr) const override</argsstring>
        <name>dependsOn</name>
        <qualifiedname>csl::AbstractDuoFunc::dependsOn</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a40fe2ccf376dadd21b2d7a0f134d86c6">dependsOn</reimplements>
        <reimplementedby refid="classcsl_1_1Integral_1ae3d145e84f749ba49f57d59a277742c5">dependsOn</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Check recursively if the expression depends on <bold>expr</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to search. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if a dependency in <bold>expr</bold> is found. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="310" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="586" bodyend="590"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1a460268d704974e083a355e66126e35e1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::AbstractDuoFunc::dependsOn</definition>
        <argsstring>(Parent_info parent) const override</argsstring>
        <name>dependsOn</name>
        <qualifiedname>csl::AbstractDuoFunc::dependsOn</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a9d7d8586a0df66ba8da33528d6400e66">dependsOn</reimplements>
        <param>
          <type><ref refid="classcsl_1_1AbstractParent" kindref="compound">Parent_info</ref></type>
          <declname>parent</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="312" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1a6642c1edceccda7928bbd70256446428" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::AbstractDuoFunc::dependsExplicitlyOn</definition>
        <argsstring>(Expr_info expr) const override</argsstring>
        <name>dependsExplicitlyOn</name>
        <qualifiedname>csl::AbstractDuoFunc::dependsExplicitlyOn</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1ac3c9887977249e4d71ea36c6377b3581">dependsExplicitlyOn</reimplements>
        <reimplementedby refid="classcsl_1_1Integral_1a467c09b5b03f5e5a6ee28410ded0d09f">dependsExplicitlyOn</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Check recursively if <bold>expr</bold> is present in the expression. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to search. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if <bold>expr</bold> is found. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="314" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="597" bodyend="601"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1afb8fc18946f96492b94896ab680e2dd1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::AbstractDuoFunc::dependsExplicitlyOn</definition>
        <argsstring>(Parent_info expr) const override</argsstring>
        <name>dependsExplicitlyOn</name>
        <qualifiedname>csl::AbstractDuoFunc::dependsExplicitlyOn</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a0b26ad7a44e497af296318287bac539a">dependsExplicitlyOn</reimplements>
        <param>
          <type><ref refid="classcsl_1_1AbstractParent" kindref="compound">Parent_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="316" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="603" bodyend="607"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1ac84821d717ca9ab1aed295b644fe8cae" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::AbstractDuoFunc::commutesWith</definition>
        <argsstring>(Expr_info expr, int sign=-1) const override</argsstring>
        <name>commutesWith</name>
        <qualifiedname>csl::AbstractDuoFunc::commutesWith</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a3f68d0cd93dfe2ac02d6d4afc80fb41a">commutesWith</reimplements>
        <reimplementedby refid="classcsl_1_1Operator_1adc9dd8a7ee3c9092e6d94d88d3e9f9fe">commutesWith</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>sign</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Tells if the object commutes with expr. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if <bold>*this</bold> commutes with <bold>expr</bold>. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="318" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="609" bodyend="613"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1a424f5c3e08f3548d1be123b599eaac2f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>int</type>
        <definition>int csl::AbstractDuoFunc::isPolynomial</definition>
        <argsstring>(Expr_info expr) const override</argsstring>
        <name>isPolynomial</name>
        <qualifiedname>csl::AbstractDuoFunc::isPolynomial</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1acae10d5685ccec295fbd9be7996073cb">isPolynomial</reimplements>
        <reimplementedby refid="classcsl_1_1Pow_1a52d9ee469cf861e08a58588ce3edf1c4">isPolynomial</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Determines if the expression is a mononomial term in <bold>expr</bold>, i.e. a term of the form C*expr^n with C independent of expr, n integer. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Variable" kindref="compound">Variable</ref> of the supposed mononomial. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The order of the exponent if there is one (n in the example). </para>
</simplesect>
<simplesect kind="return"><para>-1 else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="320" column="9" bodyfile="src/csl/scalarFunc.cpp" bodystart="615" bodyend="618"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1aaa1bbff7462d592af2ad699c02296107" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
        <definition>Expr const  &amp; csl::AbstractDuoFunc::operator[]</definition>
        <argsstring>(int i) const override</argsstring>
        <name>operator[]</name>
        <qualifiedname>csl::AbstractDuoFunc::operator[]</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aa8331053065d1be2da89e70c45d24863">operator[]</reimplements>
        <param>
          <type>int</type>
          <declname>iArg</declname>
        </param>
        <briefdescription>
<para>Access operator for multi-argument expressions, equivalent to the function <ref refid="classcsl_1_1AbstractDuoFunc_1a6db2c19ea96bee60189534d583fc2af3" kindref="member">getArgument()</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iArg</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> of the argument to get. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>argument</bold>[iArg]. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="322" column="16" bodyfile="src/csl/scalarFunc.cpp" bodystart="620" bodyend="623"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1a485adbc87cb3b4739eb468cfd09e7b31" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
        <definition>Expr &amp; csl::AbstractDuoFunc::operator[]</definition>
        <argsstring>(int i) override</argsstring>
        <name>operator[]</name>
        <qualifiedname>csl::AbstractDuoFunc::operator[]</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a560aa9993d506551c54a8c02d1445814">operator[]</reimplements>
        <param>
          <type>int</type>
          <declname>iArg</declname>
        </param>
        <briefdescription>
<para>Access operator for multi-argument expressions, returns a reference so this function is not const. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iArg</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> of the argument to get. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A reference to <bold>argument</bold>[iArg]. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="324" column="10" bodyfile="src/csl/scalarFunc.cpp" bodystart="625" bodyend="628"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1AbstractDuoFunc_1a2d20154a943a0a723791d0a6223382fa" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::AbstractDuoFunc::operator&lt;</definition>
        <argsstring>(Expr_info other) const override</argsstring>
        <name>operator&lt;</name>
        <qualifiedname>csl::AbstractDuoFunc::operator&lt;</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a5c1ba8dce7fbc19eb98807bd15a279c9">operator&lt;</reimplements>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Compares the simplicity of the expression to another. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para><bold>Expression</bold> to compare. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>False</bold> if <bold>expr</bold> is simpler or equivalent. </para>
</simplesect>
<simplesect kind="return"><para><bold>True</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/scalarFunc.h" line="326" column="5" bodyfile="src/csl/simplification.cpp" bodystart="642" bodyend="680"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>Handle functions of <bold>multiple</bold> arguments. In the case of the call of a simplification function, if recursive, the function will be first applied on all the <bold>arguments</bold>, then to the function itself. </para>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <inheritancegraph>
      <node id="2">
        <label>csl::Abstract</label>
        <link refid="classcsl_1_1Abstract"/>
      </node>
      <node id="1">
        <label>csl::AbstractDuoFunc</label>
        <link refid="classcsl_1_1AbstractDuoFunc"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="6">
        <label>csl::Angle</label>
        <link refid="classcsl_1_1Angle"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="7">
        <label>csl::Commutator</label>
        <link refid="classcsl_1_1Commutator"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="4">
        <label>csl::Derivative</label>
        <link refid="classcsl_1_1Derivative"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
      <node id="5">
        <label>csl::Integral</label>
        <link refid="classcsl_1_1Integral"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
      <node id="3">
        <label>csl::Operator&lt; AbstractDuoFunc &gt;</label>
        <link refid="classcsl_1_1Operator"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="8">
        <label>csl::Pow</label>
        <link refid="classcsl_1_1Pow"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="9">
        <label>mty::FermionPropStruct</label>
        <link refid="classmty_1_1FermionPropStruct"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="2">
        <label>csl::Abstract</label>
        <link refid="classcsl_1_1Abstract"/>
      </node>
      <node id="1">
        <label>csl::AbstractDuoFunc</label>
        <link refid="classcsl_1_1AbstractDuoFunc"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
    </collaborationgraph>
    <location file="src/csl/scalarFunc.h" line="192" column="1" bodyfile="src/csl/scalarFunc.h" bodystart="192" bodyend="327"/>
    <listofallmembers>
      <member refid="classcsl_1_1Abstract_1ad5fee68c1f3dcbda0e936926fed17616" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>Abstract</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1a1c4814f068da0301ed0f0088739f3c99" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>AbstractDuoFunc</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1afc5b6550543ba68b2a8f7d7708d120ce" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>AbstractDuoFunc</name></member>
      <member refid="classcsl_1_1Abstract_1a5549ac0c186b3c6febf332245a25a82c" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>addAntiSymmetry</name></member>
      <member refid="classcsl_1_1Abstract_1abbab11282e5c6ac46b018642ff129f47" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>addDependency</name></member>
      <member refid="classcsl_1_1Abstract_1a101219973341a39cf15f07e5e1aa388f" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>addition_own</name></member>
      <member refid="classcsl_1_1Abstract_1ad431770faa4291116a50175193a11a88" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>addSymmetry</name></member>
      <member refid="classcsl_1_1Abstract_1acd972aed8326d4c13534594e061ee6da" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>antisymmetrise</name></member>
      <member refid="classcsl_1_1Abstract_1a61d3ab932182226f4670a62bbb22af4e" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>applyDiracDelta</name></member>
      <member refid="classcsl_1_1Abstract_1a316956fea77627a716500a2bbfc1f3b7" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>applyOperator</name></member>
      <member refid="classcsl_1_1Abstract_1a6305ce90c795bfb416d8e958c62f905c" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>applySelfStructureOn</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1aa3958b228b6f0ba7b0761abf42a4608e" prot="protected" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>argument</name></member>
      <member refid="classcsl_1_1Abstract_1a27ad666bf7d533607da9675b0c645ee9" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>askTerm</name></member>
      <member refid="classcsl_1_1Abstract_1aad54ed41b2ce9bad3364fe30ad1a0d71" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>begin</name></member>
      <member refid="classcsl_1_1Abstract_1adff373df9477d4e38581d09cc6d2fee4" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>begin</name></member>
      <member refid="classcsl_1_1Abstract_1aa4cba37520821432f37e212fefbc2534" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>breakSpace</name></member>
      <member refid="classcsl_1_1Abstract_1af0f40b77914e45f56bf87839d00211d7" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>breakSpace</name></member>
      <member refid="classcsl_1_1Abstract_1afd9d0336808e8adf4ccdccb51587ed8c" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>checkIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1a1ebd84082bb93418408cc0babe2dffe2" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>checkIndexStructure</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1ac4f47febdbe3b773bce05b39d506e452" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>collect</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1ac84821d717ca9ab1aed295b644fe8cae" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>commutesWith</name></member>
      <member refid="classcsl_1_1Abstract_1a7caee12abb451168149779a668dfc59e" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>compareWithDummy</name></member>
      <member refid="classcsl_1_1Abstract_1a0f16fda9fe72a89c61ece36101a11d95" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>compareWithDummy</name></member>
      <member refid="classcsl_1_1Abstract_1aed79d20a0821205e6430c80a474117d3" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>contractIndex</name></member>
      <member refid="classcsl_1_1Abstract_1ad874fc858295a737e6ce884530f1109b" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>contraction</name></member>
      <member refid="classcsl_1_1Abstract_1abd35096982e92b669ea55d960c5f44be" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>contraction</name></member>
      <member refid="classcsl_1_1Abstract_1af29c2898c5d3ba96de8018a0838c402c" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>copy</name></member>
      <member refid="classcsl_1_1Abstract_1aaa996819710adc3b7529c74a628be623" prot="public" virt="pure-virtual"><scope>csl::AbstractDuoFunc</scope><name>copy_unique</name></member>
      <member refid="classcsl_1_1Abstract_1a09648782dcf2e81abb5b864f476cc410" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>deepCopy</name></member>
      <member refid="classcsl_1_1Abstract_1a10358c33402ed520dc5888b25bb26af3" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>deepRefresh</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1a6642c1edceccda7928bbd70256446428" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>dependsExplicitlyOn</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1afb8fc18946f96492b94896ab680e2dd1" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>dependsExplicitlyOn</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1a423dcc1eccb833f88b3f98caa52189a9" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>dependsOn</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1a460268d704974e083a355e66126e35e1" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>dependsOn</name></member>
      <member refid="classcsl_1_1Abstract_1aecab8c872023a2d0771e7e4f83bb05f8" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>derive</name></member>
      <member refid="classcsl_1_1Abstract_1aeb08811cf370616477a92075e4a218ee" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>determinant</name></member>
      <member refid="classcsl_1_1Abstract_1a1578c74aee1050b806a67e7a81a67f5c" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>division_own</name></member>
      <member refid="classcsl_1_1Abstract_1a4cc7a46deaa3eaa7593909d74e76d4af" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>dot</name></member>
      <member refid="classcsl_1_1Abstract_1a0c3c3fe5010f24e8a8765ea06415c003" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>empty</name></member>
      <member refid="classcsl_1_1Abstract_1a61e4e80d998a888a1a74d9ea3e10c0f1" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>end</name></member>
      <member refid="classcsl_1_1Abstract_1ae2761d54f13310e13f5076d565edd7ef" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>end</name></member>
      <member refid="classcsl_1_1Abstract_1aa3a4cb7f30e2a422fe27a513e03d6600" prot="public" virt="pure-virtual"><scope>csl::AbstractDuoFunc</scope><name>evaluate</name></member>
      <member refid="classcsl_1_1Abstract_1a543d5a4f0432e166b492ad28a860a65f" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>evaluateScalar</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1a5dbc9bf69fbe0beb1034b21f83ba6aba" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>expand</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1adda5dcff671af0afed2ce13d81b1a903" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>expand_if</name></member>
      <member refid="classcsl_1_1Abstract_1aa2696a0feb43766ef54e1e3dd3d6d134" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>exponentiation_own</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1a0a9110ce4150f135902865efdd99c130" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>factor</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1a8bfd43c575fadc19e46948953af5f2a5" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>factor</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1a86ac8ca4a6eed274d004d989f3a65f3d" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>findSubExpression</name></member>
      <member refid="classcsl_1_1Abstract_1a021946e84d8c1a019908cac578b16fe8" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getAllDependencies</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1a6db2c19ea96bee60189534d583fc2af3" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getArgument</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1abd56e93ef0544827fa7931f68b8edd06" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a898d6cf2a7f348feacab189447bee1eb" prot="public" virt="virtual" ambiguityscope="csl::Abstract::"><scope>csl::AbstractDuoFunc</scope><name>getArgument</name></member>
      <member refid="classcsl_1_1Abstract_1aa689fb64eecb86edbde6c745d1ce756b" prot="public" virt="virtual" ambiguityscope="csl::Abstract::"><scope>csl::AbstractDuoFunc</scope><name>getArgument</name></member>
      <member refid="classcsl_1_1Abstract_1afeb26e1382411448ce3c65d50fefd8bb" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getCanonicalPermutation</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1a032adea087db90b6ed2c222942fdebd6" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getCommutable</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1a14a9ddd387b869c129c48dfaea5974ad" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getComplexArgument</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1a04866fe8e757f391e79d6aaa18885221" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getComplexConjugate</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1ab8d3db6601adde22f9cfcaa5b046bcbe" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getComplexModulus</name></member>
      <member refid="classcsl_1_1Abstract_1a470d9f1267fba4a82e13af4a39470f81" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getComplexProperty</name></member>
      <member refid="classcsl_1_1Abstract_1af04c0e4426f0bf9df365afe0148d59df" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getContractedPair</name></member>
      <member refid="classcsl_1_1Abstract_1aec707d949f0f98e08ab4642c93dd9eb5" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getContractionProperties</name></member>
      <member refid="classcsl_1_1Abstract_1aa22f0e4c9c91f43b5cd61cbb873869eb" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getDeltaMinus</name></member>
      <member refid="classcsl_1_1Abstract_1a69a657baf1c35ed581e9db2c47a71c99" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getDeltaPlus</name></member>
      <member refid="classcsl_1_1Abstract_1a9531d78d67c82e288c0130da5b1ba80b" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getDenom</name></member>
      <member refid="classcsl_1_1Abstract_1a5856c3d55a6d1406970f3656e61efe8e" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getDim</name></member>
      <member refid="classcsl_1_1Abstract_1a77e067fc57c0c2e70d141079455fdbd7" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getElementary</name></member>
      <member refid="classcsl_1_1Abstract_1ac513c930caa9939c2b9557f36a34ee69" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getExponents</name></member>
      <member refid="classcsl_1_1Abstract_1ac34c9c6f05e692faeed2f030514787ad" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getFactors</name></member>
      <member refid="classcsl_1_1Abstract_1aa4136dc23f1fba4bf897b54c8592ccfc" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getFreeIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1aa5b707a5efdaef7c7945cbd921c3f526" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getHermitianConjugate</name></member>
      <member refid="classcsl_1_1Abstract_1aff5cca2b2c8190e59f6e34cb1e383d36" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getHermitianConjugate</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1a484a42c8d029d02f2def2df2bf24c7c0" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getImaginaryPart</name></member>
      <member refid="classcsl_1_1Abstract_1a3234ce243f6a2e11950be42f10100943" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getIndex</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1a7b6c806179b294bbbcd606cb9257fd99" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1ae6a9a9ef3efd6bb83b62c0a353742d25" prot="public" virt="non-virtual" ambiguityscope="csl::Abstract::"><scope>csl::AbstractDuoFunc</scope><name>getIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1addb848bf4cdea207484a71e9b1006ead" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getIndexStructureView</name></member>
      <member refid="classcsl_1_1Abstract_1a632e28530a68539fadacd7ab7ffc8be1" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getIndexStructureView</name></member>
      <member refid="classcsl_1_1Abstract_1a3d6b1e294cf24dea17c3c4361226138b" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getInfBoundary</name></member>
      <member refid="classcsl_1_1Abstract_1a9c4a302d1a3cbf4dd9394f5e5880d343" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getLatexName</name></member>
      <member refid="classcsl_1_1Abstract_1a652101e34b2efa43114150e9af3c79d5" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getLibDependency</name></member>
      <member refid="classcsl_1_1Abstract_1af7f5e7466e754984a2c4394a112464f7" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getName</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1a2effb7bc0153b8c4e6d3c695d3b245cb" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getNArgs</name></member>
      <member refid="classcsl_1_1Abstract_1a42125e9765a771c47819548d342b0b28" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getNContractedPairs</name></member>
      <member refid="classcsl_1_1Abstract_1a204dbd37b63432cb08932b995f49d3f4" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getNFactor</name></member>
      <member refid="classcsl_1_1Abstract_1add364193f7a78ac28f7001c7f4036453" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getNIndices</name></member>
      <member refid="classcsl_1_1Abstract_1a6aa6bcc7cb8ee1574f29dc6ab6c6f0ed" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getNum</name></member>
      <member refid="classcsl_1_1Abstract_1aad25c117c8dfc4d9718ba41e8d3f33a6" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getNumericalFactor</name></member>
      <member refid="classcsl_1_1Abstract_1a9c3ec3dfe1fbd8ead5c8d9aca421a863" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getOperand</name></member>
      <member refid="classcsl_1_1Abstract_1a9500a21d75d03c695ec0c76493600b38" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getOrder</name></member>
      <member refid="classcsl_1_1Abstract_1ae89eb7b1a9e0259a60154563f3315907" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getOrderOf</name></member>
      <member refid="classcsl_1_1Abstract_1ab150130c9f67daaf6aba52b9f6b90941" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getParent</name></member>
      <member refid="classcsl_1_1Abstract_1a15f775b5add9af8727ead2cfaab78ba2" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getParent_info</name></member>
      <member refid="classcsl_1_1Abstract_1aea8459b3206eb3a2297eeea7688e9520" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getParity</name></member>
      <member refid="classcsl_1_1Abstract_1a946d175d946da102c5f4cc91840703cb" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getPermutations</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1a1e789c914e462e7f289e56f55ef83076" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getPoint</name></member>
      <member refid="classcsl_1_1Abstract_1ade540a127da7304f2b7282f4dcaffc7f" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getPolynomialTerm</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1abafb2415e1952440db4b16c6138d6313" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getPrimaryType</name></member>
      <member refid="classcsl_1_1Abstract_1a07489d0569bc983718796d21c73f34b3" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getProduct</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1abccb4ba9f313edd3a3939c317afbc14e" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getRealPart</name></member>
      <member refid="classcsl_1_1Abstract_1a5b77f008f4b95030641224877004f06c" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getRegularExpression</name></member>
      <member refid="classcsl_1_1Abstract_1a625efe55a17b97a1c0f085bdbf3a962a" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getShape</name></member>
      <member refid="classcsl_1_1Abstract_1aa83df1d9dc202457113e5b38bd694fae" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getSign</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1ad855f9c5253c25f631c6646e3d28ae4b" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getSubSymbols</name></member>
      <member refid="classcsl_1_1Abstract_1a7dcdc11b64c8c515933882168d0792ef" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1a413c50b2663f57d38c1d3ec3cfeaa3ce" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1a26a0854bca4c47e84a1da36a3de8c49f" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1a29261a946b3398b6129237620754a8b9" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1a8a067b70756c4eef758aa88076a95162" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1aeaf8154e39ff211b12e6382e675ccaad" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getSum</name></member>
      <member refid="classcsl_1_1Abstract_1a2fcc223dbf5d880e923c07df142df5c8" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getSupBoundary</name></member>
      <member refid="classcsl_1_1Abstract_1a1d36e7a5acc50766d5cd3f6d59df978d" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getTerm</name></member>
      <member refid="classcsl_1_1Abstract_1a404c5e89a3aad8a8dabcb56d4120c0fe" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getTransposed</name></member>
      <member refid="classcsl_1_1Abstract_1aca3debb143668fd3ab75a27a47dd0c13" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getTransposed</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1a96910b875bda50dd7111e0f03477e36d" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getType</name></member>
      <member refid="classcsl_1_1Abstract_1a78f98ba06476e464e3fd2fce0d1f8243" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getValue</name></member>
      <member refid="classcsl_1_1Abstract_1a628563238145f3a9acc331f1a89ce32f" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getValued</name></member>
      <member refid="classcsl_1_1Abstract_1ae85f810bbadbc792210c958e8f1b2ffb" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getVariable</name></member>
      <member refid="classcsl_1_1Abstract_1ac83c44ae1e5315a38083bdb7acd8f3fa" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getVectorArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a0188b049736016c970a2513ed9f6931f" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>getVectorialModulus</name></member>
      <member refid="classcsl_1_1Abstract_1a94bf1455397fdd2df8dbbc3b41c2f3f4" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>hasChainContractionProperty</name></member>
      <member refid="classcsl_1_1Abstract_1aa31e08c251d96b8ea8ec8d385895c1ff" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>hasContractionProperty</name></member>
      <member refid="classcsl_1_1Abstract_1a8c42723e8bc6334c99f00898cc1d59d7" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>hermitian</name></member>
      <member refid="classcsl_1_1Abstract_1a5437e7f685edf8549e6d3b34572343f8" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>insert</name></member>
      <member refid="classcsl_1_1Abstract_1a1b68943aa7ecf60a63af0f2f368eef8f" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>inverseMatrix</name></member>
      <member refid="classcsl_1_1Abstract_1a9347e75b0cd0b75e0f0a38db93b29d83" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>isAnOperator</name></member>
      <member refid="classcsl_1_1Abstract_1ac09992d147b39388c8936b3bff648930" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>isArbitrary</name></member>
      <member refid="classcsl_1_1Abstract_1ad74c068f1da78856321932b6b6ae17dc" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>isBuildingBlock</name></member>
      <member refid="classcsl_1_1Abstract_1a22a594845a29429c9b4f19c92bd18cad" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>isComplexConjugate</name></member>
      <member refid="classcsl_1_1Abstract_1a464f4f0613db9b4b0a4efe26a3a03d60" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>isEmpty</name></member>
      <member refid="classcsl_1_1Abstract_1af2ce38838e35c5785f92373a1d830668" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>isHermitianConjugate</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1a3c528c48d0b95db2e506f1d6959c5e67" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>isIndexed</name></member>
      <member refid="classcsl_1_1Abstract_1a9a014bfd266b5f8471f23580e271979b" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>isInteger</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1a424f5c3e08f3548d1be123b599eaac2f" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>isPolynomial</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1ab71346e18c63f56e01526b34783d34cc" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>isPurelyImaginary</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1afcc87b9f871955a482fa7c435c5ab68c" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>isReal</name></member>
      <member refid="classcsl_1_1Abstract_1ab79c1d8df9e6b1a3eca66958f7dc489d" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>matchShape</name></member>
      <member refid="classcsl_1_1Abstract_1ac3978c71035bf1cda50f5b9031d631af" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>memoryOverhead</name></member>
      <member refid="classcsl_1_1Abstract_1a4f5ed458ba62f5b4cf61a9e1f8568af1" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>multiplication_own</name></member>
      <member refid="classcsl_1_1Abstract_1af5b62a6308638064c42da80e9cc2cb7e" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1af4fd1b57df371dac7ccfd5a909620e49" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1a96de5935a58a96d4c5b1e47966488923" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1ac99a619abde7e4c58f39e14d4d20fcf5" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1a45206de7c7773b3cb150451ee3eb379e" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1a0d3495220202bd417c1b58249c923f39" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1a2d20154a943a0a723791d0a6223382fa" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>operator&lt;</name></member>
      <member refid="classcsl_1_1Abstract_1a6e19587260a07dba65cf2a985e05516b" prot="public" virt="non-virtual" ambiguityscope="csl::Abstract::"><scope>csl::AbstractDuoFunc</scope><name>operator&lt;</name></member>
      <member refid="classcsl_1_1Abstract_1a2a1660498f2638f5e490d6e512eb32f4" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>operator&lt;=</name></member>
      <member refid="classcsl_1_1Abstract_1afbcac6df2fd7ac11f336189cf215124b" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>operator&lt;=</name></member>
      <member refid="classcsl_1_1Abstract_1a59ff2950fc8ca319f87a730450f14545" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>operator=</name></member>
      <member refid="classcsl_1_1Abstract_1a8334e14cd5789168b037d3888ed60edd" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a12d929e34039e817e464abc560bd4a9d" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a3775f3088e784cc924cb7d26e118660e" prot="public" virt="pure-virtual"><scope>csl::AbstractDuoFunc</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a1f78f0cce24c93def3050743bc5f2845" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1aed43debcac4a19e0da44986774c522bc" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a2376f08c0aa5ffe783090381d102d3ae" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a485c6f3e10db539a70416cd0766b117d" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>operator&gt;</name></member>
      <member refid="classcsl_1_1Abstract_1ab305bdf49212f03781e7f98024faeb66" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>operator&gt;</name></member>
      <member refid="classcsl_1_1Abstract_1a4c8883df19d7538b68fa96aadac9dfa9" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>operator&gt;=</name></member>
      <member refid="classcsl_1_1Abstract_1a6b931f7b159d57bad26ca9c9ea729aa1" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>operator&gt;=</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1aaa1bbff7462d592af2ad699c02296107" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>operator[]</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1a485adbc87cb3b4739eb468cfd09e7b31" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>operator[]</name></member>
      <member refid="classcsl_1_1Abstract_1a75d9abfa88d9d09a89d3a4becd9e6429" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>operatorAppliesOn</name></member>
      <member refid="classcsl_1_1Abstract_1abe9aceabbc0a99642e84c9025dbdc767" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>permut</name></member>
      <member refid="classcsl_1_1Abstract_1aed56cb85894209a9bbc9b8bdada5e6ab" prot="public" virt="pure-virtual"><scope>csl::AbstractDuoFunc</scope><name>print</name></member>
      <member refid="classcsl_1_1Abstract_1a2910dd30d90915c11d48c01cab618dda" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>printCode</name></member>
      <member refid="classcsl_1_1Abstract_1a89e45ffc7b65f92e77e592f76f70934c" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>printExplicit</name></member>
      <member refid="classcsl_1_1Abstract_1aa067d4a97135bfe2052a7e21c28f75be" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>printLaTeX</name></member>
      <member refid="classcsl_1_1Abstract_1a0645745feacf93470963b55f93cae1c0" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>printProp</name></member>
      <member refid="classcsl_1_1Abstract_1aaeab3809e91989adbdf29c3f56d905b6" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>refresh</name></member>
      <member refid="classcsl_1_1Abstract_1a8aab87c41acafaf1b1837b922495560d" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>regularLiteral</name></member>
      <member refid="classcsl_1_1Abstract_1a2fe749450d2e610199801b189dc3d0f8" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>regularLiteral</name></member>
      <member refid="classcsl_1_1Abstract_1aba5ef083016b2f3d9e6271f864b9b063" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>regularName</name></member>
      <member refid="classcsl_1_1Abstract_1a1a8421d402d5ba82257188b545e8d668" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>regularName</name></member>
      <member refid="classcsl_1_1Abstract_1a0e778c682b6cb02642b90e8ec8765441" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>removeDependency</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1aeaa65642df3b0311a2f0056335011ab9" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>replaceIndex</name></member>
      <member refid="classcsl_1_1Abstract_1a9372ddd521fa661c5d3371e0d8d4dfc3" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>replaceIndexInPlace</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1aa0da071b14916bfbe1b12a388346e415" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>replaceIndices</name></member>
      <member refid="classcsl_1_1Abstract_1af0d95f3edc0562b1d75d60b670119842" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>resetIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1a5c796713828ebfb74a7d8787d7802a76" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>self</name></member>
      <member refid="classcsl_1_1Abstract_1aa6a40ceb6eb1aa79711ca126d5bdda02" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>setAllDependencies</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1ab9ed03e7424e97a17464fb76e14bb213" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>setArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a45c3adb7ba4e2b8442247246a3792b44" prot="public" virt="virtual" ambiguityscope="csl::Abstract::"><scope>csl::AbstractDuoFunc</scope><name>setArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a7bb29d316b8f64652cef472a6c23f001" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>setCommutable</name></member>
      <member refid="classcsl_1_1Abstract_1ae35385480a1be08f5e7433535b58ac0b" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>setComplexProperty</name></member>
      <member refid="classcsl_1_1Abstract_1a37ebc247831d6629d44117a490fca120" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>setConjugated</name></member>
      <member refid="classcsl_1_1Abstract_1aa6a04bb56578e7da143b3cd8d8fb7b26" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>setElementary</name></member>
      <member refid="classcsl_1_1Abstract_1afa50c743b8e7e76e637e98f165ad4e5d" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>setEmpty</name></member>
      <member refid="classcsl_1_1Abstract_1ac318016372d14b795893fe7e59199084" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>setFullyAntiSymmetric</name></member>
      <member refid="classcsl_1_1Abstract_1a4f90ebb7cf7c26782bd36bc2a67fc5d4" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>setFullySymmetric</name></member>
      <member refid="classcsl_1_1Abstract_1a70f946f9c59df045ef7416320ade89c7" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>setIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1a5ecdb6ce7a2d9643da2f6161a06dfbbf" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>setInfBoundary</name></member>
      <member refid="classcsl_1_1Abstract_1a867135c96776248add60018f4aa7a578" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>setName</name></member>
      <member refid="classcsl_1_1Abstract_1a70df7be4486affa8dc891e3f25bf499f" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>setOperand</name></member>
      <member refid="classcsl_1_1Abstract_1ae7b8a14fc746ed72e4d5abd63373c5ba" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>setOperandPrivate</name></member>
      <member refid="classcsl_1_1Abstract_1a3003698af4978e774eeb2e62038f7432" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>setParent</name></member>
      <member refid="classcsl_1_1Abstract_1a3c175411df619e7504feb6d888fc82f1" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>setPoint</name></member>
      <member refid="classcsl_1_1Abstract_1aad7104a5b8855272a92a47c58f29e958" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>setSupBoundary</name></member>
      <member refid="classcsl_1_1Abstract_1aaf7f0692cb84ca861a5b3b641bea518b" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>setValue</name></member>
      <member refid="classcsl_1_1Abstract_1aa49c51bd285830e724f103e9fb61c464" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>setValue</name></member>
      <member refid="classcsl_1_1Abstract_1aa47ddab3aa047e86be34c70358d53548" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>setVariable</name></member>
      <member refid="classcsl_1_1Abstract_1a83fee8ed28079bcac107455d58be9d5d" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>setVectorArgument</name></member>
      <member refid="classcsl_1_1AbstractDuoFunc_1a0c134489522dacd21756e7faaafed79c" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>size</name></member>
      <member refid="classcsl_1_1Abstract_1a4eeedaeaa39e75facf1060dce7c57a8f" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>suppressExponent</name></member>
      <member refid="classcsl_1_1Abstract_1a43520e1d6d5fdad9b50f77c6e027f928" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>suppressTerm</name></member>
      <member refid="classcsl_1_1Abstract_1a4faf1ffd8cb3b6c721e128980c0303d8" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>symmetrise</name></member>
      <member refid="classcsl_1_1Abstract_1a7b83c6a13716688f45b02e6291d39aba" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>tensordot</name></member>
      <member refid="classcsl_1_1Abstract_1aee4fa41a5e014f067395467542ee8831" prot="public" virt="non-virtual"><scope>csl::AbstractDuoFunc</scope><name>testDummy</name></member>
      <member refid="classcsl_1_1Abstract_1a9a86d21f5c5f65eb7e524a8f8002c0e7" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>trace</name></member>
      <member refid="classcsl_1_1Abstract_1aacab43e551e9259a39a79378373ce49c" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>trace</name></member>
      <member refid="classcsl_1_1Abstract_1a1e97712696e5c40b28bc1e35987fea94" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>transpose</name></member>
      <member refid="classcsl_1_1Abstract_1a40bdc4c76fdbbf3cbac3af4dce8286ed" prot="public" virt="virtual"><scope>csl::AbstractDuoFunc</scope><name>~Abstract</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
