<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.12.0" xml:lang="en-US">
  <compounddef id="classcsl_1_1TDerivativeElement" kind="class" language="C++" prot="public">
    <compoundname>csl::TDerivativeElement</compoundname>
    <basecompoundref refid="classcsl_1_1Operator" prot="public" virt="non-virtual">csl::Operator&lt; TensorFieldElement &gt;</basecompoundref>
    <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="classcsl_1_1TDerivativeElement_1a8b0aa4e09e715ae2e41b7092cd63a72b" prot="protected" static="no" mutable="no">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::TDerivativeElement::operand</definition>
        <argsstring></argsstring>
        <name>operand</name>
        <qualifiedname>csl::TDerivativeElement::operand</qualifiedname>
        <initializer>= CSL_1</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="267" column="10" bodyfile="src/csl/tensorField.h" bodystart="267" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1a7add9201b4d926c39f45e5181737d1f6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>csl::TDerivativeElement::TDerivativeElement</definition>
        <argsstring>(const Tensor &amp;t_vector, const Parent &amp;t_parent, const Index &amp;index)</argsstring>
        <name>TDerivativeElement</name>
        <qualifiedname>csl::TDerivativeElement::TDerivativeElement</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>t_vector</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref> &amp;</type>
          <declname>t_parent</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="271" column="5" bodyfile="src/csl/tensorField.cpp" bodystart="209" bodyend="216"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1aa67378895bb919e0d1c17fba1746927e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>csl::TDerivativeElement::TDerivativeElement</definition>
        <argsstring>(const Tensor &amp;t_vector, const Parent &amp;t_parent, const Index &amp;index, const Expr &amp;operand, bool empty)</argsstring>
        <name>TDerivativeElement</name>
        <qualifiedname>csl::TDerivativeElement::TDerivativeElement</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>t_vector</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref> &amp;</type>
          <declname>t_parent</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>index</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>operand</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>empty</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="275" column="5" bodyfile="src/csl/tensorField.cpp" bodystart="218" bodyend="228"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1a66539851b420ad3dc18e6602d259f46d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>csl::TDerivativeElement::~TDerivativeElement</definition>
        <argsstring>()</argsstring>
        <name>~TDerivativeElement</name>
        <qualifiedname>csl::TDerivativeElement::~TDerivativeElement</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="283" column="5" bodyfile="src/csl/tensorField.h" bodystart="283" bodyend="283"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1a16ff4a3a49daf68786abbe407d1d5b8c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="namespacecsl_1ace591865c69b6315c533a1a325777312" kindref="member">csl::Type</ref></type>
        <definition>csl::Type csl::TDerivativeElement::getType</definition>
        <argsstring>() const override</argsstring>
        <name>getType</name>
        <qualifiedname>csl::TDerivativeElement::getType</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aa781456c3f801b37ce169c83514c51c1">getType</reimplements>
        <briefdescription>
<para>Gives the <bold>type</bold> of <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>In the program this function is very often called. It allows different functions to know what type of expr they are manipulating (cos, product, number, etc) in order to do special treatments or simplifications. <simplesect kind="return"><para>type (a non memorized integer corresponding to the type of abstract) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="285" column="15" bodyfile="src/csl/tensorField.cpp" bodystart="230" bodyend="233"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1a877666789a952f0dbf0e37bd91383108" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>size_t</type>
        <definition>size_t csl::TDerivativeElement::size</definition>
        <argsstring>() const override</argsstring>
        <name>size</name>
        <qualifiedname>csl::TDerivativeElement::size</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a3794843945b8a39e2c1be073c9bacdf5">size</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="287" column="12" bodyfile="src/csl/tensorField.cpp" bodystart="235" bodyend="238"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1a0d83fa5e3869c4e375e4d5d3f0ae8757" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::TDerivativeElement::print</definition>
        <argsstring>(int mode=0, std::ostream &amp;out=std::cout, LibraryMode libMode=LibraryMode::NoLib) const override</argsstring>
        <name>print</name>
        <qualifiedname>csl::TDerivativeElement::print</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aed56cb85894209a9bbc9b8bdada5e6ab">print</reimplements>
        <param>
          <type>int</type>
          <declname>mode</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
          <defval>std::cout</defval>
        </param>
        <param>
          <type>LibraryMode</type>
          <declname>libMode</declname>
          <defval>LibraryMode::NoLib</defval>
        </param>
        <briefdescription>
<para>Displays the abstract in standard output. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>Tells if the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> is printed alone (default) or in another expr. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="289" column="10" bodyfile="src/csl/tensorField.cpp" bodystart="240" bodyend="251"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1abc07f74c7642f18855bea42cbed1eef5" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::TDerivativeElement::printCode</definition>
        <argsstring>(int mode=0, std::ostream &amp;out=std::cout) const override</argsstring>
        <name>printCode</name>
        <qualifiedname>csl::TDerivativeElement::printCode</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a2910dd30d90915c11d48c01cab618dda">printCode</reimplements>
        <param>
          <type>int</type>
          <declname>mode</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
          <defval>std::cout</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="293" column="10" bodyfile="src/csl/tensorField.cpp" bodystart="253" bodyend="273"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1aa3b01cb3bd1dcef5901cc82ec29c66b3" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::string</type>
        <definition>string csl::TDerivativeElement::printLaTeX</definition>
        <argsstring>(int mode=0) const override</argsstring>
        <name>printLaTeX</name>
        <qualifiedname>csl::TDerivativeElement::printLaTeX</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aa067d4a97135bfe2052a7e21c28f75be">printLaTeX</reimplements>
        <param>
          <type>int</type>
          <declname>mode</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Creates a LaTeX output for the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>Tells if the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> is printed alone (default) or in another expr. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The string corresponding to the LaTeX output. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="298" column="17" bodyfile="src/csl/tensorField.cpp" bodystart="275" bodyend="289"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1a2073cd345694641addf40b7af57aeac8" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::vector&lt; <ref refid="classcsl_1_1Parent" kindref="compound">csl::Parent</ref> &gt;</type>
        <definition>std::vector&lt; csl::Parent &gt; csl::TDerivativeElement::getSubSymbols</definition>
        <argsstring>() const override</argsstring>
        <name>getSubSymbols</name>
        <qualifiedname>csl::TDerivativeElement::getSubSymbols</qualifiedname>
        <reimplements refid="classcsl_1_1AbstractElement_1a680ab53340473533609d65060d8457b8">getSubSymbols</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="300" column="17" bodyfile="src/csl/tensorField.cpp" bodystart="291" bodyend="299"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1a984d8c40c787a0d7350aa0de1969c65f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::TDerivativeElement::factor</definition>
        <argsstring>(bool full=false) const override</argsstring>
        <name>factor</name>
        <qualifiedname>csl::TDerivativeElement::factor</qualifiedname>
        <reimplements refid="classcsl_1_1AbstractBuildingBlock_1a2f12cede626ece5382c9869d32c32146">factor</reimplements>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para><bold>Factors</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>This function tries to factor the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> wrt any <bold>factor</bold>. This will be more involved in calculation than the other factorizing function that takes the factor as a parameter. So this function <bold>must be used only</bold> if we don&apos;t know the factors we want at the end. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>full</parametername>
</parameternamelist>
<parameterdescription>
<para>If true the factorization is <bold>recursive</bold> through all the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="302" column="19" bodyfile="src/csl/tensorField.cpp" bodystart="301" bodyend="312"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1afff58e758180748e03f566e9ac83e728" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::TDerivativeElement::factor</definition>
        <argsstring>(Expr_info expr, bool full=false) const override</argsstring>
        <name>factor</name>
        <qualifiedname>csl::TDerivativeElement::factor</qualifiedname>
        <reimplements refid="classcsl_1_1AbstractBuildingBlock_1a447f940bf0a08d13297fde0b50b4cb84">factor</reimplements>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>factor</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para><bold>Factors</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> wrt a <bold>particular</bold> <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>factor</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> wrt which we try to factor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>full</parametername>
</parameternamelist>
<parameterdescription>
<para>If true the factorization is <bold>recursive</bold> through all the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="304" column="19" bodyfile="src/csl/tensorField.cpp" bodystart="314" bodyend="325"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1aeec6c024c50776cf5439872586451579" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::TDerivativeElement::collect</definition>
        <argsstring>(std::vector&lt; Expr &gt; const &amp;factors, bool full=false) const override</argsstring>
        <name>collect</name>
        <qualifiedname>csl::TDerivativeElement::collect</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1ab3746f1d3667846824ea51b8a2e00d31">collect</reimplements>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; const &amp;</type>
          <declname>factors</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Collects terms in sum according to some factors given by the user. </para>
        </briefdescription>
        <detaileddescription>
<para>This function allows the factor with some specific scalar variables. For example, <formula id="6">$ ax + ay + by $</formula> can be factored in two ways. Either with <formula id="7">$ (a, b) $</formula> which gives <formula id="8">$ a(x+y) + by $</formula> ; or with <formula id="9">$ (x, y) $</formula> which gives <formula id="10">$ ax + (a+b)y $</formula>. With the collect function it is possible to choose precisely the set of variables that will be factored to express results in a standard way.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>factors</parametername>
</parameternamelist>
<parameterdescription>
<para>Factors to search in the expression. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>full</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean (default = false) that tells if the collection must be recursive (full expression depth).</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The collected expression if modifications have been done. </para>
</simplesect>
<simplesect kind="return"><para>std::nullopt else.</para>
</simplesect>
<simplesect kind="note"><para>This function will probably replace the <ref refid="classcsl_1_1TDerivativeElement_1a984d8c40c787a0d7350aa0de1969c65f" kindref="member">factor()</ref> function in the future.</para>
</simplesect>
<simplesect kind="note"><para>For now, the collect function does not support factorization by indicial tensors, whereas <ref refid="classcsl_1_1TDerivativeElement_1a984d8c40c787a0d7350aa0de1969c65f" kindref="member">factor()</ref> does. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="308" column="19" bodyfile="src/csl/tensorField.cpp" bodystart="327" bodyend="339"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1add5adbf1747cd9343c96dca5a2b7479b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::TDerivativeElement::expand</definition>
        <argsstring>(bool full=false, bool inPlace=false) const override</argsstring>
        <name>expand</name>
        <qualifiedname>csl::TDerivativeElement::expand</qualifiedname>
        <reimplements refid="classcsl_1_1Operator_1a7e4ec8aa653557544dd3063af72d816f">expand</reimplements>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>inPlace</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para><bold>Develops</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>This function concerns only products (and exponents) that will be flatten to give at the end a sum of independant terms.<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>full</parametername>
</parameternamelist>
<parameterdescription>
<para>If true the expandment is <bold>recursive</bold> through all the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The expand <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="313" column="19" bodyfile="src/csl/tensorField.cpp" bodystart="340" bodyend="373"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1a1fee5554d976f77bf0e2dd5a451890b7" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::TDerivativeElement::expand_if</definition>
        <argsstring>(std::function&lt; bool(Expr const &amp;)&gt; const &amp;f, bool full=false, bool inPlace=false) const override</argsstring>
        <name>expand_if</name>
        <qualifiedname>csl::TDerivativeElement::expand_if</qualifiedname>
        <reimplements refid="classcsl_1_1Operator_1a453d864df2f26dcedca00592cc49ea55">expand_if</reimplements>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>inPlace</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para><bold>Develops</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>This function concerns only products (and exponents) that will be flatten to give at the end a sum of independant terms.<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Functions that returns a boolean that determines which arguments must be expanded in products.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>full</parametername>
</parameternamelist>
<parameterdescription>
<para>If true the expandment is <bold>recursive</bold> through all the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The expand <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="316" column="19" bodyfile="src/csl/tensorField.cpp" bodystart="375" bodyend="410"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1a36e27ebf0e0c82941829b8ed015a26fc" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>unique_Expr</type>
        <definition>unique_Expr csl::TDerivativeElement::copy_unique</definition>
        <argsstring>() const override</argsstring>
        <name>copy_unique</name>
        <qualifiedname>csl::TDerivativeElement::copy_unique</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aaa996819710adc3b7529c74a628be623">copy_unique</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="321" column="17" bodyfile="src/csl/tensorField.cpp" bodystart="412" bodyend="420"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1a85eae07c84149a410984807125d6f556" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::TDerivativeElement::deepCopy</definition>
        <argsstring>() const override</argsstring>
        <name>deepCopy</name>
        <qualifiedname>csl::TDerivativeElement::deepCopy</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a09648782dcf2e81abb5b864f476cc410">deepCopy</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="323" column="10" bodyfile="src/csl/tensorField.cpp" bodystart="422" bodyend="426"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1acb67e501bd671dd0f0d8bfde9379d51b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::TDerivativeElement::refresh</definition>
        <argsstring>() const override</argsstring>
        <name>refresh</name>
        <qualifiedname>csl::TDerivativeElement::refresh</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aaeab3809e91989adbdf29c3f56d905b6">refresh</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="325" column="10" bodyfile="src/csl/tensorField.cpp" bodystart="428" bodyend="434"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1a9d93b947a2e4f55e14ba514cdbd3d4d8" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::TDerivativeElement::deepRefresh</definition>
        <argsstring>() const override</argsstring>
        <name>deepRefresh</name>
        <qualifiedname>csl::TDerivativeElement::deepRefresh</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a10358c33402ed520dc5888b25bb26af3">deepRefresh</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="327" column="10" bodyfile="src/csl/tensorField.cpp" bodystart="436" bodyend="443"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1adf338110c2e609411e6e82120c3c5013" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::TDerivativeElement::operatorAppliesOn</definition>
        <argsstring>(Expr_info expr) const override</argsstring>
        <name>operatorAppliesOn</name>
        <qualifiedname>csl::TDerivativeElement::operatorAppliesOn</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a75d9abfa88d9d09a89d3a4becd9e6429">operatorAppliesOn</reimplements>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="329" column="10" bodyfile="src/csl/tensorField.cpp" bodystart="445" bodyend="450"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1a618856543c22406e8c7eed5b8a5a9c65" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::TDerivativeElement::dependsOn</definition>
        <argsstring>(Expr_info expr) const override</argsstring>
        <name>dependsOn</name>
        <qualifiedname>csl::TDerivativeElement::dependsOn</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a40fe2ccf376dadd21b2d7a0f134d86c6">dependsOn</reimplements>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Check recursively if the expression depends on <bold>expr</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to search. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if a dependency in <bold>expr</bold> is found. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="331" column="10" bodyfile="src/csl/tensorField.cpp" bodystart="788" bodyend="791"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1af1249fbc711db9da848ef8f80ce9a9bd" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::TDerivativeElement::dependsOn</definition>
        <argsstring>(Parent_info t_parent) const override</argsstring>
        <name>dependsOn</name>
        <qualifiedname>csl::TDerivativeElement::dependsOn</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a9d7d8586a0df66ba8da33528d6400e66">dependsOn</reimplements>
        <param>
          <type><ref refid="classcsl_1_1AbstractParent" kindref="compound">Parent_info</ref></type>
          <declname>t_parent</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="333" column="10" bodyfile="src/csl/tensorField.cpp" bodystart="793" bodyend="797"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1af76375171fcd6824d8410030fb2d5c28" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::TDerivativeElement::dependsExplicitlyOn</definition>
        <argsstring>(Expr_info expr) const override</argsstring>
        <name>dependsExplicitlyOn</name>
        <qualifiedname>csl::TDerivativeElement::dependsExplicitlyOn</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1ac3c9887977249e4d71ea36c6377b3581">dependsExplicitlyOn</reimplements>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Check recursively if <bold>expr</bold> is present in the expression. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to search. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if <bold>expr</bold> is found. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="335" column="10" bodyfile="src/csl/tensorField.cpp" bodystart="799" bodyend="803"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1a254af52dc9947ef7fa1625ea9c9f77ef" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::TDerivativeElement::dependsExplicitlyOn</definition>
        <argsstring>(Parent_info expr) const override</argsstring>
        <name>dependsExplicitlyOn</name>
        <qualifiedname>csl::TDerivativeElement::dependsExplicitlyOn</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a0b26ad7a44e497af296318287bac539a">dependsExplicitlyOn</reimplements>
        <param>
          <type><ref refid="classcsl_1_1AbstractParent" kindref="compound">Parent_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="337" column="10" bodyfile="src/csl/tensorField.cpp" bodystart="805" bodyend="809"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1a3f571d26e241f9a943e11191c3ebe9a6" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
        <definition>Expr const  &amp; csl::TDerivativeElement::getArgument</definition>
        <argsstring>(int i) const override</argsstring>
        <name>getArgument</name>
        <qualifiedname>csl::TDerivativeElement::getArgument</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1ac33a42309d629d47bfdbede4e152414e">getArgument</reimplements>
        <param>
          <type>int</type>
          <declname>iArg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="warning"><para>This function must not be called for building blocks, one must check first that the expression has arguments. </para>
</simplesect>
<simplesect kind="return"><para>The i^{th} argument of the expression. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="339" column="16" bodyfile="src/csl/tensorField.cpp" bodystart="452" bodyend="459"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1af2b7c69a2465d6c4c302c97a275d44a8" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
        <definition>Expr &amp; csl::TDerivativeElement::getArgument</definition>
        <argsstring>(int i) override</argsstring>
        <name>getArgument</name>
        <qualifiedname>csl::TDerivativeElement::getArgument</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a06f542034e95744148f4fce5a4893e63">getArgument</reimplements>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="341" column="10" bodyfile="src/csl/tensorField.cpp" bodystart="461" bodyend="468"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1adce6c89ecb493c05627b42f036e49b5b" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::TDerivativeElement::setArgument</definition>
        <argsstring>(Expr const &amp;arg, int i) override</argsstring>
        <name>setArgument</name>
        <qualifiedname>csl::TDerivativeElement::setArgument</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aab2d2ac186b56d17d2cc0a105e145b11">setArgument</reimplements>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>iArg</declname>
        </param>
        <briefdescription>
<para>Sets the argument at position <bold>iArg</bold> (default=0). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression that replaces the argument. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>iArg</parametername>
</parameternamelist>
<parameterdescription>
<para>the position of the argument to change. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="343" column="10" bodyfile="src/csl/tensorField.cpp" bodystart="470" bodyend="477"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1aba17709ddc3ea5ae260a6b713a032355" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::TDerivativeElement::getOperand</definition>
        <argsstring>() const override</argsstring>
        <name>getOperand</name>
        <qualifiedname>csl::TDerivativeElement::getOperand</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a9c3ec3dfe1fbd8ead5c8d9aca421a863">getOperand</reimplements>
        <briefdescription>
<para>Returns the operand of an <ref refid="classcsl_1_1Operator" kindref="compound">Operator</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><bold>operand</bold> of an <ref refid="classcsl_1_1Operator" kindref="compound">Operator</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="345" column="10" bodyfile="src/csl/tensorField.cpp" bodystart="479" bodyend="482"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1ab78ef96e45ffe45a9fd18b315ad73db9" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::TDerivativeElement::setOperand</definition>
        <argsstring>(const Expr &amp;t_operand) override</argsstring>
        <name>setOperand</name>
        <qualifiedname>csl::TDerivativeElement::setOperand</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a70df7be4486affa8dc891e3f25bf499f">setOperand</reimplements>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>operand</declname>
        </param>
        <briefdescription>
<para>Sets the operand of an operator. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>operand</parametername>
</parameternamelist>
<parameterdescription>
<para>New operand. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="347" column="10" bodyfile="src/csl/tensorField.cpp" bodystart="484" bodyend="488"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1a9c002e3c12a2d4f959795431d28b4099" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::TDerivativeElement::setPoint</definition>
        <argsstring>(const Tensor &amp;newPoint) override</argsstring>
        <name>setPoint</name>
        <qualifiedname>csl::TDerivativeElement::setPoint</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a3c175411df619e7504feb6d888fc82f1">setPoint</reimplements>
        <param>
          <type>const <ref refid="classcsl_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>newPoint</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="349" column="10" bodyfile="src/csl/tensorField.cpp" bodystart="490" bodyend="496"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1aab730479855c747fa6baafe4c50ca8cf" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1IndexStructure" kindref="compound">IndexStructure</ref></type>
        <definition>IndexStructure csl::TDerivativeElement::getIndexStructure</definition>
        <argsstring>() const override</argsstring>
        <name>getIndexStructure</name>
        <qualifiedname>csl::TDerivativeElement::getIndexStructure</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1ae125a32b6f3d0368b6055d4e58c1ff3f">getIndexStructure</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The index structure of the <bold>Indicial</bold> expression </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="351" column="20" bodyfile="src/csl/tensorField.cpp" bodystart="811" bodyend="816"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1ae976c5be78ef54ca485001a9807d75bc" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::TDerivativeElement::setIndexStructure</definition>
        <argsstring>(const IndexStructure &amp;t_struct) override</argsstring>
        <name>setIndexStructure</name>
        <qualifiedname>csl::TDerivativeElement::setIndexStructure</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a70f946f9c59df045ef7416320ade89c7">setIndexStructure</reimplements>
        <param>
          <type>const <ref refid="classcsl_1_1IndexStructure" kindref="compound">IndexStructure</ref> &amp;</type>
          <declname>t_index</declname>
        </param>
        <briefdescription>
<para>Replaces the index structure of the object, that must be an <bold>Indicial</bold> expression. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t_index</parametername>
</parameternamelist>
<parameterdescription>
<para>A std::vector of <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> which takes the place of the structure index. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="353" column="10" bodyfile="src/csl/tensorField.cpp" bodystart="818" bodyend="831"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1a336af14506e8d3877cfc15eeb3eb9149" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::TDerivativeElement::selfCheckIndexStructure</definition>
        <argsstring>()</argsstring>
        <name>selfCheckIndexStructure</name>
        <qualifiedname>csl::TDerivativeElement::selfCheckIndexStructure</qualifiedname>
        <briefdescription>
<para>Checks for index contractions in the product. Applies Einstein&apos;s summation convention and sums automatically repeated indices. This function is called after the construction in order to leave a correct expression. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="361" column="10" bodyfile="src/csl/tensorField.cpp" bodystart="833" bodyend="850"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1a3641cf8c169a05bff45ac4882c0cb596" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::TDerivativeElement::replaceIndexInPlace</definition>
        <argsstring>(Index const &amp;oldIndex, Index const &amp;newIndex) override</argsstring>
        <name>replaceIndexInPlace</name>
        <qualifiedname>csl::TDerivativeElement::replaceIndexInPlace</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a9372ddd521fa661c5d3371e0d8d4dfc3">replaceIndexInPlace</reimplements>
        <param>
          <type><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> const &amp;</type>
          <declname>oldIndex</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> const &amp;</type>
          <declname>newIndex</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="363" column="10" bodyfile="src/csl/tensorField.cpp" bodystart="851" bodyend="856"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1ae304eceb527459e79e9cc635350b1a70" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::TDerivativeElement::replaceIndex</definition>
        <argsstring>(const Index &amp;indexToReplace, const Index &amp;newIndex, bool refresh=true) const override</argsstring>
        <name>replaceIndex</name>
        <qualifiedname>csl::TDerivativeElement::replaceIndex</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1acc0eb077e25c9a67d15269cf8d5f0511">replaceIndex</reimplements>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>indexToReplace</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>newIndex</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>refresh</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>For indicial expressions, this function searches <bold>indexToContract</bold> and replaces it with newIndex. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>indexToContract</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> that is newly contracted. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>newIndex</parametername>
</parameternamelist>
<parameterdescription>
<para>Dummy new index that replaces <bold>indexToContract</bold> in the expression. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if the index has been found. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="367" column="19" bodyfile="src/csl/tensorField.cpp" bodystart="858" bodyend="883"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1ad55b628d2e960ed410b59d5e3d58ce16" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::TDerivativeElement::replaceIndices</definition>
        <argsstring>(std::vector&lt; Index &gt; const &amp;indexToReplace, std::vector&lt; Index &gt; const &amp;newIndex, bool refresh=true, bool flipped=false) const override</argsstring>
        <name>replaceIndices</name>
        <qualifiedname>csl::TDerivativeElement::replaceIndices</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1ac9e54a236015d14af42b0bcde41953f3">replaceIndices</reimplements>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &gt; const &amp;</type>
          <declname>indexToReplace</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &gt; const &amp;</type>
          <declname>newIndex</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>refresh</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>flipped</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="372" column="19" bodyfile="src/csl/tensorField.cpp" bodystart="886" bodyend="913"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1af224ac3745a73a90fa4d6e746072c983" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>csl::vector_expr</type>
        <definition>csl::vector_expr csl::TDerivativeElement::breakSpace</definition>
        <argsstring>(const Space *brokenSpace, const std::vector&lt; const Space * &gt; &amp;newSpaces, const std::vector&lt; std::string &gt; &amp;indexNames) const override</argsstring>
        <name>breakSpace</name>
        <qualifiedname>csl::TDerivativeElement::breakSpace</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1af0f40b77914e45f56bf87839d00211d7">breakSpace</reimplements>
        <param>
          <type>const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> *</type>
          <declname>brokenSpace</declname>
        </param>
        <param>
          <type>const std::vector&lt; const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> * &gt; &amp;</type>
          <declname>newSpaces</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::string &gt; &amp;</type>
          <declname>indexNames</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="378" column="22" bodyfile="src/csl/tensorField.cpp" bodystart="532" bodyend="545"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1a1b6a2e64b07222e4d5d126d2281c4816" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::TDerivativeElement::getComplexConjugate</definition>
        <argsstring>() const override</argsstring>
        <name>getComplexConjugate</name>
        <qualifiedname>csl::TDerivativeElement::getComplexConjugate</qualifiedname>
        <reimplements refid="classcsl_1_1Complexified_1a9d3fec789b00de1625df53232da4cf30">getComplexConjugate</reimplements>
        <briefdescription>
<para>Calculates and returns the complex conjugate of the expression. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>\bar{*this}. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="384" column="19" bodyfile="src/csl/tensorField.cpp" bodystart="915" bodyend="923"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1ac28ceccb0fea566ae54b2d01b70548f5" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::TDerivativeElement::compareWithDummy</definition>
        <argsstring>(Expr_info other, std::map&lt; Index, Index &gt; &amp;constraints, bool keepAllCosntraints=false) const override</argsstring>
        <name>compareWithDummy</name>
        <qualifiedname>csl::TDerivativeElement::compareWithDummy</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a7caee12abb451168149779a668dfc59e">compareWithDummy</reimplements>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::map&lt; <ref refid="classcsl_1_1Index" kindref="compound">Index</ref>, <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &gt; &amp;</type>
          <declname>constraints</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>keepAllCosntraints</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Comparison disregarding name of dummy indices, i.e. the two expressions * are equals even if dummy indices have not the same names in *this and * expr. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to compare.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>constraints</parametername>
</parameternamelist>
<parameterdescription>
<para>List of existing constraints between indices (it is modified in the function).</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if expr == *this taking constraints into account. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="386" column="10" bodyfile="src/csl/tensorField.cpp" bodystart="498" bodyend="529"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1a380f7ce153c1b608c232e86f79bdcbd0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::TDerivativeElement::operator==</definition>
        <argsstring>(Expr_info other) const override</argsstring>
        <name>operator==</name>
        <qualifiedname>csl::TDerivativeElement::operator==</qualifiedname>
        <reimplements refid="classcsl_1_1Complexified_1a10b02cb2da960264c19926a76a859488">operator==</reimplements>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Compares</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> with another. </para>
        </briefdescription>
        <detaileddescription>
<para>Here if two Abstracts have the same name, the function will return <bold>true</bold> even if they are <bold>not</bold> <bold>mathematically</bold> <bold>equal</bold>. So beware not to name different things the same way. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> to compare. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if the two Abstracts are the same (or have the same name). </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="390" column="10" bodyfile="src/csl/tensorField.cpp" bodystart="547" bodyend="576"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1a90129cfd12b5f98644e088de0e40fd74" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::TDerivativeElement::operator&lt;</definition>
        <argsstring>(const Abstract *expr) const override</argsstring>
        <name>operator&lt;</name>
        <qualifiedname>csl::TDerivativeElement::operator&lt;</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="392" column="5" bodyfile="src/csl/simplification.cpp" bodystart="1119" bodyend="1146"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1a2e9000986cc55b7016cc56513f058f69" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
        <definition>Expr const  &amp; csl::TDerivativeElement::operator[]</definition>
        <argsstring>(int i) const override</argsstring>
        <name>operator[]</name>
        <qualifiedname>csl::TDerivativeElement::operator[]</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aa8331053065d1be2da89e70c45d24863">operator[]</reimplements>
        <param>
          <type>int</type>
          <declname>iArg</declname>
        </param>
        <briefdescription>
<para>Access operator for multi-argument expressions, equivalent to the function <ref refid="classcsl_1_1TDerivativeElement_1a3f571d26e241f9a943e11191c3ebe9a6" kindref="member">getArgument()</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iArg</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> of the argument to get. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>argument</bold>[iArg]. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="394" column="16" bodyfile="src/csl/tensorField.cpp" bodystart="578" bodyend="585"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TDerivativeElement_1aa2934b8a3734feac07dec2abc1e14e5a" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
        <definition>Expr &amp; csl::TDerivativeElement::operator[]</definition>
        <argsstring>(int i) override</argsstring>
        <name>operator[]</name>
        <qualifiedname>csl::TDerivativeElement::operator[]</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a560aa9993d506551c54a8c02d1445814">operator[]</reimplements>
        <param>
          <type>int</type>
          <declname>iArg</declname>
        </param>
        <briefdescription>
<para>Access operator for multi-argument expressions, returns a reference so this function is not const. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iArg</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> of the argument to get. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A reference to <bold>argument</bold>[iArg]. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="396" column="10" bodyfile="src/csl/tensorField.cpp" bodystart="587" bodyend="594"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="friend">
      <memberdef kind="friend" id="classcsl_1_1TDerivativeElement_1ae27d5d413aba166b5c7636b95fcb3173" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr tderivativeelement_s</definition>
        <argsstring>(const Tensor &amp;t_vector, const Parent &amp;t_parent, const Index &amp;t_index)</argsstring>
        <name>tderivativeelement_s</name>
        <qualifiedname>csl::TDerivativeElement::tderivativeelement_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>t_vector</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref> &amp;</type>
          <declname>t_parent</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>t_index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="399" column="10" bodyfile="src/csl/tensorField.h" bodystart="399" bodyend="405"/>
      </memberdef>
      <memberdef kind="friend" id="classcsl_1_1TDerivativeElement_1a63cb62b7453a1084a244221af72f97a7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr tderivativeelement_s</definition>
        <argsstring>(const Tensor &amp;t_vector, const Parent &amp;t_parent, const Index &amp;t_index, const Expr &amp;t_operand, bool t_empty)</argsstring>
        <name>tderivativeelement_s</name>
        <qualifiedname>csl::TDerivativeElement::tderivativeelement_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>t_vector</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref> &amp;</type>
          <declname>t_parent</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>t_index</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>t_operand</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>t_empty</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="408" column="10" bodyfile="src/csl/tensorField.h" bodystart="408" bodyend="416"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <inheritancegraph>
      <node id="8">
        <label>csl::Abstract</label>
        <link refid="classcsl_1_1Abstract"/>
      </node>
      <node id="7">
        <label>csl::AbstractBuildingBlock</label>
        <link refid="classcsl_1_1AbstractBuildingBlock"/>
        <childnode refid="8" relation="public-inheritance">
        </childnode>
      </node>
      <node id="5">
        <label>csl::AbstractElement</label>
        <link refid="classcsl_1_1AbstractElement"/>
        <childnode refid="6" relation="public-inheritance">
        </childnode>
      </node>
      <node id="6">
        <label>csl::Complexified</label>
        <link refid="classcsl_1_1Complexified"/>
        <childnode refid="7" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>csl::Operator&lt; TensorFieldElement &gt;</label>
        <link refid="classcsl_1_1Operator"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1">
        <label>csl::TDerivativeElement</label>
        <link refid="classcsl_1_1TDerivativeElement"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="4">
        <label>csl::TensorElement</label>
        <link refid="classcsl_1_1TensorElement"/>
        <childnode refid="5" relation="public-inheritance">
        </childnode>
      </node>
      <node id="3">
        <label>csl::TensorFieldElement</label>
        <link refid="classcsl_1_1TensorFieldElement"/>
        <childnode refid="4" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="8">
        <label>csl::Abstract</label>
        <link refid="classcsl_1_1Abstract"/>
      </node>
      <node id="7">
        <label>csl::AbstractBuildingBlock</label>
        <link refid="classcsl_1_1AbstractBuildingBlock"/>
        <childnode refid="8" relation="public-inheritance">
        </childnode>
      </node>
      <node id="5">
        <label>csl::AbstractElement</label>
        <link refid="classcsl_1_1AbstractElement"/>
        <childnode refid="6" relation="public-inheritance">
        </childnode>
        <childnode refid="9" relation="usage">
          <edgelabel>parent</edgelabel>
        </childnode>
      </node>
      <node id="6">
        <label>csl::Complexified</label>
        <link refid="classcsl_1_1Complexified"/>
        <childnode refid="7" relation="public-inheritance">
        </childnode>
      </node>
      <node id="13">
        <label>csl::Expr</label>
        <link refid="classcsl_1_1Expr"/>
        <childnode refid="14" relation="public-inheritance">
        </childnode>
      </node>
      <node id="10">
        <label>csl::IndexStructure</label>
        <link refid="classcsl_1_1IndexStructure"/>
      </node>
      <node id="2">
        <label>csl::Operator&lt; TensorFieldElement &gt;</label>
        <link refid="classcsl_1_1Operator"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1">
        <label>csl::TDerivativeElement</label>
        <link refid="classcsl_1_1TDerivativeElement"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
        <childnode refid="13" relation="usage">
          <edgelabel>operand</edgelabel>
        </childnode>
      </node>
      <node id="11">
        <label>csl::Tensor</label>
        <link refid="classcsl_1_1Tensor"/>
        <childnode refid="12" relation="public-inheritance">
        </childnode>
      </node>
      <node id="4">
        <label>csl::TensorElement</label>
        <link refid="classcsl_1_1TensorElement"/>
        <childnode refid="5" relation="public-inheritance">
        </childnode>
        <childnode refid="10" relation="usage">
          <edgelabel>index</edgelabel>
        </childnode>
      </node>
      <node id="3">
        <label>csl::TensorFieldElement</label>
        <link refid="classcsl_1_1TensorFieldElement"/>
        <childnode refid="4" relation="public-inheritance">
        </childnode>
        <childnode refid="11" relation="usage">
          <edgelabel>point</edgelabel>
        </childnode>
      </node>
      <node id="12">
        <label>std::shared_ptr&lt; TensorParent &gt;</label>
        <link refid="classstd_1_1shared__ptr"/>
      </node>
      <node id="14">
        <label>std::shared_ptr&lt; csl::Abstract &gt;</label>
        <link refid="classstd_1_1shared__ptr"/>
      </node>
      <node id="9">
        <label>std::shared_ptr&lt; csl::AbstractParent &gt;</label>
        <link refid="classstd_1_1shared__ptr"/>
      </node>
    </collaborationgraph>
    <location file="src/csl/tensorField.h" line="263" column="1" bodyfile="src/csl/tensorField.h" bodystart="263" bodyend="417"/>
    <listofallmembers>
      <member refid="classcsl_1_1Abstract_1ad5fee68c1f3dcbda0e936926fed17616" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>Abstract</name></member>
      <member refid="classcsl_1_1AbstractBuildingBlock_1a64aaa989689a7e8c262e6d9fceaff10f" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>AbstractBuildingBlock</name></member>
      <member refid="classcsl_1_1AbstractElement_1a12ebb2cd662c44ca2e60106d630dbc48" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>AbstractElement</name></member>
      <member refid="classcsl_1_1AbstractElement_1a90b37b4752b24ab6cb0a29dc3329eea4" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>AbstractElement</name></member>
      <member refid="classcsl_1_1Abstract_1a5549ac0c186b3c6febf332245a25a82c" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>addAntiSymmetry</name></member>
      <member refid="classcsl_1_1Abstract_1abbab11282e5c6ac46b018642ff129f47" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>addDependency</name></member>
      <member refid="classcsl_1_1Abstract_1a101219973341a39cf15f07e5e1aa388f" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>addition_own</name></member>
      <member refid="classcsl_1_1Abstract_1ad431770faa4291116a50175193a11a88" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>addSymmetry</name></member>
      <member refid="classcsl_1_1TensorElement_1aa2605b68051617e35fc2a443c2b38a2c" prot="protected" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>adjustMetricDeltaParent</name></member>
      <member refid="classcsl_1_1Abstract_1acd972aed8326d4c13534594e061ee6da" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>antisymmetrise</name></member>
      <member refid="classcsl_1_1TensorElement_1a02db643378663eb5f17011937c5c9557" prot="protected" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>applyBrokenIndices</name></member>
      <member refid="classcsl_1_1Complexified_1ac8174f246df45364467fffd925027808" prot="protected" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>applyComplexPropertiesOn</name></member>
      <member refid="classcsl_1_1Complexified_1a7b2b037721656af10cb29a077a567b30" prot="protected" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>applyComplexPropertiesOn</name></member>
      <member refid="classcsl_1_1Abstract_1a61d3ab932182226f4670a62bbb22af4e" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>applyDiracDelta</name></member>
      <member refid="classcsl_1_1Operator_1ae9da277be3e179944e647d54acf13eea" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>applyOperator</name></member>
      <member refid="classcsl_1_1TensorElement_1ad6f100f8c15bee5c29d97d40549a6e18" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>applyPermutation</name></member>
      <member refid="classcsl_1_1TensorElement_1afbfaf24db5ee68ab64a2378248fdf7e4" prot="protected" virt="virtual"><scope>csl::TDerivativeElement</scope><name>applySelfStructureOn</name></member>
      <member refid="classcsl_1_1TensorElement_1a6ec375934423dbb60f6d00ea13ec7f80" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>askTerm</name></member>
      <member refid="classcsl_1_1Abstract_1aad54ed41b2ce9bad3364fe30ad1a0d71" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>begin</name></member>
      <member refid="classcsl_1_1Abstract_1adff373df9477d4e38581d09cc6d2fee4" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>begin</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1af224ac3745a73a90fa4d6e746072c983" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>breakSpace</name></member>
      <member refid="classcsl_1_1Abstract_1aa4cba37520821432f37e212fefbc2534" prot="public" virt="non-virtual" ambiguityscope="csl::AbstractElement::"><scope>csl::TDerivativeElement</scope><name>breakSpace</name></member>
      <member refid="classcsl_1_1TensorElement_1ad9d1474eb8d1c53835ffb3891e01b020" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>checkIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1a1ebd84082bb93418408cc0babe2dffe2" prot="public" virt="virtual" ambiguityscope="csl::AbstractElement::"><scope>csl::TDerivativeElement</scope><name>checkIndexStructure</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1aeec6c024c50776cf5439872586451579" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>collect</name></member>
      <member refid="classcsl_1_1Operator_1adc9dd8a7ee3c9092e6d94d88d3e9f9fe" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>commutesWith</name></member>
      <member refid="classcsl_1_1TensorElement_1ad78eb0b8122b22db79ea59b4af50f7c7" prot="protected" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>comparePermutations</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1ac28ceccb0fea566ae54b2d01b70548f5" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>compareWithDummy</name></member>
      <member refid="classcsl_1_1Abstract_1a0f16fda9fe72a89c61ece36101a11d95" prot="public" virt="non-virtual" ambiguityscope="csl::AbstractElement::"><scope>csl::TDerivativeElement</scope><name>compareWithDummy</name></member>
      <member refid="classcsl_1_1Complexified_1a6333b0f548411b1712301806c21c2261" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>Complexified</name></member>
      <member refid="classcsl_1_1Complexified_1a785754f2eac5813fcf8aa87cc0b456bf" prot="protected" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>conjugated</name></member>
      <member refid="classcsl_1_1Abstract_1aed79d20a0821205e6430c80a474117d3" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>contractIndex</name></member>
      <member refid="classcsl_1_1TensorElement_1a2a301cd1beb0eecde2b83c1ca6167c59" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>contraction</name></member>
      <member refid="classcsl_1_1Abstract_1abd35096982e92b669ea55d960c5f44be" prot="public" virt="virtual" ambiguityscope="csl::AbstractElement::"><scope>csl::TDerivativeElement</scope><name>contraction</name></member>
      <member refid="classcsl_1_1Abstract_1af29c2898c5d3ba96de8018a0838c402c" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>copy</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1a36e27ebf0e0c82941829b8ed015a26fc" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>copy_unique</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1a85eae07c84149a410984807125d6f556" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>deepCopy</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1a9d93b947a2e4f55e14ba514cdbd3d4d8" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>deepRefresh</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1af76375171fcd6824d8410030fb2d5c28" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>dependsExplicitlyOn</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1a254af52dc9947ef7fa1625ea9c9f77ef" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>dependsExplicitlyOn</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1a618856543c22406e8c7eed5b8a5a9c65" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>dependsOn</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1af1249fbc711db9da848ef8f80ce9a9bd" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>dependsOn</name></member>
      <member refid="classcsl_1_1TensorElement_1a7a1fc7737cce9da527d3796d2fd711d8" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>derive</name></member>
      <member refid="classcsl_1_1Abstract_1aeb08811cf370616477a92075e4a218ee" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>determinant</name></member>
      <member refid="classcsl_1_1Abstract_1a1578c74aee1050b806a67e7a81a67f5c" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>division_own</name></member>
      <member refid="classcsl_1_1Abstract_1a4cc7a46deaa3eaa7593909d74e76d4af" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>dot</name></member>
      <member refid="classcsl_1_1Operator_1aaf3e5ccf31c2699000627096abaa9ba8" prot="protected" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>empty</name></member>
      <member refid="classcsl_1_1Abstract_1a0c3c3fe5010f24e8a8765ea06415c003" prot="public" virt="virtual" ambiguityscope="csl::TensorFieldElement::"><scope>csl::TDerivativeElement</scope><name>empty</name></member>
      <member refid="classcsl_1_1Abstract_1a61e4e80d998a888a1a74d9ea3e10c0f1" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>end</name></member>
      <member refid="classcsl_1_1Abstract_1ae2761d54f13310e13f5076d565edd7ef" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>end</name></member>
      <member refid="classcsl_1_1TensorFieldElement_1a55ad56ca57e69bdcb5b77e6d0bf254c7" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>evaluate</name></member>
      <member refid="classcsl_1_1Abstract_1a543d5a4f0432e166b492ad28a860a65f" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>evaluateScalar</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1add5adbf1747cd9343c96dca5a2b7479b" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>expand</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1a1fee5554d976f77bf0e2dd5a451890b7" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>expand_if</name></member>
      <member refid="classcsl_1_1Abstract_1aa2696a0feb43766ef54e1e3dd3d6d134" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>exponentiation_own</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1a984d8c40c787a0d7350aa0de1969c65f" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>factor</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1afff58e758180748e03f566e9ac83e728" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>factor</name></member>
      <member refid="classcsl_1_1AbstractBuildingBlock_1a4000d3f204c1957f5cffc0677dd754c0" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>findSubExpression</name></member>
      <member refid="classcsl_1_1Abstract_1a021946e84d8c1a019908cac578b16fe8" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getAllDependencies</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1a3f571d26e241f9a943e11191c3ebe9a6" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getArgument</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1af2b7c69a2465d6c4c302c97a275d44a8" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a898d6cf2a7f348feacab189447bee1eb" prot="public" virt="virtual" ambiguityscope="csl::Operator&lt; TensorFieldElement &gt;::"><scope>csl::TDerivativeElement</scope><name>getArgument</name></member>
      <member refid="classcsl_1_1Abstract_1aa689fb64eecb86edbde6c745d1ce756b" prot="public" virt="virtual" ambiguityscope="csl::Operator&lt; TensorFieldElement &gt;::"><scope>csl::TDerivativeElement</scope><name>getArgument</name></member>
      <member refid="classcsl_1_1TensorElement_1ad6f8f7e5b89936e1fa39661b1975c3ce" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getCanonicalPermutation</name></member>
      <member refid="classcsl_1_1Operator_1aa26c6f1e6a43ab0d529c170466e810b0" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getCommutable</name></member>
      <member refid="classcsl_1_1Complexified_1ab70d880a6d5eaf52b7d365c9d0c29f86" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getComplexArgument</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1a1b6a2e64b07222e4d5d126d2281c4816" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getComplexConjugate</name></member>
      <member refid="classcsl_1_1Complexified_1a05b65b2f6cdbc13a1d757a3f90ae7c0c" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getComplexModulus</name></member>
      <member refid="classcsl_1_1AbstractElement_1a0b2c014c2c35cad27d9df5240bfb8548" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getComplexProperty</name></member>
      <member refid="classcsl_1_1Abstract_1af04c0e4426f0bf9df365afe0148d59df" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getContractedPair</name></member>
      <member refid="classcsl_1_1TensorElement_1a5f1b1ae7f3655cccd70bf09a60075b7b" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getContractionProperties</name></member>
      <member refid="classcsl_1_1Abstract_1aa22f0e4c9c91f43b5cd61cbb873869eb" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getDeltaMinus</name></member>
      <member refid="classcsl_1_1Abstract_1a69a657baf1c35ed581e9db2c47a71c99" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getDeltaPlus</name></member>
      <member refid="classcsl_1_1Abstract_1a9531d78d67c82e288c0130da5b1ba80b" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getDenom</name></member>
      <member refid="classcsl_1_1Abstract_1a5856c3d55a6d1406970f3656e61efe8e" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getDim</name></member>
      <member refid="classcsl_1_1Abstract_1a77e067fc57c0c2e70d141079455fdbd7" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getElementary</name></member>
      <member refid="classcsl_1_1Abstract_1ac513c930caa9939c2b9557f36a34ee69" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getExponents</name></member>
      <member refid="classcsl_1_1Abstract_1ac34c9c6f05e692faeed2f030514787ad" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getFactors</name></member>
      <member refid="classcsl_1_1Abstract_1aa4136dc23f1fba4bf897b54c8592ccfc" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getFreeIndexStructure</name></member>
      <member refid="classcsl_1_1TensorElement_1ab38b54f3efd6b9950b6d3334a224caa1" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getHermitianConjugate</name></member>
      <member refid="classcsl_1_1TensorElement_1ac1596174400a2ccd49d56b736fa8114a" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getHermitianConjugate</name></member>
      <member refid="classcsl_1_1Complexified_1a11702661de0ea3b9c59b1f23af0ca0c0" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getImaginaryPart</name></member>
      <member refid="classcsl_1_1TensorElement_1a029c4358822daed54f4f775032896790" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getIndex</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1aab730479855c747fa6baafe4c50ca8cf" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1ae6a9a9ef3efd6bb83b62c0a353742d25" prot="public" virt="non-virtual" ambiguityscope="csl::AbstractElement::"><scope>csl::TDerivativeElement</scope><name>getIndexStructure</name></member>
      <member refid="classcsl_1_1TensorElement_1abe312de6a76204dfcdc98cf4711bf353" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getIndexStructureView</name></member>
      <member refid="classcsl_1_1TensorElement_1a15b5b8ef2a249fda36f7491b634270fb" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getIndexStructureView</name></member>
      <member refid="classcsl_1_1Abstract_1a3d6b1e294cf24dea17c3c4361226138b" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getInfBoundary</name></member>
      <member refid="classcsl_1_1AbstractElement_1ad8d4ceaa06fb30861b1ce4336a465f54" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getLatexName</name></member>
      <member refid="classcsl_1_1Abstract_1a652101e34b2efa43114150e9af3c79d5" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getLibDependency</name></member>
      <member refid="classcsl_1_1AbstractElement_1ae80699e259632a43c4f69a125b64ae30" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getName</name></member>
      <member refid="classcsl_1_1Abstract_1aa034448201c9e7998bbbb5e409636b30" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getNArgs</name></member>
      <member refid="classcsl_1_1Abstract_1a42125e9765a771c47819548d342b0b28" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getNContractedPairs</name></member>
      <member refid="classcsl_1_1Abstract_1a204dbd37b63432cb08932b995f49d3f4" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getNFactor</name></member>
      <member refid="classcsl_1_1TensorElement_1a5ddd03efb94ea0017def76cd6777f745" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getNIndices</name></member>
      <member refid="classcsl_1_1Abstract_1a6aa6bcc7cb8ee1574f29dc6ab6c6f0ed" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getNum</name></member>
      <member refid="classcsl_1_1Abstract_1aad25c117c8dfc4d9718ba41e8d3f33a6" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getNumericalFactor</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1aba17709ddc3ea5ae260a6b713a032355" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getOperand</name></member>
      <member refid="classcsl_1_1Abstract_1a9500a21d75d03c695ec0c76493600b38" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getOrder</name></member>
      <member refid="classcsl_1_1Abstract_1ae89eb7b1a9e0259a60154563f3315907" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getOrderOf</name></member>
      <member refid="classcsl_1_1AbstractElement_1a9e50d48ea0ee472c5c07f3985cc6c641" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getParent</name></member>
      <member refid="classcsl_1_1AbstractElement_1acde43ab4cab544c3c0aa0d695e67b4ad" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getParent_info</name></member>
      <member refid="classcsl_1_1Abstract_1aea8459b3206eb3a2297eeea7688e9520" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getParity</name></member>
      <member refid="classcsl_1_1TensorElement_1aa0f1ab4f63aa28f3c759a666fb15636a" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getPermutations</name></member>
      <member refid="classcsl_1_1TensorFieldElement_1ac80748b3601cff1ed0df3b721316b950" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getPoint</name></member>
      <member refid="classcsl_1_1AbstractElement_1a028ecff66278c1e385280b761388b929" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getPolynomialTerm</name></member>
      <member refid="classcsl_1_1TensorFieldElement_1aab050fd18460d4842d8972a990363b0c" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getPrimaryType</name></member>
      <member refid="classcsl_1_1Abstract_1a07489d0569bc983718796d21c73f34b3" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getProduct</name></member>
      <member refid="classcsl_1_1Complexified_1a5de9b50162c5af5177a928e855e6b71b" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getRealPart</name></member>
      <member refid="classcsl_1_1Abstract_1a5b77f008f4b95030641224877004f06c" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getRegularExpression</name></member>
      <member refid="classcsl_1_1Abstract_1a625efe55a17b97a1c0f085bdbf3a962a" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getShape</name></member>
      <member refid="classcsl_1_1Abstract_1aa83df1d9dc202457113e5b38bd694fae" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getSign</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1a2073cd345694641addf40b7af57aeac8" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getSubSymbols</name></member>
      <member refid="classcsl_1_1Abstract_1a7dcdc11b64c8c515933882168d0792ef" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1a413c50b2663f57d38c1d3ec3cfeaa3ce" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1a26a0854bca4c47e84a1da36a3de8c49f" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1a29261a946b3398b6129237620754a8b9" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1a8a067b70756c4eef758aa88076a95162" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1aeaf8154e39ff211b12e6382e675ccaad" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getSum</name></member>
      <member refid="classcsl_1_1Abstract_1a2fcc223dbf5d880e923c07df142df5c8" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getSupBoundary</name></member>
      <member refid="classcsl_1_1AbstractBuildingBlock_1a58c627e31c2a42adec4caf39030123aa" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getTerm</name></member>
      <member refid="classcsl_1_1TensorElement_1ae47bc7e79e284964b2a8447bf917f48f" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getTransposed</name></member>
      <member refid="classcsl_1_1TensorElement_1a7cc7fb9e1f39bcebc90170e8dd526d43" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getTransposed</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1a16ff4a3a49daf68786abbe407d1d5b8c" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getType</name></member>
      <member refid="classcsl_1_1Abstract_1a78f98ba06476e464e3fd2fce0d1f8243" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getValue</name></member>
      <member refid="classcsl_1_1Abstract_1a628563238145f3a9acc331f1a89ce32f" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getValued</name></member>
      <member refid="classcsl_1_1Abstract_1ae85f810bbadbc792210c958e8f1b2ffb" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getVariable</name></member>
      <member refid="classcsl_1_1Abstract_1ac83c44ae1e5315a38083bdb7acd8f3fa" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getVectorArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a0188b049736016c970a2513ed9f6931f" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>getVectorialModulus</name></member>
      <member refid="classcsl_1_1TensorElement_1acb6f22178e26a8cc694ae2ffc01c2075" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>hasChainContractionProperty</name></member>
      <member refid="classcsl_1_1TensorElement_1a511992d33dc54c1fb8d0c4c17afa5f8c" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>hasContractionProperty</name></member>
      <member refid="classcsl_1_1Abstract_1a8c42723e8bc6334c99f00898cc1d59d7" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>hermitian</name></member>
      <member refid="classcsl_1_1TensorElement_1a7f7b50e1bbd4157e8b2797740aa31b89" prot="protected" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>index</name></member>
      <member refid="classcsl_1_1Abstract_1a5437e7f685edf8549e6d3b34572343f8" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>insert</name></member>
      <member refid="classcsl_1_1Abstract_1a1b68943aa7ecf60a63af0f2f368eef8f" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>inverseMatrix</name></member>
      <member refid="classcsl_1_1Operator_1a740ec7cf6f100e21ab3e6e1dde93374b" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>isAnOperator</name></member>
      <member refid="classcsl_1_1Abstract_1ac09992d147b39388c8936b3bff648930" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>isArbitrary</name></member>
      <member refid="classcsl_1_1AbstractBuildingBlock_1aee083330a4490359012cf0e656758a44" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>isBuildingBlock</name></member>
      <member refid="classcsl_1_1Complexified_1a3f583f018b34b63b321976a8bcedf430" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>isComplexConjugate</name></member>
      <member refid="classcsl_1_1Operator_1aee71c873c2f3042ea748f1e9e07f7d6c" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>isEmpty</name></member>
      <member refid="classcsl_1_1Abstract_1af2ce38838e35c5785f92373a1d830668" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>isHermitianConjugate</name></member>
      <member refid="classcsl_1_1TensorFieldElement_1a9bc54de57d7301838f673c014ed9d79f" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>isIndexed</name></member>
      <member refid="classcsl_1_1Abstract_1a9a014bfd266b5f8471f23580e271979b" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>isInteger</name></member>
      <member refid="classcsl_1_1AbstractElement_1a9f3e30eeaace6c5c21cda6895daa2de9" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>isPolynomial</name></member>
      <member refid="classcsl_1_1Complexified_1aa3de4cb73eb624830da28f07ef0fa4d4" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>isPurelyImaginary</name></member>
      <member refid="classcsl_1_1Complexified_1a4c69b308c3d305cfa532eb5c653072a0" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>isReal</name></member>
      <member refid="classcsl_1_1Abstract_1ab79c1d8df9e6b1a3eca66958f7dc489d" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>matchShape</name></member>
      <member refid="classcsl_1_1TensorElement_1ae7a6d8fc44218dcade0332e215f4b653" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>memoryOverhead</name></member>
      <member refid="classcsl_1_1Abstract_1a4f5ed458ba62f5b4cf61a9e1f8568af1" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>multiplication_own</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1a8b0aa4e09e715ae2e41b7092cd63a72b" prot="protected" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>operand</name></member>
      <member refid="classcsl_1_1Operator_1abeb8555c87e755baed2b7caff64cbb70" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>Operator</name></member>
      <member refid="classcsl_1_1Operator_1ac46d14c2b95625f96bb07d65713ef139" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>Operator</name></member>
      <member refid="classcsl_1_1Abstract_1af5b62a6308638064c42da80e9cc2cb7e" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1af4fd1b57df371dac7ccfd5a909620e49" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1a96de5935a58a96d4c5b1e47966488923" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1ac99a619abde7e4c58f39e14d4d20fcf5" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1a45206de7c7773b3cb150451ee3eb379e" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1a0d3495220202bd417c1b58249c923f39" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1a90129cfd12b5f98644e088de0e40fd74" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>operator&lt;</name></member>
      <member refid="classcsl_1_1Abstract_1a5c1ba8dce7fbc19eb98807bd15a279c9" prot="public" virt="pure-virtual" ambiguityscope="csl::AbstractElement::"><scope>csl::TDerivativeElement</scope><name>operator&lt;</name></member>
      <member refid="classcsl_1_1Abstract_1a6e19587260a07dba65cf2a985e05516b" prot="public" virt="non-virtual" ambiguityscope="csl::AbstractElement::"><scope>csl::TDerivativeElement</scope><name>operator&lt;</name></member>
      <member refid="classcsl_1_1Abstract_1a2a1660498f2638f5e490d6e512eb32f4" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>operator&lt;=</name></member>
      <member refid="classcsl_1_1Abstract_1afbcac6df2fd7ac11f336189cf215124b" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>operator&lt;=</name></member>
      <member refid="classcsl_1_1Abstract_1a59ff2950fc8ca319f87a730450f14545" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>operator=</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1a380f7ce153c1b608c232e86f79bdcbd0" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a8334e14cd5789168b037d3888ed60edd" prot="public" virt="virtual" ambiguityscope="csl::AbstractBuildingBlock::"><scope>csl::TDerivativeElement</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a12d929e34039e817e464abc560bd4a9d" prot="public" virt="virtual" ambiguityscope="csl::AbstractBuildingBlock::"><scope>csl::TDerivativeElement</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a1f78f0cce24c93def3050743bc5f2845" prot="public" virt="non-virtual" ambiguityscope="csl::AbstractBuildingBlock::"><scope>csl::TDerivativeElement</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1aed43debcac4a19e0da44986774c522bc" prot="public" virt="non-virtual" ambiguityscope="csl::AbstractBuildingBlock::"><scope>csl::TDerivativeElement</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a2376f08c0aa5ffe783090381d102d3ae" prot="public" virt="non-virtual" ambiguityscope="csl::AbstractBuildingBlock::"><scope>csl::TDerivativeElement</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a485c6f3e10db539a70416cd0766b117d" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>operator&gt;</name></member>
      <member refid="classcsl_1_1Abstract_1ab305bdf49212f03781e7f98024faeb66" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>operator&gt;</name></member>
      <member refid="classcsl_1_1Abstract_1a4c8883df19d7538b68fa96aadac9dfa9" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>operator&gt;=</name></member>
      <member refid="classcsl_1_1Abstract_1a6b931f7b159d57bad26ca9c9ea729aa1" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>operator&gt;=</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1a2e9000986cc55b7016cc56513f058f69" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>operator[]</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1aa2934b8a3734feac07dec2abc1e14e5a" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>operator[]</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1adf338110c2e609411e6e82120c3c5013" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>operatorAppliesOn</name></member>
      <member refid="classcsl_1_1AbstractElement_1a5ad0a45c8a069be5e3e0ce21b784bb0b" prot="protected" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>parent</name></member>
      <member refid="classcsl_1_1Abstract_1abe9aceabbc0a99642e84c9025dbdc767" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>permut</name></member>
      <member refid="classcsl_1_1TensorFieldElement_1afac4c3b974119ba3ecc7e093abcd28c2" prot="protected" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>point</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1a0d83fa5e3869c4e375e4d5d3f0ae8757" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>print</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1abc07f74c7642f18855bea42cbed1eef5" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>printCode</name></member>
      <member refid="classcsl_1_1Abstract_1a89e45ffc7b65f92e77e592f76f70934c" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>printExplicit</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1aa3b01cb3bd1dcef5901cc82ec29c66b3" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>printLaTeX</name></member>
      <member refid="classcsl_1_1Complexified_1a42c425b2145c916331f881f217e14e4b" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>printProp</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1acb67e501bd671dd0f0d8bfde9379d51b" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>refresh</name></member>
      <member refid="classcsl_1_1Abstract_1a8aab87c41acafaf1b1837b922495560d" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>regularLiteral</name></member>
      <member refid="classcsl_1_1Abstract_1a2fe749450d2e610199801b189dc3d0f8" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>regularLiteral</name></member>
      <member refid="classcsl_1_1Abstract_1aba5ef083016b2f3d9e6271f864b9b063" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>regularName</name></member>
      <member refid="classcsl_1_1Abstract_1a1a8421d402d5ba82257188b545e8d668" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>regularName</name></member>
      <member refid="classcsl_1_1Abstract_1a0e778c682b6cb02642b90e8ec8765441" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>removeDependency</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1ae304eceb527459e79e9cc635350b1a70" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>replaceIndex</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1a3641cf8c169a05bff45ac4882c0cb596" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>replaceIndexInPlace</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1ad55b628d2e960ed410b59d5e3d58ce16" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>replaceIndices</name></member>
      <member refid="classcsl_1_1TensorElement_1a1ca07618e533c2ca4b4cc3646195a64d" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>resetIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1a5c796713828ebfb74a7d8787d7802a76" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>self</name></member>
      <member refid="classcsl_1_1TensorElement_1a44cf39f1c6deadcb0191a78d32c3b441" prot="protected" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>selfCheckAutoIndices</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1a336af14506e8d3877cfc15eeb3eb9149" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>selfCheckIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1aa6a40ceb6eb1aa79711ca126d5bdda02" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>setAllDependencies</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1adce6c89ecb493c05627b42f036e49b5b" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>setArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a45c3adb7ba4e2b8442247246a3792b44" prot="public" virt="virtual" ambiguityscope="csl::Operator&lt; TensorFieldElement &gt;::"><scope>csl::TDerivativeElement</scope><name>setArgument</name></member>
      <member refid="classcsl_1_1AbstractElement_1ab8f5f04326a3320b48a315ec5cee60d9" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>setCommutable</name></member>
      <member refid="classcsl_1_1AbstractElement_1a7d9bb4605dbd97ea98f721611adadd72" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>setComplexProperty</name></member>
      <member refid="classcsl_1_1Complexified_1a22b60556c965e51ab733e6eb5441783c" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>setConjugated</name></member>
      <member refid="classcsl_1_1Abstract_1aa6a04bb56578e7da143b3cd8d8fb7b26" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>setElementary</name></member>
      <member refid="classcsl_1_1Operator_1a79761fde19842386022873d3332d2454" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>setEmpty</name></member>
      <member refid="classcsl_1_1Abstract_1ac318016372d14b795893fe7e59199084" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>setFullyAntiSymmetric</name></member>
      <member refid="classcsl_1_1Abstract_1a4f90ebb7cf7c26782bd36bc2a67fc5d4" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>setFullySymmetric</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1ae976c5be78ef54ca485001a9807d75bc" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>setIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1a5ecdb6ce7a2d9643da2f6161a06dfbbf" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>setInfBoundary</name></member>
      <member refid="classcsl_1_1AbstractElement_1aed5a0c9faec5b41fb1feb52764c4237f" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>setName</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1ab78ef96e45ffe45a9fd18b315ad73db9" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>setOperand</name></member>
      <member refid="classcsl_1_1Operator_1a5a4637f0cc00891717e62a6bdfbd212f" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>setOperandPrivate</name></member>
      <member refid="classcsl_1_1AbstractElement_1af55db25120693bf64ed360105cb4357c" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>setParent</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1a9c002e3c12a2d4f959795431d28b4099" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>setPoint</name></member>
      <member refid="classcsl_1_1Abstract_1aad7104a5b8855272a92a47c58f29e958" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>setSupBoundary</name></member>
      <member refid="classcsl_1_1Abstract_1aaf7f0692cb84ca861a5b3b641bea518b" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>setValue</name></member>
      <member refid="classcsl_1_1Abstract_1aa49c51bd285830e724f103e9fb61c464" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>setValue</name></member>
      <member refid="classcsl_1_1Abstract_1aa47ddab3aa047e86be34c70358d53548" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>setVariable</name></member>
      <member refid="classcsl_1_1Abstract_1a83fee8ed28079bcac107455d58be9d5d" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>setVectorArgument</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1a877666789a952f0dbf0e37bd91383108" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>size</name></member>
      <member refid="classcsl_1_1Abstract_1a4eeedaeaa39e75facf1060dce7c57a8f" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>suppressExponent</name></member>
      <member refid="classcsl_1_1Abstract_1a43520e1d6d5fdad9b50f77c6e027f928" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>suppressTerm</name></member>
      <member refid="classcsl_1_1Abstract_1a4faf1ffd8cb3b6c721e128980c0303d8" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>symmetrise</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1a7add9201b4d926c39f45e5181737d1f6" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>TDerivativeElement</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1aa67378895bb919e0d1c17fba1746927e" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>TDerivativeElement</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1ae27d5d413aba166b5c7636b95fcb3173" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>tderivativeelement_s</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1a63cb62b7453a1084a244221af72f97a7" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>tderivativeelement_s</name></member>
      <member refid="classcsl_1_1Abstract_1a7b83c6a13716688f45b02e6291d39aba" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>tensordot</name></member>
      <member refid="classcsl_1_1TensorElement_1ae0b7c09c0acd3173ba66669d797192c0" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>TensorElement</name></member>
      <member refid="classcsl_1_1TensorElement_1a1b29839ab99dd106e336ce900023d18a" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>TensorElement</name></member>
      <member refid="classcsl_1_1TensorElement_1ac2169c4eabe165be2f0c455f658a0036" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>TensorElement</name></member>
      <member refid="classcsl_1_1TensorElement_1a3bba3e8ce7e864a2921ad91e4019454c" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>TensorElement</name></member>
      <member refid="classcsl_1_1TensorElement_1a4d45c8d308213ea65d46f9aeab883d9f" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>TensorElement</name></member>
      <member refid="classcsl_1_1TensorElement_1a4f78788e311f00a646e933b102fe365c" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>TensorElement</name></member>
      <member refid="classcsl_1_1TensorFieldElement_1a36078184224c07158d5eb1268128d670" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>TensorFieldElement</name></member>
      <member refid="classcsl_1_1TensorFieldElement_1a9c35e9c1bae8f34130311b027fab9867" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>TensorFieldElement</name></member>
      <member refid="classcsl_1_1TensorFieldElement_1a16cf2e827a2ee85322fea69b4e779827" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>TensorFieldElement</name></member>
      <member refid="classcsl_1_1Abstract_1aee4fa41a5e014f067395467542ee8831" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>testDummy</name></member>
      <member refid="classcsl_1_1Abstract_1a9a86d21f5c5f65eb7e524a8f8002c0e7" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>trace</name></member>
      <member refid="classcsl_1_1Abstract_1aacab43e551e9259a39a79378373ce49c" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>trace</name></member>
      <member refid="classcsl_1_1Abstract_1a1e97712696e5c40b28bc1e35987fea94" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>transpose</name></member>
      <member refid="classcsl_1_1Abstract_1a40bdc4c76fdbbf3cbac3af4dce8286ed" prot="public" virt="virtual"><scope>csl::TDerivativeElement</scope><name>~Abstract</name></member>
      <member refid="classcsl_1_1AbstractElement_1a96ee7c198c82450d17ce0f08df2bef00" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>~AbstractElement</name></member>
      <member refid="classcsl_1_1Operator_1ad0d3e7465277ab30bc11413410daea6e" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>~Operator</name></member>
      <member refid="classcsl_1_1TDerivativeElement_1a66539851b420ad3dc18e6602d259f46d" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>~TDerivativeElement</name></member>
      <member refid="classcsl_1_1TensorFieldElement_1ab09e4e36b98ea53f96c817d7af2c9368" prot="public" virt="non-virtual"><scope>csl::TDerivativeElement</scope><name>~TensorFieldElement</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
