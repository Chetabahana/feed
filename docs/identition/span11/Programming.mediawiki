''[[Programming|https://id.wikipedia.org/wiki/Pemrograman]]'' (pemrograman) adalah proses menulis, menguji dan memperbaiki (debug), dan memelihara kode yang membangun suatu [[program|program komputer]].

__TOC__

==Desain==

* [[Mengenal Konsep OOP|https://idcloudhost.com/panduan/mengenal-pengertian-dan-konsep-oop/]]

Beberapa prinsip pemrograman berorientasi objek adalah prinsip-prinsip desain kelas. Dalam project ini kita analogikan opsi² tersebut sebagai bentuk hubungan antar objek. 

<br>[[Implementasi|<img src=https://user-images.githubusercontent.com/36441664/82759546-60e14080-9e18-11ea-845f-81aee6a63659.jpg>]]

Untuk penampilan dari cara dokumentasinya Anda bisa pelajari disini:
* Wikitext: https://en.wikipedia.org/wiki/Help:Wikitext  
* Template:Highlight: https://en.wikipedia.org/wiki/Template:Highlight  
* Extension:SyntaxHighlight: https://www.mediawiki.org/wiki/Extension:SyntaxHighlight  
''Note: If you can't understand [[Bahasa|https://en.wikipedia.org/wiki/Bahasa]], you may see what this all about here in [[Stack Overflow|https://stackoverflow.com/questions/50820724/how-to-get-jekyll-collections-as-json-base-on-weight-using-liquid]]''.

===Kelas===

Menggunakan kelas yang dirancang dengan baik membantu meningkatkan stabilitas dan pemeliharaan aplikasi Anda. Objek yang dirancang dengan baik hanya memiliki satu tanggung jawab dan dapat digunakan kembali, fleksibel, dan dikemas.

[[Diagram|<img src=https://user-images.githubusercontent.com/36441664/71261750-c19fb500-2370-11ea-8e0c-4c665cb77857.png width=500>]]

Properti suatu objek adalah apa yang diketahuinya dan metodenya adalah apa yang dapat dilakukannya. 
# Properti objek klien akan mencakup semua detail penting tentang klien dan metode-metodenya akan dapat mengubahnya. 
# Objek biaya akan memiliki metode yang diperlukan untuk menghitung biaya proyek berdasarkan jam kerja, tarif per jam, biaya bahan, dan biaya.

====Prinsip====

[[Single responsibility principle|https://en.wikipedia.org/wiki/Single_responsibility_principle]] (SRP) menyatakan bahwa suatu kelas tidak boleh memiliki lebih dari satu tanggung jawab. Jika memang memiliki banyak tanggung jawab, perubahan satu tanggung jawab dapat secara tidak sengaja melanggar tanggung jawab lainnya di kelas.  

Ini dapat menyebabkan efek domino di aplikasi Anda, menyebabkannya melakukan atau memecah dengan cara yang tidak terduga.

[[<img src=https://user-images.githubusercontent.com/36441664/71580479-72594180-2b33-11ea-83f7-69ad5a681a94.png width=600>|http://xahlee.info/comp/oop.html]]

Tanyakan pada diri Anda apakah objek yang Anda rancang dapat digunakan dalam versi aplikasi berikutnya dengan sedikit perubahan. Apakah bisa berfungsi jika aplikasi dikonfigurasi ulang? Bisakah ini bekerja di aplikasi lain?

[[Implementasi#polinomial|<img src=https://user-images.githubusercontent.com/36441664/71182939-9e5e0280-22a9-11ea-8b70-4de1c91df802.png width=600>]]  

Anda akan dapat menjawab ya untuk setidaknya salah satu dari pertanyaan ini jika Anda sedang membangun objek fleksibel yang dapat digunakan kembali.

====Flexible====

* [[How a simple mix of OOP can sharpen your deep learning prototype|https://towardsdatascience.com/how-a-simple-mix-of-object-oriented-programming-can-sharpen-your-deep-learning-prototype-19893bd969bd]]

Di dunia nyata, objek sering menyembunyikan informasi mereka dan cara kerjanya. Mereka memiliki antarmuka publik yang memungkinkan Anda untuk berhasil menggunakan objek tanpa mengetahui apa pun tentang cara kerjanya. 

Anda tidak perlu mengetahui detail internal untuk menggunakan objek selama Anda tahu cara menggunakan antarmuka publiknya.

Ketika Anda mulai menggunakan prinsip penyesuaian pewarisan, objek Anda dapat mencapai tingkat usabilitas yang lebih tinggi melalui pemetaan ([[mapping]]) dari [[bagan]] dan [[diagram]].

[[Mapping|<img src=https://user-images.githubusercontent.com/36441664/82457970-535a4c80-9ae0-11ea-8746-54ced1d3d05f.jpg>]]

Menurut [[Kamus Besar Bahasa Indonesia (KBBI)|https://kbbi.web.id/]]:
* [[Skema|https://kbbi.web.id/skema]]: '''rangka/kerangka (rancangan, paparan dan sebagainya)'''; garis besar; denah;
* [[Bagan|https://kbbi.web.id/skema]]: alat peraga grafik untuk '''menyajikan data agar mempermudah penafsiran''';
* [[Diagram|https://kbbi.web.id/diagram]] : gambar yang '''memperlihatkan jalannya pelaksanaan''' kegiatan; 

Dari ketiga kata di atas kata [[Skema|https://kbbi.web.id/skema]] mengandung arti yang paling mendasar, oleh karenanya  maka dalam project ini kita pakai untuk mulai menjelaskan Konsep secara garis besar.<br><br>

Selanjutnya guna menyamakan persepsi maka uraian dengan huruf tebal akan diambil sebagai acuan yang membedakan pemakaian dari kata ''[[Bagan]]'' dan ''[[Diagram]]''.

===Object===

Saat mendesain objek, ingatlah usabilitas dan fleksibilitas. Anda ingin menulis kelas yang dapat digunakan berulang kali dalam aplikasi Anda, dan mungkin di kelas yang akan datang.

[[Program#resolusi|<img src=https://user-images.githubusercontent.com/36441664/71260691-0e35c100-236e-11ea-83a3-441f2f55b91e.png>]]

Pikirkan tentang sakelar lampu. Untuk menyalakan lampu, Anda cukup beralih sakelar. Anda tidak perlu menjadi tukang listrik atau mengerti apa pun tentang listrik untuk mengerjakan sistem listrik di sebuah ruangan. 

====Operasi====

Mobil adalah contoh bagus lainnya. Selama Anda tahu cara menggunakan pedal gas dan rem, setir, dan kunci kontak, Anda bisa mengemudi.

Anda tidak perlu memahami bagaimana mesin, atau transmisi, atau sistem kelistrikan bekerja untuk mengendarai mobil. Anda juga tidak perlu tahu sifat-sifat spesifik mobil seperti ukuran mesin, tenaga kuda, atau torsi.

====Orientasi====
Di bawah ini adalah tiga versi kelas persegi panjang yang dirancang untuk menggambar persegi panjang. Setiap versi kelas membawanya lebih dekat untuk mencapai tujuan SRP, usabilitas ulang, fleksibilitas, dan enkapsulasi.

[[<img src=https://user-images.githubusercontent.com/36441664/71260772-46d59a80-236e-11ea-99f1-b7fa642a30f8.png>|http://www.differencebetween.net/technology/software-technology/difference-between-data-hiding-and-data-encapsulation/]]

Dalam pemrograman berorientasi objek, objek yang dirancang dengan baik merangkum data dan fungsionalitasnya dari objek lain. Anda dapat mempelajari lebih lanjut tentang enkapsulasi dalam konsep pemrograman berorientasi objek: Enkapsulasi.

==Metode==

* [[OOPs: Encapsulation|https://www.adobe.com/devnet/actionscript/learning/oop-concepts/encapsulation.html]]

Memiliki konsep getter dan setter implisit yang memungkinkan Anda untuk menyembunyikan detail implementasi lebih lanjut dari pengguna saat mengatur atau membaca properti untuk menyegarkan apa yang ditampilkan di layar.<br><br>

[[https://user-images.githubusercontent.com/36441664/69957702-c0c7f000-1535-11ea-9472-12725801ae67.png]]

Pembuat dan penyetel tersirat adalah benar-benar dua fungsi yang terlihat seperti properti tunggal untuk pengguna objek. Satu fungsi — pengambil — disebut ketika properti dibaca. Fungsi lainnya — setter — dipanggil ketika properti diatur. 

===Delegasi===
Delegasi, dalam komputasi atau pemrograman komputer, secara umum merujuk pada satu entitas yang memberikan sesuatu kepada entitas lain, dan secara sempit ke berbagai [[Sequence#model|model]] hubungan tertentu. Ini termasuk:

# Delegasi (pemrograman berorientasi objek), mengevaluasi [[Sequence#class|class]] dari satu objek (penerima) dalam konteks yang lain, objek asli (pengirim).
# Pola pendelegasian, [[Sequence#pewarisan|pola desain]] yang menerapkan fitur ini.
# Penerusan (pemrograman berorientasi objek), teknik yang sering membingungkan di mana objek pengiriman menggunakan [[Sequence#class|class]] dari objek lain, tanpa objek penerima memiliki pengetahuan tentang objek pengirim asli.
# Agregasi atau [[Diagram#kaidah-kognitif|kaidah-kognitif]], istilah umum untuk satu objek menggunakan objek lain.
# Suatu bentuk pointer fungsi yang digunakan oleh Common Language Infrastructure (CLI), untuk memanggil dan secara opsional objek dalam proses [[Sequence#interaksi|interaksi]].

[[<img src=https://user-images.githubusercontent.com/36441664/71585786-5c0ab000-2b4a-11ea-8e43-27511b3c7d0e.png width=500>|https://snarky.ca/deconstructing-xkcd-com-1987/]]

====Pewarisan====
Kita telah bahas metode Encapsulation sampai ke Inheritance, maka pada proses pembentukan Class akan ditelusuri akurasinya terhadap kaidah kognitif.

[[<img src=https://user-images.githubusercontent.com/36441664/71191184-80e46500-22b8-11ea-9f97-5ce856a39820.png>|http://www.allinoneblogs.com/java-tutorials/oops-concept/object-oriented-programming/]]

Dalam pemrograman berorientasi objek, pewarisan memungkinkan objek baru mengambil properti dari objek yang ada. Kelas yang digunakan sebagai dasar pewarisan disebut kelas superclass atau base. Kelas yang mewarisi dari superclass disebut subclass atau turunan kelas.  

====Komposisi====
Istilah kelas induk dan kelas anak juga merupakan ketentuan yang dapat diterima untuk digunakan masing-masing. Seorang anak mewarisi properti dan metode yang terlihat dari induknya sambil menambahkan properti dan metode tambahannya sendiri.

Subclass adalah turunan dari superclass yang lebih spesifik. Misalnya, jeruk adalah buah jeruk, yang merupakan buah. Seorang gembala adalah seekor anjing, yang merupakan binatang. Klarinet adalah alat musik tiup kayu, yang merupakan alat musik. 

Jika hubungan adalah tidak ada antara subclass dan superclass, Anda tidak boleh menggunakan warisan. Jeruk adalah buah; jadi tidak apa-apa untuk menulis kelas Oranye yang merupakan subkelas dari kelas Buah. 

Sebaliknya, dapur memiliki wastafel. Tidak masuk akal untuk mengatakan bahwa dapur adalah wastafel atau bahwa wastafel adalah dapur. 

Memiliki hubungan menunjukkan komposisi (lihat konsep pemrograman berorientasi objek: [[Komposisi dan agregasi|https://www.adobe.com/devnet/actionscript/learning/oop-concepts/composition-and-aggregation.html]]) daripada warisan.

===Property===

Bersama-sama, fungsi-fungsi ini memungkinkan pengguna kelas Anda untuk mengakses properti pribadi seolah-olah mereka mengakses properti publik. 

Selain itu, akses diberikan tanpa memiliki dua fungsi publik untuk setiap properti pribadi yang menyediakan akses baca dan tulis.  
 
<br>[[<img src=https://user-images.githubusercontent.com/36441664/71555526-fe9a3480-2a5f-11ea-972a-eab603b3128e.png width=500>|https://www.py4e.com/html3/14-objects]]

Manfaat tambahan dari fungsi setter adalah menyediakan tempat yang nyaman untuk memastikan bahwa data dibentuk dengan cara yang diharapkan oleh objek Anda.  

Menggunakan fungsi setter, suatu objek dapat berpotensi memvalidasi data sebelum disimpan secara internal, mengurangi kebutuhan untuk lebih lanjut memeriksa data setiap kali digunakan dan memberikan beberapa ukuran konsistensi untuk keadaan internal objek.

====Antarmuka====

Anda sekarang memiliki kemampuan untuk melakukan pekerjaan tambahan ketika salah satu dipanggil. , argumen diperiksa dan metode dipanggil, tetapi sekarang dilakukan secara implisit alih-alih secara eksplisit, menghapus kemungkinan kesalahan pengguna dan menyembunyikan detail implementasi.  

[[Diagram#encapsulation|<img src=https://user-images.githubusercontent.com/36441664/71260726-286f9f00-236e-11ea-803e-dd9f9ea70882.png>]]

Metode pertama adalah untuk menyediakan cara yang disederhanakan dan dimengerti untuk menggunakan objek Anda tanpa perlu memahami kompleksitas di dalamnya.  

Seperti disebutkan di atas, pengemudi tidak perlu tahu cara kerja mesin pembakaran internal. Cukup mengetahui bagaimana menghidupkan mobil, bagaimana melibatkan transmisi jika Anda ingin bergerak, cara menyediakan bahan bakar, cara menghentikan mobil, dan cara mematikan mesin.  

Anda tahu menggunakan kunci, shifter (dan mungkin kopling), pedal gas dan pedal rem untuk menyelesaikan setiap operasi ini. Pengoperasian dasar ini membentuk antarmuka untuk mobil. Pikirkan sebuah antarmuka sebagai kumpulan hal-hal yang dapat Anda lakukan untuk mobil tanpa mengetahui bagaimana masing-masing hal itu bekerja.
 
Menyembunyikan kompleksitas mobil dari pengguna memungkinkan siapa saja, bukan hanya mekanik, untuk mengendarai mobil. 

====Mekanisme====

Dengan cara yang sama, menyembunyikan fungsionalitas kompleks objek Anda dari pengguna memungkinkan siapa saja untuk menggunakannya dan menemukan cara untuk menggunakannya kembali di masa depan terlepas dari pengetahuan mereka tentang cara kerja internal.  

[[<img src=https://user-images.githubusercontent.com/36441664/71263914-8358c480-2375-11ea-9506-8f5563a5a015.png>|https://accu.org/index.php/journals/246]]

Konsep ini menjaga detail implementasi tersembunyi dari sisa sistem adalah kunci untuk desain berorientasi objek.
 
Metode kedua adalah menyembunyikan kompleksitas adalah untuk mengelola perubahan. Saat ini sebagian besar dari kita yang berkendara menggunakan kendaraan dengan mesin pembakaran internal bertenaga bensin.  

Namun, ada hibrida gas-listrik, motor listrik murni, dan berbagai mesin pembakaran internal yang menggunakan bahan bakar alternatif. Masing-masing tipe mesin memiliki mekanisme internal yang berbeda namun kami dapat menggerakkan masing-masing karena kompleksitasnya telah disembunyikan.  

Ini berarti bahwa, meskipun mekanisme yang mendorong perubahan mobil, sistem itu sendiri berfungsi dengan cara yang sama dari perspektif pengguna.

==Integrasi==

* [[Object-oriented programming in C#|https://kottans.org/csharp-slides/presentations/5-oop-pt1/#/]]
* [[Object-Oriented Programming in JavaScript|https://www.freecodecamp.org/news/an-introduction-to-object-oriented-programming-in-javascript-8900124e316a/]]
Pada bagian ini kita akan bahas konfigurasi berdasarkan [[Diagram#metode-oops|Metode OOPs]].  

<br>[[<img src=https://user-images.githubusercontent.com/36441664/70870922-f5bf5280-1fcb-11ea-88cf-44f7b02a7232.png>|https://www.freecodecamp.org/news/an-introduction-to-object-oriented-programming-in-javascript-8900124e316a/]]

Prinsip yang disarankan [[Diagram#metode-oops|Metode OOPs]] sesuai paradigma pemrograman adalah sbb:
# Perluas fungsionalitas kelas setiap kali Anda mendapatkan kesempatan untuk menyelesaikan analisis kompleks menggunakan pewarisan. Ubah mereka menjadi skrip yang dapat dieksekusi dan letakkan di dalam modul kecil. 
# Bangun kebiasaan memodulasi pekerjaan Anda sehingga dapat dengan mudah digunakan kembali dan diperluas oleh siapa saja, di mana saja.  

===Modulasi===
* [[Classes vs modules in nodejs|https://stackoverflow.com/questions/46493808/classes-vs-modules-in-nodejs]]
* [[Importance Of Modularity In Programming|http://aosd.net/importance-of-modularity-in-programming/]]

Sesuai dengan tujuan yang ingin dicapai maka cara identifikasi ini dapat Anda lakukan dengan berbagai macam pola dan style. Berikut ini cara identifikasi yang dilakukan dalam projek ini.

<br>[[<img src=https://user-images.githubusercontent.com/36441664/71568220-17562900-2af8-11ea-82af-5a0d560932ce.png width=300>|https://www.researchgate.net/figure/Modular-programming-architecture_fig10_256439362]]<br>

Pengertian dari modul:  
* standar atau satuan pengukur
* unit kecil dari satu sistem yang dapat beroperasi sendiri
* satuan bebas yang merupakan bagian dari struktur keseluruhan
* satuan standar yang bersama-sama dengan yang lain digunakan secara bersama
* komponen dari suatu sistem yang berdiri sendiri, tetapi menunjang program dari sistem itu

[[<img src=https://user-images.githubusercontent.com/36441664/71568015-74e97600-2af6-11ea-8bae-72507d036d3f.png width=400>|http://aosd.net/importance-of-modularity-in-programming/]]  

```js
### module
const privateHello = 'hello' // <- module code (private)
export const publicHello = 'hello'; // <- module code (public)


### class
export class Classes { // <- module AND class code (public)
    private privateHello = 'hello'; // <- class code (private)
    public publicHello = 'hello'; // <- class code (public)
} // <- class code (public)
const anotherPrivateHello = 'hello'; // <- module code (private)
export const anotherPublicHello = 'hello'; // <- module code (public)


### prototype
export function Prototypes() { // <- module AND prototype code (public)
    const privateHello = 'hello'; // <- prototype code (private)
    this.publicHello = 'hello'; // <- prototype code (public)
} // <- prototype code (public)
const anotherPrivateHello = 'hello'; // <- module code (private)
export const anotherPublicHello = 'hello'; // <- module code (public)
```

====Operasional====

* [[From zero to webpack|https://www.jumoel.com/2017/zero-to-webpack.html]]
* [[Browserify for webpack users'|https://gist.github.com/substack/68f8d502be42d5cd4942]]

[[Node.js|https://en.wikipedia.org/wiki/Node.js]] adalah salah satu bahasa pemrograman yang memungkinkan pembuatan Web Server dan alat jaringan menggunakan JavaScript dan kumpulan [[Programming#modulasi|"modul"]] yang menangani berbagai fungsi inti.  

[[Modul disediakan|https://github.com/chetabahana/tree/tree/master/lib]] untuk sistem file [[I/O|https://en.wikipedia.org/wiki/Input/output]], jaringan ([[DNS|https://en.wikipedia.org/wiki/Domain_Name_System]], [[HTTP|https://en.wikipedia.org/wiki/HTTP]], [[TCP|https://en.wikipedia.org/wiki/Transmission_Control_Protocol]], [[TLS/SSL|https://en.wikipedia.org/wiki/Transport_Layer_Security]], atau [[UDP|https://en.wikipedia.org/wiki/User_Datagram_Protocol]]), [[data biner|https://en.wikipedia.org/wiki/Binary_file]] (buffer), fungsi [[kriptografi|https://en.wikipedia.org/wiki/Cryptography]], [[aliran data|https://en.wikipedia.org/wiki/Stream_(computing)]], dan fungsi inti lainnya yang semuanya dapat difungsikan [[via API|https://nodejs.org/api/modules.html]]. Selain Javascript, Modul Node.js juga support [[CoffeeScript|https://github.com/chetabahana/tree/blob/master/deps/npm/docs/content/using-npm/scripts.md#use-cases]], Dart, TypeScript, ClojureScript dll.  

[[<img src=https://user-images.githubusercontent.com/36441664/70564806-6c6ee100-1bc3-11ea-8beb-3843de6ef1c7.jpg>|https://en.wikipedia.org/wiki/Node.js]]  

Node.js terutama digunakan untuk membangun [[program jaringan Web server|https://en.wikipedia.org/wiki/Server-side_scripting]] seperti halnya [[PHP|https://en.wikipedia.org/wiki/PHP]]. Perbedaan paling signifikan antara Node.js dan PHP adalah bahwa sebagian besar fungsi dalam blok PHP hingga selesai (perintah hanya dijalankan setelah perintah sebelumnya selesai).  

Dari ''[[sejumlah bahasa pemrograman|https://en.wikipedia.org/wiki/List_of_programming_languages_by_type]]'' yang tersedia,  Node.js ini masih tergolong baru. Node.js [[lahir|https://en.wikipedia.org/wiki/Node.js#History]] ketika penulisnya mengkritisi pengelolaan di banyak server dimana umum terjadi kode memblok keseluruhan proses dalam kasus koneksi simultan atau menyisakan banyak tumpukan eksekusi.  

Fungsi Node.js adalah ''[[non-pemblokiran|https://en.wikipedia.org/wiki/Node.js#Overview]]'', perintah dijalankan secara bersamaan atau bahkan paralel dengan menggunakan panggilan balik (''[[Callback|https://en.wikipedia.org/wiki/Callback_(computer_programming)]]'') untuk menandakan penyelesaian atau kegagalan.

Instalasi [[node_modules|https://github.com/graphql/graphiql/issues/1090#issuecomment-566469364]] dilakukan via [[package.json|https://github.com/chetabahana/scenetree/blob/gh-pages/package.json]]. Jika Anda temukan [[SyntaxError:'sourceType: module'|https://stackoverflow.com/a/40029232/4058484]], salah satu solusinya gunakan setup [[Babel Loader|https://github.com/babel/babel-loader#install]] untuk [[Webpack|https://medium.com/@jeffrey.allen.lewis/the-ultimate-2018-webpack-4-and-babel-setup-guide-npm-yarn-dependencies-compared-entry-points-866b577da6a]].

[[<img src=https://user-images.githubusercontent.com/36441664/70690599-915d7400-1ce9-11ea-8f87-f09a9154d4e8.png>|https://medium.com/@jeffrey.allen.lewis/the-ultimate-2018-webpack-4-and-babel-setup-guide-npm-yarn-dependencies-compared-entry-points-866b577da6a]]

====Pengelolaan====

* [[Advanced Node.js Project Structure Tutorial|https://blog.codeship.com/advanced-node-js-project-structure-tutorial/]]
* [[Structure preference for a large-scale Node.js project|https://gist.github.com/lancejpollard/1398757]]
* [[How npm handles the "scripts" field|https://docs.npmjs.com/misc/scripts.html]]

[[NPM|https://en.wikipedia.org/wiki/Npm_(software)]] adalah salah satu [[pengelola paket|https://en.wikipedia.org/wiki/List_of_software_package_management_systems]] yang berbasis [[modul|https://github.com/chetabahana/tree/tree/master/deps/npm/node_modules]]. Ini adalah manajer paket default untuk lingkungan runtime JavaScript [[Diagram#Nodejs|Node.js]].

<br>[[<img src=https://user-images.githubusercontent.com/36441664/69913022-0cf72f80-1465-11ea-9229-16d1f0f5475c.png>|https://www.npmjs.com/]]

Untuk step berikut npm mendukung properti "scripts" dari file package.json:

* <code>prepublish</code>: Jalankan SEBELUM paket ini dikemas dan dipublikasikan, serta pada instalasi npm lokal tanpa argumen. (Lihat di bawah)
* <code>prepare</code>: Jalankan keduanya SEBELUM paket dikemas dan dipublikasikan, pada npm lokal instal tanpa argumen apa pun, dan ketika menginstal dependensi git (Lihat di bawah). Ini dijalankan SETELAH pra-publikasi, tetapi SEBELUM pra-publikasi Hanya.
* <code>prepublishOnly</code>: Jalankan SEBELUM paket disiapkan dan dikemas, HANYA pada npm publish. (Lihat di bawah.)
* <code>prepack</code>: jalankan SEBELUM tarball dikemas (pada paket npm, npm publish, dan ketika menginstal dependensi git)
* <code>postpack</code>: Jalankan SETELAH tarball telah dihasilkan dan dipindahkan ke tujuan akhirnya.
* <code>publish, postpublish</code>: Jalankan SETELAH paket diterbitkan.
* <code>prepublishOnly</code>: Jalankan SEBELUM paket diinstal
* <code>instal, postinstall</code>: Jalankan SETELAH paket diinstal.
* <code>preuninstall, uninstall</code>: Jalankan SEBELUM paket dihapus.
* <code>postuninstall</code>: Jalankan SETELAH paket itu dihapus.
* <code>preversion</code>: Jalankan SEBELUM menabrak versi paket.
* <code>version</code>: Jalankan SETELAH membenturkan versi paket, tetapi SEBELUM komit.
* <code>postversion</code>: Jalankan SETELAH menabrak versi paket, dan SETELAH komit.
* <code>pretest, test, posttest</code>: Dijalankan oleh perintah tes npm.
* <code>prestop, stop, poststop</code>: Dijalankan oleh perintah npm stop.
* <code>prestart, start, poststart</code>: Dijalankan oleh perintah start npm.
* <code>prerestart, restart, postrestart</code>: Dijalankan oleh perintah restart npm. Catatan: npm restart akan menjalankan skrip berhenti dan mulai jika tidak ada skrip restart yang disediakan.
* <code>preshrinkwrap, shrinkwrap, postshrinkwrap</code>: Dijalankan oleh perintah npm shrinkwrap.

===Identifikasi===

* [[Update package for commonjs import patterns|https://github.com/graphql/graphiql/issues/1090]]

[[Situs GitHub]] memungkinkan Anda untuk mengatur tampilan halaman situs di [[dunia internet|internet]] dalam satu waktu yang bersamaan walaupun file² atau [[Programming#modulasi|modul²]] yang Anda gunakan berada di banyak ''repository'' yang berlainan.

<br>[[Collections#layout|<img src=https://user-images.githubusercontent.com/36441664/82759549-62ab0400-9e18-11ea-9913-09c73d207dd6.jpg>]]

Hal ini tentu saja akan sangat membantu kita menampilkan halaman atau data yang dihasilkan oleh project yang berbeda namun dapat diintegrasikan sehingga dapat berkomunikasi satu sama lain. 

Jadi dalam menentukan identifikasi yang penting adalah mengatur tata letak ''[[Hirarki|https://en.wikipedia.org/wiki/Hierarchy]]'' nya saja. 

Sebagai analogi, pikirkan boneka Rusia yang cocok satu sama lain. Setiap tata letak cocok dengan tata letak lain yang ditentukan.

[[Mapping|<img src=https://user-images.githubusercontent.com/36441664/73657512-01bebb00-46c5-11ea-8d2c-0188b6ea075b.png width=400>]]

Ketika tata letak menentukan tata letak lain, itu berarti konten tata letak pertama akan dimasukkan ke dalam tag <code>{{content}}</code> tata letak kedua. 

====Penampilan====

* [[Structure of a NodeJS API Project|https://medium.com/codebase/structure-of-a-nodejs-api-project-cdecb46ef3f8]]
* [[Folder structure for a Node.js project|https://stackoverflow.com/questions/5178334/folder-structure-for-a-node-js-project]]

```js
├── index.html
├── js/
│   ├── main.js
│   ├── models/
│   ├── views/
│   ├── collections/
│   ├── templates/
│   └── libs/
│       ├── backbone/
│       ├── underscore/
│       └── ...
├── css/
└── 
```

Diagram berikut menunjukkan cara kerja tata letak di ''[[Jekyll/Liquid]]'' via file ''[[Collections]]'':

[[<img src=https://user-images.githubusercontent.com/36441664/67744501-41399380-fa54-11e9-90d2-c9368962dfde.png>|https://www.jekyll.com.cn/tutorials/convert-site-to-jekyll/#how-layouts-work]]

Dalam contoh ini didapatkan keteraturan tata letak seperti ini: 
# Konten dari dokumen ''Markdown'' <code>dokumen.md</code> yang menentukan <code>layout: docs</code> didorong ke tag <code>{{content}}</code> file tata letak <code>docs.html</code>. 
# Karena tata letak dokumen itu sendiri menentukan tata letak: halaman, konten dari <code>docs.html</code> didorong ke tag <code>{{content}}</code> di file tata letak <code>page.html</code>. 
# Akhirnya karena tata letak halaman menentukan <code>layout: default</code>, konten dari <code>page.html</code> dimasukkan ke tag <code>{{content}}</code> file tata letak <code>default.html</code>.

====Implementasi====
* [[Object Oriented Programming in Mathlabs: Basics|https://www.cs.ubc.ca/~murphyk/Software/matlabTutorial/html/objectOriented.html]]

Dimungkinkan juga untuk menentukan identifikasi secara global menggunakan ''[[pola glob|https://en.wikipedia.org/wiki/Glob_(programming)]]'' (berlaku terbatas pada pola yang mengandung <code>*)</code> saat mencocokkan default. 

Sebagai contoh, dimungkinkan untuk mengatur tata letak khusus untuk setiap <code>special-page.html</code> dalam subfolder dari folder <code>section</code> bagian mana saja:

[[<img src=https://user-images.githubusercontent.com/36441664/68163541-5438f000-ff8d-11e9-8402-bcbd762f11b9.png>|https://jekyllrb.com/docs/configuration/front-matter-defaults/#glob-patterns-in-front-matter-defaults]]

Dengan menerapkan ''[[Jekyll/Liquid]]'' pada project, maka Anda akan dapat setel semua pengaturan ''Korelasi'' secara global sesuai yang Anda inginkan di bagian default file [[<code>_config.yml</code>|https://github.com/chetabahana/chetabahana.github.io/blob/Chetabahana/_config.yml]]. 

Anda pun dapat memilih untuk mengabaikan pengaturan dari pasangan lingkup / nilai lain dengan menentukan ''[[Korelasi yang lebih spesifik|https://en.wikipedia.org/wiki/Correlation_and_dependence]]'' untuk lingkup tersebut.

[[Implementasi#pengembangan|<img src=https://user-images.githubusercontent.com/36441664/71577062-52bb1c80-2b25-11ea-83db-0e5484fbaa37.png width=800>]]

Identifikasi ini perlu diatur sedemikian rupa sehingga terindikasi unik pada setiap jenjang penurunan sehingga memudahkan dalam konstruksi data yang dialirkan maupun rekonstruki pewarisan. 

```json
id: 15

---+-----+-----
 1 | 1   | 15
---+-----+-----
 2 | 16  | 25
---+-----+-----
 3 | 26  | 50
---+-----+-----
 4 | 51  | 84
---+-----+-----
 5 | 85  | 99
---+-----+-----
```
Sekian.

'''SALAM Sukses!'''<br>
'''© [[Chetabahana Project|https://github.com/MarketLeader]]'''<br>
[[<img src=https://stackexchange.com/users/flair/5054985.png>|https://stackoverflow.com/users/4058484/chetabahana?tab=profile]]  

==''Referensi''==
* [[Determination of moment, shear and ductility capacities of spiral columns|https://www.researchgate.net/publication/334472177_Determination_of_moment_shear_and_ductility_capacities_of_spiral_columns_by_intelligent_system]]  
