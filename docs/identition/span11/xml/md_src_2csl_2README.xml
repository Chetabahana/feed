<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.12.0" xml:lang="en-US">
  <compounddef id="md_src_2csl_2README" kind="page">
    <compoundname>md_src_2csl_2README</compoundname>
    <title>README</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><hruler/>
 <heading level="2">Welcome to the documentation !</heading>
</para>
<para>The documentation is an interactive content, explaining a little bit more in details objects and functions in <emphasis>CSL</emphasis>. <emphasis>CSL</emphasis> is the computer algebra system embedded in <emphasis>MARTY</emphasis>, although it is logically separated and has its own manual and documentation.</para>
<para>This documentation is probably not complete. It is a work in progress, but it represents a massive amount of work and time constraints prevented me from writing a comprehensive documentation. There is still an important quantity of information you may get here, in particular on important topics about <emphasis>CSL</emphasis>.</para>
<para>If you have any question that this documentation and the manual do not answer, please feel free to ask the author: <ulink url="mailto:marty.uhlrich@gmail.com">marty.uhlrich@gmail.com</ulink>.</para>
<para>If you want to come back on <emphasis>MARTY</emphasis> main page, you can <ulink url="https://marty.in2p3.fr">click here</ulink> or click on the logo at the top of the page at any time. To get to <emphasis>MARTY</emphasis>&apos;s documentation, please <ulink url="https://marty.in2p3.fr/doc/marty/html/index.html">click here</ulink>.</para>
<para><hruler/>
 <heading level="2">Get Started with the documentation</heading>
</para>
<para>If you are in the documentation for the first time, you should already have a pretty precise idea of what <emphasis>CSL</emphasis> is doing without knowing really how. For a code overview, the manual or the initial publication are probably better.</para>
<para>It is still very valuable to learn how to navigate in the documentation, and in particular where to start. Then if you want to use a specific object in your code, the documentation is really the best help you can get as even if not all function are documented, they all appear here.</para>
<para><heading level="3">Data structures</heading>
</para>
<para>To have an idea of what information you can get here, you may be interested in the tab <ulink url="classes.html">Data Structures/Data Structure Index</ulink>. It contains all the classes (object abstractions) in <emphasis>CSL</emphasis>. You may found there what is an Expr (symbolic expression), <ref refid="classcsl_1_1Sum" kindref="compound">csl::Sum</ref>, <ref refid="classcsl_1_1Integer" kindref="compound">csl::Integer</ref>, <ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref> and more.</para>
<para><heading level="3">Files</heading>
</para>
<para>Another good starting point is to go in <ulink url="files.html">File/File List</ulink> that shows all the header files in the physics part of <emphasis>CSL</emphasis>. File names are clear and the user should be able to guess what lies inside each (at least a bit). For example, <ref refid="classcsl_1_1Cos" kindref="compound">csl::Cos</ref>, <ref refid="classcsl_1_1Exp" kindref="compound">csl::Exp</ref>, <ref refid="classcsl_1_1Sin" kindref="compound">csl::Sin</ref> are mathematical (symbolic) functions and are in the file <ref refid="mathFunctions_8h" kindref="compound">mathFunctions.h</ref>.</para>
<para><hruler/>
 <heading level="2">Useful links</heading>
</para>
<para>This part aims to give directly the links to the main features of <emphasis>CSL</emphasis>, sorted by topic.</para>
<para><heading level="3">User interface</heading>
</para>
<para>Most <emphasis>CSL</emphasis>&apos;s features are callable from class methods. The files <ref refid="interface_8h" kindref="compound">interface.h</ref> and <ref refid="interface__indicial_8h" kindref="compound">interface_indicial.h</ref> contain a number of functions directly callable, without having to know what object owns the method. All features are not reimplemented in this file, but the main ones are, and it is then a good starting point to know what you can do with <emphasis>CSL</emphasis>.</para>
<para><heading level="3">Basic expression types</heading>
</para>
<para>A mathematical expression in <emphasis>CSL</emphasis> is expressed as a pointer to an abstract base class. The pointer may point to any specialization (a sum, an integer, a product...). The ownership of an expression is shared, i.e. several expressions may own another one (a variable &apos;x&apos; may appear in several functions for example). The pointer is then a <ref refid="classstd_1_1shared__ptr" kindref="compound">std::shared_ptr</ref> that expresses the fact that the underlying ressource is shared. When the last shared_ptr pointing to a resource is deleted, this ressource is automatically destroyed.</para>
<para>In <emphasis>CSL</emphasis>, the abstract base class is <ref refid="classcsl_1_1Abstract" kindref="compound">csl::Abstract</ref> and the shared pointer to it is encapsulated in the class Expr. Both classes are in the file <ref refid="abstract_8h" kindref="compound">abstract.h</ref>. In the <ref refid="classcsl_1_1Abstract" kindref="compound">csl::Abstract</ref> class, you may see all functions callable for a variable of type Expr using expr-&gt;func(&lt;args&gt;). In the Expr type is implemented a bit of interface allowing to use operator[] for example on an expression.</para>
<para>A list of all types in <emphasis>CSL</emphasis> is in the file <ref refid="enum_8h" kindref="compound">enum.h</ref>.</para>
<para><heading level="3">Scalar expression types</heading>
</para>
<para>As we said, a mathematical expression (Expr) is a shared pointer to the base class <ref refid="classcsl_1_1Abstract" kindref="compound">csl::Abstract</ref>, but the underlying object is specialized in a valid object. These objects can be of different types (here are just the scalar types): <linebreak/>
<itemizedlist>
<listitem><para><ref refid="numerical_8h" kindref="compound">numerical.h</ref> contains numerical types.</para>
</listitem><listitem><para><ref refid="literal_8h" kindref="compound">literal.h</ref> contains literal types, i.e. <ref refid="classcsl_1_1Constant" kindref="compound">csl::Constant</ref>, <ref refid="classcsl_1_1Variable" kindref="compound">csl::Variable</ref>, and <ref refid="classcsl_1_1Imaginary" kindref="compound">csl::Imaginary</ref> (the imaginary i in expressions respecting i*i = -1).</para>
</listitem><listitem><para><ref refid="mathFunctions_8h" kindref="compound">mathFunctions.h</ref> contains mathematical function types (<ref refid="classcsl_1_1Exp" kindref="compound">csl::Exp</ref>, <ref refid="classcsl_1_1Cos" kindref="compound">csl::Cos</ref>, <ref refid="classcsl_1_1Log" kindref="compound">csl::Log</ref> etc).</para>
</listitem><listitem><para><ref refid="operations_8h" kindref="compound">operations.h</ref> contains mathematical operations: +, *, -, / and ^. Those operations are contained in the classes <ref refid="classcsl_1_1Sum" kindref="compound">csl::Sum</ref>, <ref refid="classcsl_1_1Prod" kindref="compound">csl::Prod</ref>, and <ref refid="classcsl_1_1Pow" kindref="compound">csl::Pow</ref>. There is no such thing as a - b or a / b directly, as these objects may be represented by sums, products and exponents only. No need for other objects. In the cases presented here, there is just a + (-1)*b and a * b^(-1).</para>
</listitem></itemizedlist>
</para>
<para><heading level="3">Tensorial expression types</heading>
</para>
<para>Expressions may be tensorial as well, i.e. carrying indices.<itemizedlist>
<listitem><para><ref refid="index_8h" kindref="compound">index.h</ref> contains the <ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref> and <ref refid="classcsl_1_1IndexStructure" kindref="compound">csl::IndexStructure</ref> classes. The first is simply the internal representation of an index, and the second of an index list, that is the set of indices for a given tensor.</para>
</listitem><listitem><para><ref refid="classcsl_1_1TensorElement" kindref="compound">csl::TensorElement</ref> is the specialization of <ref refid="classcsl_1_1Abstract" kindref="compound">csl::Abstract</ref> for a generic indexed tensor.</para>
</listitem><listitem><para><ref refid="classcsl_1_1TensorParent" kindref="compound">csl::TensorParent</ref> is the parent object, unique in the program for each tensor, that contains all the properties of the tensor. Each element keeps a pointer to its parent to access its properties and do not carry them itself. This allows to have only one copy of a tensor&apos;s properties in the program rather than for all tensor instances in mathematical expressions.</para>
</listitem><listitem><para><ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref> is a shared pointer to <ref refid="classcsl_1_1TensorParent" kindref="compound">csl::TensorParent</ref>. It follows the same principle as the Expr class for <ref refid="classcsl_1_1Abstract" kindref="compound">csl::Abstract</ref>, and it is the object the user will manipulate as tensor parent.</para>
</listitem><listitem><para><ref refid="classcsl_1_1ISum" kindref="compound">csl::ISum</ref> is a specialization of <ref refid="classcsl_1_1Sum" kindref="compound">csl::Sum</ref> to handle indicial expressions. It checks in particular if the different terms have the same free index structure.</para>
</listitem><listitem><para><ref refid="classcsl_1_1IProd" kindref="compound">csl::IProd</ref> is a specialization of <ref refid="classcsl_1_1Prod" kindref="compound">csl::Prod</ref> to handle indicial expressions. It takes care of contracting all repeted indices whenever it is necessary to keep expressions well-formed.</para>
</listitem></itemizedlist>
</para>
<para><heading level="3">Expression modifiers</heading>
</para>
<para>Expressions may of course be modified by <emphasis>CSL</emphasis>. You may call at any moment member functions of the obecjt you manipulate, but also interface functions doing specific actions on expressions:<itemizedlist>
<listitem><para><ref refid="utils_8h" kindref="compound">utils.h</ref> contains functions to copy, refresh expressions, as well as functions replacing parts of expressions, indices, in a bigger one.</para>
</listitem><listitem><para><ref refid="interface_8h" kindref="compound">interface.h</ref> contains functions to factor, expand expressions, and more.</para>
</listitem><listitem><para><ref refid="algo_8h" kindref="compound">algo.h</ref> contains algorithms that walk through mathematical expressions, applying a user-defined function on every sub-expression. Algorithms are very practical when <emphasis>CSL</emphasis> built-in functions are not enough to do what the user wants to do.</para>
</listitem></itemizedlist>
</para>
<para><heading level="3">Options</heading>
</para>
<para>Several general options can be found in the file <ref refid="options_8h" kindref="compound">options.h</ref>. </para>
    </detaileddescription>
    <location file="src/csl/README.md"/>
  </compounddef>
</doxygen>
