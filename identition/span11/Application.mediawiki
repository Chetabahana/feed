Application (aplikasi) adalah perangkat lunak yang dibuat dengan algoritma untuk mengerjakan tugas-tugas tertentu.

__TOC__

==Konsep==
* [[Millennium Prize: P vs NP|https://theconversation.com/millennium-prize-p-vs-np-4246]]

Pada bagian ini kita akan bahas tentang algoritma pada aplikasi dan kaitannya dengan ''[[Implementasi#kelompok|Masalah P = NP]]'' yang mungkin adalah masalah terbuka yang paling penting saat ini.

<br>[[<img src=https://user-images.githubusercontent.com/36441664/84323196-8ef8ab80-aba0-11ea-8483-6aa7973ce90d.png>|https://github.com/MarketLeader/application/wiki]]

Pada 1930-an, Alan Turing menunjukkan ada tugas-tugas dasar yang tidak mungkin dicapai dengan cara algoritmik. Dalam istilah modern, yang ditunjukkannya adalah bahwa tidak ada program komputer umum yang menjawab ya atau tidak terhadap pertanyaan apakah program komputer lain pada akhirnya akan berhenti ketika dijalankan.

Kegagalan yang luar biasa dari Masalah Pemutusan ini mengandung kehalusan yang lebih membingungkan. Meskipun kita tidak memiliki cara untuk mengetahui terlebih dahulu apakah suatu program akan berhenti, pada prinsipnya ada cara yang jelas untuk menunjukkan bahwa itu berhenti jika itu adalah program penghentian: jalankan, tunggu, dan saksikan ia berhenti!

Dengan kata lain, Turing menunjukkan bahwa, pada tingkat terluas, memutuskan apakah pernyataan itu benar secara komputasi lebih sulit daripada menunjukkan bahwa itu benar ketika itu.

; Pertanyaan efisiensi
Pekerjaan Turing adalah momen penting dalam sejarah komputasi. Sekitar 80 tahun kemudian, perangkat komputasi telah merasuki hampir setiap segi masyarakat. Asli Turing "apa yang bisa dihitung?" pertanyaan sebagian besar telah digantikan oleh yang lebih relevan, "apa yang dapat dihitung secara efisien?"

Tetapi sementara Masalah Turing Turing dapat dibuktikan tidak mungkin dalam beberapa garis magis, batas antara "efisien" dan "tidak efisien" tampaknya jauh lebih sulit dipahami. P versus NP adalah yang paling terkenal dari sejumlah besar pertanyaan yang belum terselesaikan yang muncul dari pandangan modern terhadap pertanyaan Turing.

; Jadi apa hal NP ini?
Secara kasar, P (singkatan dari " polinomial time "), berhubungan dengan kumpulan masalah komputasi yang memiliki solusi efisien. Ini hanya formulasi abstrak "efisien", tetapi ia bekerja cukup baik dalam praktiknya.

NP kelas berhubungan dengan masalah yang, ketika jawabannya adalah "ya", ada demonstrasi yang efisien bahwa jawabannya adalah ya ("N" adalah singkatan dari "nondeterministic", tetapi deskripsi yang diambil di sini lebih intuitif). P versus NP hanya menanyakan apakah kedua kelas masalah komputasi ini sama.

Ini hanya masalah "memutuskan versus mendemonstrasikan" dalam Masalah Puting asli Turing, tetapi dengan kondisi efisiensi tambahan.

; Teka-teki
P jelas tidak terlihat sama dengan NP. Teka-teki adalah contoh bagus dari intuisi umum di sini. Teka-teki silang sangat populer karena merupakan tantangan untuk menemukan solusinya, dan manusia menyukai tantangan. Tapi tidak ada yang menghabiskan waktu makan siang mereka memeriksa teka-teki silang yang sudah lengkap: memeriksa solusi orang lain tidak menawarkan tantangan yang sama.

Bahkan yang lebih jernih adalah Sudoku: sekali lagi ini adalah tantangan sejati untuk dipecahkan, tetapi memeriksa solusi yang ada untuk kebenarannya begitu rutin sehingga tidak memiliki nilai hiburan.

Kemungkinan P = NP seperti menemukan bahwa bagian "menemukan" dari teka-teki ini hanya memiliki kesulitan yang sama dengan bagian "memeriksa". Itu sepertinya sulit dipercaya, tapi sebenarnya kita tidak tahu pasti.

Intuisi yang sama ini meliputi banyak sekali tugas komputasi penting yang saat ini kita tidak memiliki algoritma yang efisien. Salah satu fitur yang sangat menggoda adalah bahwa, lebih sering daripada tidak, masalah-masalah ini dapat ditunjukkan secara maksimal sulit di antara masalah NP.

Masalah yang disebut " NP-complete " ini adalah kasus uji untuk P versus NP: jika salah satu dari mereka memiliki solusi algoritme yang efisien maka mereka semua melakukannya (dan pemeriksaan yang efisien tidak lebih sulit daripada penemuan yang efisien).

Tetapi jika bahkan hanya satu yang dapat terbukti tidak memiliki solusi yang efisien, maka P tidak sama dengan NP (dan temuan yang efisien sebenarnya, secara umum, lebih sulit daripada pengecekan yang efisien).

Berikut adalah beberapa contoh klasik dari masalah NP-complete.

; Partisi (dilema alien pick-pocket)
Di planet asing, dua kantong pencuri mencuri dompet. Untuk membagikan hasil, mereka harus membagi uang secara merata: dapatkah mereka melakukannya? Mata uang standar Earth berevolusi untuk memiliki nilai koin yang dirancang untuk membuat tugas ini mudah, tetapi secara umum tugas ini selesai NP. Ada dalam NP karena, jika ada pembagian koin yang sama, ini dapat dengan mudah ditunjukkan dengan hanya menunjukkan pembagian itu. (Menemukan itu adalah bagian yang sulit!)

; Penjadwalan
Menemukan jika ada jadwal bebas-bentrok adalah NP-lengkap. Masalahnya ada di NP karena kita dapat secara efisien memeriksa jadwal yang benar, bebas bentrok untuk bebas bentrok.

; Travelling Salesman
Seorang penjual keliling harus mengunjungi masing-masing dari sejumlah kota. Untuk menghemat biaya, penjual ingin menemukan rute terpendek yang melewati semua kota. Untuk beberapa jarak target tertentu "n", apakah ada rute panjang paling banyak "n"?

; Bukti singkat
Apakah ada bukti singkat untuk pernyataan matematika favorit Anda (mungkin masalah Hadiah Milenium)? Dengan rumusan "pendek" yang sesuai, ini adalah NP-lengkap. Ada dalam NP karena memeriksa bukti formal dapat dilakukan secara efisien: bagian yang sulit adalah menemukannya (setidaknya, kita pikir itu bagian yang sulit!).

Dalam setiap kasus, kita tahu tidak ada algoritma pasti yang efisien, dan tidak adanya algoritma seperti itu setara dengan membuktikan P tidak sama dengan NP.

Jadi, apakah kita sudah dekat dengan solusi? Tampaknya yang terbaik yang kita tahu adalah bahwa kita tidak tahu banyak! Dapat diperdebatkan, kemajuan paling substansial dalam saga P versus NP secara aneh negatif: mereka kebanyakan menunjukkan bahwa kita tidak mungkin berharap untuk menyelesaikan P sebagai berbeda dengan NP dengan teknik yang sudah dikenal.

Kita tahu pendekatan Turing tidak bisa bekerja. Pada tahun 2007, Alexander Razborov dan Steven Rudich dianugerahi Hadiah Gödel (sering disebut-sebut sebagai Hadiah Nobel Ilmu Komputer) untuk karya mereka yang menunjukkan bahwa tidak ada "bukti alami" yang dapat membuktikan P tidak setara dengan NP.

Tentu saja, kita akan terus mencari!

===Model===
* [[What makes P vs. NP problem “MILLENNIUM!” ?|https://medium.com/@dhyaneshparekh222ddp/what-makes-p-vs-np-problem-millennium-6cd81b173fd]]

P adalah polinomial dan NP adalah polinomial non-deterministik. Dalam istilah yang lebih sederhana, P berarti masalah yang mudah dipecahkan oleh komputer, dan NP berarti masalah yang tidak mudah dipecahkan komputer tetapi mudah diperiksa. 

<br>Contohnya adalah menemukan bilangan prima, Mudah untuk memeriksa apakah bilangan tersebut prima atau tidak, tetapi sangat sulit untuk menentukan angka-angka itu karena sampai saat ini distribusinya masih berupa dugaan saja ([[Branching|Hipotesa Riemann]]). 

Untuk beberapa pertanyaan praktis yang menarik dari jenis ini, kita tidak memiliki cara untuk menemukan jawaban dengan cepat, tetapi jika kita diberikan jawaban, adalah mungkin untuk memeriksa itu dan memverifikasi jawabannya dengan cepat. 

[[https://user-images.githubusercontent.com/36441664/84532586-b2daff00-ad10-11ea-9880-ff7e97858cd3.gif]]

Dengan cara ini, masalah NP dapat dianggap sebagai seperti teka-teki: mungkin sulit untuk menemukan jawaban atas sebuah teka-teki, tetapi begitu seseorang mendengar jawabannya, jawabannya tampak jelas. 

Dalam perbandingan (analogi) ini, pertanyaan dasarnya adalah: apakah teka-teki benar-benar sekeras yang kita pikirkan, atau apakah kita kehilangan sesuatu? 

Masalah ini pertama kali diangkat oleh ahli matematika Austria-Amerika Kurt Gödel yang membingungkan. Kemudiam dirumuskan oleh Stephen Cook pada tahun 1971. 

[[https://user-images.githubusercontent.com/36441664/85101079-c532cc80-b22b-11ea-86a1-49ddf8b18a71.jpg]]

Setelan distribusi yang seragam atas input ukuran mungkin tidak memodelkan realitas dengan baik, atau perlu didefinisikan. Misalnya, pengurutan cepat diketahui memiliki kompleksitas rata-rata yang baik tetapi berkinerja sangat buruk pada daftar yang sudah disortir.

[[<img src=https://user-images.githubusercontent.com/36441664/85101045-b3e9c000-b22b-11ea-99af-36efc909accc.jpeg>]]

Namun, dalam praktiknya kita sering mengerjakan daftar yang disortir. Jadi hal ini tidak hanya merupakan pertanyaan yang sangat teoretis dalam ilmu komputer dan matematika, tetapi juga memiliki implikasi besar terhadap dunia nyata. 

[[https://user-images.githubusercontent.com/36441664/84533715-e880e780-ad12-11ea-8e87-f3192bafa4b0.png]]

Masalah ini kemudian dianggap oleh banyak orang sebagai masalah terbuka terpenting dalam bidang ilmu komputer.

Resolusi ini dapat merevolusi dunia. 

Beberapa algoritma diketahui memiliki kompleksitas rata-rata berbeda dalam waktu kasus-terburuknya yang dibatasi oleh fungsi [[polinomial|https://id.m.wikipedia.org/wiki/Polinomial]] jika melebihi ukuran input waktu yang dibutuhkan ''[[Mesin Turing|https://en.m.wikipedia.org/wiki/Turing_machine]]'' untuk berhenti. 

[[https://user-images.githubusercontent.com/36441664/85101052-b64c1a00-b22b-11ea-973c-5e7225bdaf90.png]]

Pernyataan terperinci masalah P versus NP diperkenalkan pada tahun 1971 oleh Stephen Cook dalam makalah seminarnya “[[Kompleksitas prosedur pembuktian teorema|https://github.com/chetabahana/skema/files/4788101/Lecture27_ho.pdf]]”:

[[https://user-images.githubusercontent.com/36441664/84744560-a5a66480-afdd-11ea-87ed-4cdedd1b08fe.jpg]]

----
[[https://user-images.githubusercontent.com/36441664/84807279-35293300-b031-11ea-90e5-1a7b36cf08ab.jpg]]
----
[[https://user-images.githubusercontent.com/36441664/84807316-3f4b3180-b031-11ea-8d60-4d0a1a8a12cb.jpg]]
----
[[https://user-images.githubusercontent.com/36441664/84807335-496d3000-b031-11ea-9445-34f1ff79b4f6.jpg]]
----
[[https://user-images.githubusercontent.com/36441664/84807359-50943e00-b031-11ea-952b-299a0cf43ad2.jpg]]
----
[[https://user-images.githubusercontent.com/36441664/84807376-568a1f00-b031-11ea-8176-6998e52c2802.jpg]]
----
[[https://user-images.githubusercontent.com/36441664/84807386-5d189680-b031-11ea-9b86-b706adce34fe.jpg]]
----

====Track====

Berikut ini akan diuraikan definisi dan hasil utama ''P = NP''. Detilnya Anda bisa ikuti pada artikel yang berjudul: ''[[P versus NP: A Crucial Open Problem|http://www.science4all.org/article/pnp/]]''.

; Simbol "P"
Mari kita mulai dengan memahami simbol '''''P''''' ini. 

''<blockquote>'''P''' mewakili sekumpulan masalah keputusan yang dapat diselesaikan dengan mesin '''Turing deterministik''' dengan '''kompleksitas waktu polinomial''' dalam '''kasus terburuk'''.</blockquote>

; Masalah Keputusan
Masalah keputusan adalah pertanyaan yang memperhitungkan input dan yang jawabannya adalah ya atau tidak. 

<br>Misalnya, masalah "Apakah elemen-elemen array berbeda?" 

Ini adalah masalah keputusan yang memperhitungkan array sebagai input, dan yang jawabannya adalah ya atau tidak. Sederhana bukan?

; Mesin Turing Deterministik
Mesin Turing deterministik atau biasa disebut ''Mesin Turing'' adalah mesin dengan algoritma yang biasanya kita definisikan (dengan tes "if", loop "while" dan "for", dan rekursi). 

<br>[[<img src=https://user-images.githubusercontent.com/36441664/84648825-c1ebc800-af2f-11ea-88d5-9446b711cfe5.png width=500>|https://en.m.wikipedia.org/wiki/Nondeterministic_Turing_machine]]

Meskipun tidak semua algoritma sesuai dengan mesin Turing, sebagian besar algoritma yang kita gunakan atau tulis di komputer sesuai dengan definisi mesin Turing.

Mesin Turing dapat dipahami sebagai satu set keadaan yang memungkinkan transisi antar kondisi sesuai dengan operasi dasar. 

Pada setiap langkah algoritma, tergantung pada kondisi saat ini dan pada input yang sedang dibaca oleh mesin, transisi menuju status berikutnya diambil. 

Algoritma pertemanan Sheldon berikut dapat digambarkan sebagai mesin Turing, di mana area biru adalah status dan transisi diwakili oleh panah:

[[https://user-images.githubusercontent.com/36441664/84599529-e480d100-ae9c-11ea-8166-385a1f7bcaa4.png]]

Ada beberapa kondisi spesifik. Salah satunya adalah kondisi awal. Dalam algoritma Sheldon, keadaan awal adalah keadaan di kiri atas yang disebut "Panggilan Telepon". Kemudian, ada negara yang dikenal sebagai negara bagian terakhir atau negara penerima. 

Pada contoh ini, algoritma selesai. Hasil algoritma ditentukan oleh kondisi akhir yang akhirnya akan tercapai. Hasil ini merujuk pada status "Mulailah Frienship" dan "Partake in Interest" dalam masalah keputusan. 

Pada beberapa tempat akan merujuk ke jawaban "benar", dan yang lain untuk jawaban "salah".

====Batas====

Akankah transisi selalu mengarah ke kondisi akhir?
Tidak. Lihatlah algoritma persahabatan Sheldon misalnya. Jika tidak memiliki jumlah loop, itu mungkin tetap dalam loop ini tanpa batas. Faktanya, mengetahui apakah suatu algoritma akan mencapai kondisi akhir adalah masalah yang sulit. Memang, pada akhir 1930-an, Alan Turing, pendiri ilmu komputer modern, telah membuktikan bahwa tidak ada mesin Turing yang, mengingat mesin Turing dan input, dapat menentukan apakah mesin Turing akan selesai dengan input. Secara setara, kita mengatakan bahwa menentukan apakah mesin Turing akan berhenti dengan input apa pun tidak dapat ditentukan. Masalah ini dikenal sebagai masalah penghentian dan merupakan kasus teorema Rice. Teorema ini mengatakan bahwa masalah non-sepele tidak dapat diputuskan. Tapi ini semakin rumit dan saya tidak akan memikirkan itu.

[[https://user-images.githubusercontent.com/36441664/84532777-03eaf300-ad11-11ea-8d13-3aa52d07af23.jpg]]

Saya tidak benar-benar melihat hubungan antara mesin Turing dan komputer ...
Komputer dapat dimodelkan dengan mesin Turing. Memang, setiap keadaan dari seluruh memori komputer dapat dimodelkan dengan keadaan di mesin Turing. Sekarang, pada setiap langkah algoritma yang dijalankan pada komputer, memori dan input dibaca, dan, berdasarkan instruksi yang diberikan, keputusan untuk menimpa memori diambil. Ini mengarah ke keadaan memori yang baru. Dengan demikian, keputusan untuk menimpa sesuai dengan transisi.

===Histori===

Ini sedikit tentang mesin Turing. Seperti Alan Turing membuktikannya, ada mesin Turing, yang disebut mesin Turing universal, sehingga, mesin Turing lainnya dapat disimulasikan oleh mesin Turing universal, dengan menulis instruksi pada input. Untuk komputer, ini sesuai dengan mengatakan bahwa bahasa pemrograman seperti C ++ atau Java adalah mesin Turing universal. Anda dapat menulis instruksi, menambahkan input, dan memberikannya ke bahasa-bahasa tersebut untuk menjalankan algoritma apa pun.

Fakta penting adalah bahwa komputer dapat dipahami sebagai mesin Turing. Jadi, algoritma yang biasanya kita tulis termasuk dalam definisi P.

Saya kira saya mendapatkan apa itu mesin Turing ... Sekarang, apa kompleksitas waktu polinomialnya?
Nah, untuk itu saya pertama-tama perlu berbicara tentang ukuran input dan waktu yang dibutuhkan untuk menyelesaikan suatu algoritma ...

====Koleksi====

Kedua konsep itu tampaknya cukup sederhana ... Maksud saya, ukuran input adalah jumlah byte, bukan?
Ya, ukuran input sering diukur dalam byte. Tetapi dalam banyak kasus, kita lebih suka menggambarkan ukuran input dengan angka yang sebanding dengan ukuran dalam byte. Misalnya, dalam kasus array, ukuran input dapat dianggap sebagai jumlah elemen array. Entah representasi setara dengan definisi yang akan kita lihat.

Dan saya kira waktunya tidak diukur dalam hitungan detik ...
Masalah dengan mengukur waktu dalam hitungan detik adalah waktu yang dibutuhkan suatu algoritma untuk menyelesaikannya sangat tergantung pada kekuatan prosesor Anda. Dan itu tidak semua, seperti komputer sekarang muli-tugas segalanya, jika Anda menjalankan suatu algoritma dengan input yang sama dua kali pada komputer yang sama, mungkin tidak akan membutuhkan jumlah detik yang sama untuk menyelesaikannya. Itu sebabnya, ketika memungkinkan, kita lebih suka mengukur adalah jumlah operasi dasar (tes, penambahan ...) yang dilakukan oleh komputer. Waktu lain ini hampir sebanding dengan waktu aktual dalam detik, dan setara dengan definisi yang akan kita lihat.

OK, jadi sekarang Anda dapat memberi tahu kita apa arti kompleksitas waktu polinomial ...
Iya! Mesin Turing memiliki kompleksitas waktu polinomial jika ada polinomial sedemikian rupa sehingga untuk setiap input ukuran, waktu yang dibutuhkan mesin Turing untuk berhenti kurang dari . Dalam hal ini, kita akan tahu pasti bahwa algoritma akan selesai dalam jumlah waktu yang wajar untuk input apa pun. Ini sesuai dengan mengatakan bahwa bahkan dalam kasus terburuk, waktu kompleksitas adalah polinomial dalam ukuran input.

====Korelasi====

Saya kira Anda sekarang memiliki semua informasi untuk memahami masalah keputusan apa yang dapat diselesaikan oleh mesin Turing dengan kompleksitas waktu polinomial dalam kasus terburuk.

Saya kira ... Bisakah Anda memberi contoh? Hanya untuk memastikan saya mendapatkannya ...
Tentu! Alih-alih meminta orang lain untuk membuat saran satu per satu, Sheldon dapat meminta orang lain untuk memberikan daftar saran. Namun, Sheldon agak gila, jadi dia akan memastikan bahwa orang lain itu tidak mengacaukannya. Misalnya, ia mungkin ingin memastikan bahwa semua saran berbeda satu sama lain.

Masalah pengujian apakah elemen daftar semuanya berbeda ada di P. Pertama, ini masalah keputusan. Kemudian, mari pertimbangkan algoritma berikut. Kita akan mempertimbangkan setiap pasangan elemen dari daftar. Jika dua elemen dari setiap pasangan berbeda satu sama lain, maka jawabannya akan "benar".

Bagaimana kita bisa mendaftar semua pasangan daftar?
Nah, cara biasa adalah memberi perintah kepada elemen-elemen daftar. Kemudian, kita akan mempertimbangkan kecocokan setiap elemen dengan setiap pengikutnya di daftar. Berikut ini adalah representasi grafis dari itu, di mana setiap baris sesuai dengan pasangan.

[[https://user-images.githubusercontent.com/36441664/84599526-e3e83a80-ae9c-11ea-97fb-b3120f2e629c.png]]

Algoritma ini menjawab pertanyaan. Selain itu, jika ada elemen dalam daftar, karena ada  pasang daftar, kita harus melakukan paling banyak iterasi, dengan satu operasi dasar per iterasi (tes apakah yang pertama berbeda dari yang terakhir). Dengan demikian, jumlah operasinya kurang dari. Dengan demikian, algoritma ini polinomial. Dengan demikian, masalah keputusan ini dapat diselesaikan dengan mesin Turing dalam waktu polinomial dalam kasus terburuk: Ada dalam P.

===Formasi===

; NP
Sekarang mari kita bicara tentang dua simbol terakhir: NP.

Saya kira NP berarti "Non-polinomial", bukan?
Tidak! Meskipun "N" berarti "Non" dan "P" untuk "Polinomial", "NP" adalah Polinomial Non-deterministik. Ini adalah serangkaian masalah keputusan yang, jika jawabannya benar, dapat diselesaikan dengan mesin Turing non-deterministik dalam waktu polinomial dalam kasus terburuk.

====Resolusi====
Apa itu mesin Turing non-deterministik?

Mesin Turing non-deterministik sangat mirip dengan mesin Turing deterministik, tetapi memiliki beberapa perbedaan. Terutama, ini memungkinkan, diberikan keadaan dan input, transisi menuju beberapa keadaan atau tidak sama sekali. Jika ada jalur yang menggunakan transisi ini dari kondisi awal ke kondisi akhir, maka mesin mengembalikan "true". Karena itu, mesin Turing non-deterministik sangat berbeda dari mesin Turing. Jawabannya tidak dibaca pada keadaan akhir tercapai karena mungkin ada beberapa keadaan akhir yang dapat dicapai. Jika jawaban ditemukan, itu pasti "benar".

====Interaksi====

Berbeda dengan mesin Turing deterministik yang dapat digambarkan sebagai jalur dari kondisi awal ke kondisi akhir melalui kondisi perantara menggunakan transisi, mesin Turing non-deterministik tidak dapat digambarkan sebagai jalur. Perlu dipertimbangkan sebagai arborescence, yaitu struktur di mana masing-masing negara memiliki nol, satu atau beberapa "anak" negara (meskipun itu bukan arborescence dalam arti teori grafik karena mungkin ada beberapa jalur dari root ke suatu negara, atau karena ada siklus). Secara ekuivalen, jawaban yang diberikan oleh mesin Turing deterministik adalah "benar" jika ada keadaan akhir di punjung. Gambar berikut adalah representasi dari arborescence dari mesin Turing non-deterministik.

[[https://user-images.githubusercontent.com/36441664/84599525-e2b70d80-ae9c-11ea-81dd-a30888da7eaf.png]]

==Kendala==
* [[P and NP Problem - CMI Official Problem Description (Pdf) |http://www.claymath.org/sites/default/files/pvsnp.pdf]]

<br>[[https://user-images.githubusercontent.com/36441664/84532749-f9305e00-ad10-11ea-9833-46bd8545dabf.jpg]]

Seperti yang Anda lihat, status dapat memiliki nol, satu atau beberapa transisi. Dalam contoh ini, karena ada keadaan akhir di arborescence, jawabannya adalah "benar".

Mesin non-deterministik dapat dipahami sebagai mesin yang melakukan masing-masing kemungkinan transisi secara bersamaan (dengan, misalnya, bercabang ke mesin lain yang serupa) dan selesai segera setelah salah satu jalur transisi menemukan keadaan akhir. Mereka juga dapat dipahami sebagai penebak keberuntungan yang akan selalu memilih transisi yang tepat, untuk mencapai secepat mungkin keadaan akhir.

Untuk input yang jawabannya "benar", kita dapat mendefinisikan kompleksitas waktu sebagai jumlah transisi dari jalur terpendek menuju kondisi akhir. 

[[<img src=https://user-images.githubusercontent.com/36441664/84744218-257fff00-afdd-11ea-902f-721eb68eb8d1.jpg>]]

Demikian pula dengan P, kita dapat mendefinisikan serangkaian masalah sedemikian sehingga ada mesin Turing non-deterministik yang menjawab dengan benar dengan kompleksitas waktu yang dibatasi oleh fungsi polinomial dari ukuran input. Masalah seperti itu disebut polinomial non-deterministik, yaitu mereka ada di NP.

Waw ... Ini semakin rumit ...

[[<img src=https://user-images.githubusercontent.com/36441664/68235749-5c993580-0036-11ea-8f3b-8da3496c329e.jpg width=800>|https://github.com/MarketLeader/Cloud-Tasks-API/wiki]]

[[<img src=https://user-images.githubusercontent.com/36441664/70703416-b4485200-1d02-11ea-9db1-41ba6e9fe2a9.png width=800>|https://github.com/MarketLeader/Google-Trend-API/wiki]]

[[<img src=https://user-images.githubusercontent.com/36441664/69991542-787ef100-157a-11ea-85d5-20907c99b5d7.png>|https://github.com/MarketLeader/Google-Trend-API/wiki]]

[[<img src=https://user-images.githubusercontent.com/36441664/69991227-e4ad2500-1579-11ea-8b4a-ff5a5c8aa61f.png width=800>|https://github.com/MarketLeader/Google-Ads-API/wiki]]

[[<img src=https://user-images.githubusercontent.com/36441664/69991764-e4f9f000-157a-11ea-8062-36419bc7479f.png width=800>|https://github.com/MarketLeader/Cloud-Site-API/wiki]]

[[<img src=https://user-images.githubusercontent.com/36441664/69990325-04434e00-1578-11ea-9e5a-c86bd88fe706.png width=800|https://github.com/MarketLeader/Toko-Chetabahana/wiki]]

===Atribut===

Untungnya, ada tautan menarik antara mesin Turing yang non-deterministik dan deterministik yang dapat membantu kits mengatasi masalah NP. Untuk satu hal, setiap masalah yang dapat diselesaikan dengan mesin Turing non-deterministik dapat diselesaikan dengan mesin Turing. Selain itu, masalah dalam P juga di NP.

Tapi bukan itu saja! Hasil yang paling penting adalah sebagai berikut. Masalahnya adalah NP jika dan hanya jika, untuk input apa pun, ada satu set subproblem keputusan yang terbatas (tetapi berpotensi besar) yang ada di P, sehingga jawaban dari masalah itu benar setiap kali jawaban dari semua subproblem keputusan benar juga .

Bisakah Anda memberi contoh?

Misalkan Sheldon tidak tahu apa kegiatan yang diusulkan. Dia harus pergi ke setiap tempat untuk melihat apa itu dan bagaimana mereka bekerja. Namun dia hanya punya $ 50 untuk taksi. Masalahnya adalah mencari tahu apakah dia akan dapat mengunjungi semua tempat itu.

[[https://user-images.githubusercontent.com/36441664/84532747-f897c780-ad10-11ea-94f9-081d76022cce.png]]

Gambar sebelumnya menampilkan tempat yang berbeda dan biaya taksi dari masing-masing tempat. Garis merah adalah perjalanan yang memungkinkan bagi Sheldon. Namun, biaya perjalanan merah 3 + 15 + 11 + 23 + 9 + 3 = 64 dolar. Karena Sheldon hanya memiliki $ 50, itu adalah perjalanan yang tidak dapat ia lakukan.

Mengapa NP masalah ini?

====Trace====

Untuk mengetahui apakah dia dapat mengunjungi semua tempat hanya dengan $ 50, dia dapat menguji semua perjalanan yang melewati setiap tempat. Karena ada sejumlah perjalanan terbatas yang melewati setiap tempat, dan sebagai pengujian apakah perjalanan layak dengan $ 50 dapat dilakukan dengan sangat cepat (dengan menambahkan semua biaya taksi dan membandingkan totalnya dengan $ 50 ), masalah ini masuk dalam definisi yang setara masalah NP. Karena itu NP. Bukan berarti ini algoritma yang secara bersamaan mencoba semua perjalanan sebenarnya bukan algoritma yang dilakukan oleh mesin Turing deterministik.

[[https://user-images.githubusercontent.com/36441664/84599523-e0ed4a00-ae9c-11ea-86e6-a672ee20c30f.png]]

Masalah Sheldon sebenarnya adalah contoh dari masalah keputusan salesman keliling . Masalah ini terdiri lebih umum dari memutuskan apakah ada jalan yang dimulai dan berakhir di rumah, dan melewati semua titik perantara sehingga total biaya perjalanan kurang dari beberapa nilai. Inputnya adalah himpunan titik menengah dan biaya taksi antara dua titik.

Perhatikan bahwa kita dapat memodifikasi algoritme dengan secara berurutan menguji semua perjalanan. Algoritma yang kita peroleh adalah mesin Turing deterministik. Tetapi tidak dalam P. Sebenarnya, jika ada tempat untuk dikunjungi, lalu ada cara bepergian melalui setiap tempat. Dalam contoh kita dengan hanya 5 tempat untuk dikunjungi, algoritme ini membutuhkan 120 tes! Faktanya,tidak dapat dibatasi oleh polinomial apa pun. Ini membuktikan bahwa algoritma tersebut tidak polinomial.

====Metoda====

Masalah perutean kendaraan membentuk varian varian kelas besar untuk keliling penjual keliling, dan memiliki banyak aplikasi yang melibatkan jutaan dolar!

Juga perhatikan bahwa dalam banyak artikel, karena penyalahgunaan bahasa, masalah non-keputusan kadang-kadang dikategorikan ke dalam masalah P (atau kelas masalah keputusan lainnya) yang seharusnya menjadi masalah keputusan saja. Ini biasanya berarti bahwa pemecahan masalah dapat dilakukan dalam waktu polinomial (atau dalam waktu yang sama dengan masalah keputusan kelas yang disebutkan). Namun, perlu diketahui bahwa mengenai masalah NP, banyak artikel hanya membuat kesalahan dan menulis misalnya bahwa masalah salesman keliling adalah NP. Karena definisi spesifik NP, hanya masalah keputusan yang benar-benar dapat dianggap NP!

[[https://user-images.githubusercontent.com/36441664/84623744-1b410080-af0a-11ea-978b-e1fd1961985d.jpg]]

Jadi masalah P = NP terdiri dari ...

Ingin tahu apakah ada masalah dalam NP juga dalam P, yaitu jika masalah NP dapat diselesaikan dalam waktu polinomial dengan mesin Turing deterministik. Seperti yang saya katakan, ini adalah masalah terbuka utama ... dan saya tidak akan menjadi orang dengan jawabannya! Tetapi jika Anda ingin mencobanya, Anda harus tahu tentang konsep seperti NP-hard atau NP-complete.

[[https://user-images.githubusercontent.com/36441664/84744030-ebaef880-afdc-11ea-8561-717ad38e4329.jpg]]

===Artifact===

; NP-hard, NP-complete
Dalam teori kompleksitas, masalah A dikatakan lebih sulit daripada masalah B, jika B dapat diselesaikan dengan menggunakan sejumlah operasi dasar polinom dan dengan menggunakan jumlah polinomial beberapa kali solusi untuk A. Secara setara, kita mengatakan bahwa A lebih sulit daripada B, jika, ketika kita mengasumsikan bahwa ada operasi dasar yang memecahkan A, B dapat diselesaikan dalam waktu polinomial. Dalam definisi setara kedua ini, operasi dasar yang memecahkan A disebut oracle untuk A.

Bisakah Anda memberi contoh?

Mari kita tunjukkan bahwa masalah menemukan biaya perjalanan terkecil (sebut saja masalah A) sama sulitnya dengan masalah mengetahui apakah ada kemungkinan perjalanan dengan jumlah uang tertentu (sebut saja masalah B dan perhatikan bahwa itu adalah Sheldon masalah yang kita jelaskan), ketika biaya taksi semuanya bilangan bulat (itu akan benar tanpa asumsi ini, tetapi kita akan menambahkannya untuk mempermudah). Pertama jika kita dapat menemukan A dalam satu operasi dasar, penyelesaian B dapat dilakukan dengan membandingkan jumlah uang dengan biaya perjalanan terkecil. Jadi, A lebih sulit daripada B.

====Delivery====

Mari kita sekarang menunjukkan bahwa B lebih sulit daripada A. Kita tahu bahwa biaya perjalanan terkecil adalah antara 0 dan jumlah biaya taksi antara 2 poin. Jadi kita bisa menggunakan pencarian dikotomikuntuk menemukan biaya perjalanan terkecil. Pada setiap langkah, kita tahu bahwa biaya terkecil adalah antara dua nilai. Kita mempertimbangkan cara dua nilai. Kiya menerapkan oracle B untuk mengetahui apakah nilai yang diuji lebih tinggi atau lebih rendah dari biaya terkecil lebih tinggi atau lebih rendah dari nilai yang diuji. Kita kemudian menyesuaikan interval kits di mana kita tahu biaya terkecil. Dengan menerapkan pencarian dikotomik ini, berapa kali kita menggunakan oracle B lebih kecil dari logaritma jumlah biaya taksi antara 2 poin, yaitu tentang jumlah digit yang diperlukan untuk menulis biaya taksi. Akibatnya, jumlah penggunaan B adalah polinomial dalam ukuran input. Oleh karena itu, B lebih sulit daripada A. Seperti yang telah kita tunjukkan bahwa A lebih sulit daripada B, kita sekarang dapat mengatakan bahwa kedua masalah sama sulitnya satu sama lain.

====Realisasi====

OK saya mendapatkan konsep "lebih keras". Saya kira NP-hard ada hubungannya dengan itu ...
Iya! Kita menyebut NP-hard serangkaian masalah (belum tentu masalah keputusan) yang lebih sulit daripada masalah NP apa pun. Cukup aneh, masalah NP-hard belum tentu NP. Ada banyak masalah NP-hard, dan masalah ini pasti ... sulit.

Tapi yang sangat menarik sebenarnya adalah perpotongan dari set masalah NP-hard dan set masalah NP. Set ini disebut NP-complete.

[[Collections|<img src=https://user-images.githubusercontent.com/36441664/84533710-e6b72400-ad12-11ea-9ee5-a8b57b8855fb.png width=300>]]

===Properti===

Mengapa masalah NP-complete begitu menarik?
Pertama, karena jika Anda dapat menemukan algoritma polinomial untuk menyelesaikan masalah NP-complete, maka Anda akan membuktikannya ! Jelas, ini sebenarnya berlaku untuk masalah NP-hard, karena definisi "lebih keras" yang kita bahas sebelumnya.

[[https://user-images.githubusercontent.com/36441664/84743852-b4d8e280-afdc-11ea-8e92-31c28a4ee658.png]]

Tetapi terutama, karena kita tahu banyak masalah NP-complete, sehingga Anda dapat memilih yang ingin Anda pecahkan. Di antara mereka, mari kita sebutkan masalah kepuasan boolean, masalah keputusan ransel, masalah keputusan penjual keliling, masalah keputusan mewarnai grafik ..

[[https://user-images.githubusercontent.com/36441664/84532745-f7669a80-ad10-11ea-9f1d-26e45e04401b.png]]

====Orientasi====

Anda mengatakan bahwa masalah ini P = NP sangat penting ... Mengapa?

Baiklah, jika, maka banyak penelitian dalam optimasi akan sia-sia. Banyak masalah yang kini dihadapi para ilmuwan akan diselesaikan secara instan, seperti pemulihan DNA, perhitungan kesetimbangan Nash, perutean kendaraan ... Tetapi yang lebih penting, beberapa sistem saat ini, terutama dalam kriptografi, dibangun mengingat bahwa, yaitu tidak ada yang bisa memecahkan sistem dalam waktu kurang dari beberapa juta tahun. Misalnya, komunikasi pribadi melalui web termasuk dengan bank Anda menggunakan protokol rahasia. Salah satunya adalah sistem RSA, di mana setiap lembaga memiliki kunci pribadi dan memberikan kunci publik. Anda dapat berbicara dengan lembaga dengan menyandikan pesan Anda dengan kunci publik, tetapi tidak seorang pun kecuali lembaga yang dapat men-decode pesan Anda karena kunci pribadi diperlukan untuk itu. Dan lembaga percaya bahwa tidak ada yang akan bisa menebak kunci pribadi dengan kunci publik ... yang sebenarnya bisa dilakukan, tetapi mungkin perlu beberapa juta tahun. Jika, sebuah algoritma dapat ditemukan untuk menyelesaikannya dalam hitungan hari atau kurang! Saya akan membiarkan Anda membayangkan konsekuensinya ... 

Kebanyakan ilmuwan sebenarnya cenderung percaya itu, Yang berarti bahwa masalah NP-hard adalah masalah yang secara intrinsik sulit. Dan akan lebih aman untuk membuat sistem yang mengasumsikan bahwa masalah NP-hard tidak dapat diselesaikan dalam waktu yang wajar. Bagaimanapun, di sini adalah grafik dari apa yang akan menjadi konsekuensi untuk hubungan antara P, NP, NP-lengkap dan NP-keras.

[[https://user-images.githubusercontent.com/36441664/84601801-041ff580-aead-11ea-84bb-c38c86bb189f.png]]

====Objective====

Mari kita simpulkan.

Masalah adalah masalah terbuka mendasar yang sangat sulit dengan banyak implikasi praktis utama. Itu sebabnya mungkin itu masalah utama saat ini. Selain itu, ada banyak interpretasi. Beberapa dari mereka benar-benar mempertimbangkan bahwa cara kita memahami dunia dipahami secara global, termasuk konsep kreativitas, akan sangat terpengaruh. Inilah video yang luar biasa dari Hackerdashery :

[[<img src=https://user-images.githubusercontent.com/36441664/84744703-c8d11400-afdd-11ea-96ff-a43a37b7e97c.jpg>|https://youtu.be/YX40hbAHx3s]]

Perhatikan bahwa ini bukan satu-satunya masalah terbuka mendasar dalam kompleksitas komputasi. Secara khusus, Masalah lain termasukdimana adalah serangkaian masalah keputusan yang dipecahkan oleh mesin Turing yang tidak deterministik dalam waktu polinomial ketika jawabannya "salah". Ada juga atau dimana  mengacu pada algoritma probabilistik dan untuk algoritma kuantum probabilistik. 

Banyak ilmuwan cenderung percaya, meskipun argumen utama mereka adalah bahwa, jika P = NP, maka salah satu dari mereka akan menemukan algoritma polinomial untuk menyelesaikan salah satu dari algoritma NP-complete 
... 

[[https://user-images.githubusercontent.com/36441664/84743870-bacec380-afdc-11ea-8ba5-56e2cb465a15.jpg]]

Atau mungkin itu hanya alasan untuk membenarkan bahwa kita tidak tahu jawabannya ... Yang lebih meresahkan lagi, beberapa ilmuwan menyarankan bahwa masalahnya mungkin tidak dapat dipastikan! Ini berarti tidak ada buktinya tidak juga itu . 

Penyebabnya adalah matematika tidak cukup berkembang untuk menjawab pertanyaan ini (dan, mungkin, tidak pernah cukup berkembang!). 

Namun perlu dicatat bahwa ada masalah yang terbukti lebih sulit daripada masalah P. Juga berkomentar, bahkan jika, mungkin ada algoritma yang dapat memecahkan masalah NP-hard dalam waktu polinomial rata-rata.

==Pemetaan==

[[<img src=https://user-images.githubusercontent.com/36441664/84744689-c4a4f680-afdd-11ea-80b7-6cd6566e42f9.png width=800>]]

[[https://user-images.githubusercontent.com/36441664/84743940-ce7a2a00-afdc-11ea-913f-35959f91e41d.jpg]]

[[https://user-images.githubusercontent.com/36441664/84744110-01bcb900-afdd-11ea-9f61-960ce0acc8bb.jpg]]

[[https://user-images.githubusercontent.com/36441664/84744194-1e58f100-afdd-11ea-95ce-b08fd305f47c.jpg]]

[[<img src=https://user-images.githubusercontent.com/36441664/84743530-4c8a0100-afdc-11ea-9ab7-b1d1eab8bc37.jpg>]]

[[https://user-images.githubusercontent.com/36441664/84743546-514eb500-afdc-11ea-9d7a-e9b6686c3dd2.jpg]]

===Prinsip===

[[<img width=300 src=https://user-images.githubusercontent.com/36441664/84744181-1a2cd380-afdd-11ea-83a5-c53228a4ed5d.png>]]

[[<img width=400 src=https://user-images.githubusercontent.com/36441664/84744189-1c8f2d80-afdd-11ea-8a42-edd85edd78d6.png>]]

[[https://user-images.githubusercontent.com/36441664/84744171-1731e300-afdd-11ea-9051-f8a762d0a67e.png]]

[[https://user-images.githubusercontent.com/36441664/84744171-1731e300-afdd-11ea-9051-f8a762d0a67e.png]]

[[https://user-images.githubusercontent.com/36441664/84744163-1600b600-afdd-11ea-91bb-8ac324da4af1.png]]

[[<img width=500 src=https://user-images.githubusercontent.com/36441664/84744126-071a0380-afdd-11ea-885a-f4ca8a3c3c38.gif>]]

[[https://user-images.githubusercontent.com/36441664/84744121-05504000-afdd-11ea-8d95-79651904d600.jpg]]

[[<img width=800 src=https://user-images.githubusercontent.com/36441664/84744184-1b5e0080-afdd-11ea-829a-489ac0a4196a.png>]]

====Sizing====

[[<img src=https://user-images.githubusercontent.com/36441664/84743514-485de380-afdc-11ea-921d-9eff36645cd3.png width=250>]]

[[<img width=300 src=https://user-images.githubusercontent.com/36441664/84743643-6deaed00-afdc-11ea-9b30-8a08da12a3bf.gif>]]

[[https://user-images.githubusercontent.com/36441664/84743653-717e7400-afdc-11ea-8ce6-cddc8f7181f2.gif]]

[[<img width=500 src=https://user-images.githubusercontent.com/36441664/84743725-8ce97f00-afdc-11ea-9fe7-f4cfa2c444b1.gif>]]

[[<img width=600 src=https://user-images.githubusercontent.com/36441664/84743677-793e1880-afdc-11ea-9fc0-245d50bcc6d8.png>]]

[[<img width=700 src=https://user-images.githubusercontent.com/36441664/84743735-8fe46f80-afdc-11ea-8719-42cf29839316.gif>]]

[[<img width=800 src=https://user-images.githubusercontent.com/36441664/84743713-88bd6180-afdc-11ea-87d6-8044dd843f28.gif>]]

[[<img src=https://user-images.githubusercontent.com/36441664/84744227-2749c280-afdd-11ea-99ba-4e74fba4ea13.png>]]

====Sorting====
[[https://user-images.githubusercontent.com/36441664/84744007-e3ef5400-afdc-11ea-8dfc-6dbfaa6a7d2b.gif]]

[[<img src=https://user-images.githubusercontent.com/36441664/84743988-ddf97300-afdc-11ea-9adb-d84e31bf0bd0.png>]]

[[<img width=600 src=https://user-images.githubusercontent.com/36441664/84743985-dcc84600-afdc-11ea-9440-77e9aaac8c31.png>]]

[[<img width=600 src=https://user-images.githubusercontent.com/36441664/84743982-dafe8280-afdc-11ea-8a7e-256926dee3da.png>]]

[[<img src=https://user-images.githubusercontent.com/36441664/84743542-4f84f180-afdc-11ea-8f01-429b8cc60a04.jpg>]]

[[<img width=800 src=https://user-images.githubusercontent.com/36441664/84743935-ccb06680-afdc-11ea-9c24-530c1df8a17d.jpg>]]

[[<img width=800 src=https://user-images.githubusercontent.com/36441664/84743518-498f1080-afdc-11ea-9483-66b0cd753507.png>]]

[[https://user-images.githubusercontent.com/36441664/84744011-e5208100-afdc-11ea-8415-32ef7c35416b.jpg]]

[[https://user-images.githubusercontent.com/36441664/84743538-4eec5b00-afdc-11ea-9d92-14414f632dfa.jpg]]

[[<img src=https://user-images.githubusercontent.com/36441664/84656370-ca96cb00-af3c-11ea-8f8d-be132e4e78e4.jpg>]]

```
;; n-sat-to-clique: formula -> (listof edge)
;; transform an input to n-sat to an input for clique
;; assume the input expression is in CNF, and that
(define (n-sat-to-clique expr)
  (let* ([conjuncts (∧-conjuncts expr)]
         [columns (map (λ (x) (∨-disjuncts x)) conjuncts)]
         [labeled-columns (label-graph columns 1)]
         [possible-edges (all-pairs-in-distinct-lists labeled-columns)])
     (list->set (filter no-conflict? possible-edges))))
```

===Akurasi===

[[Implementasi#replications|<img src=https://user-images.githubusercontent.com/36441664/84659635-e9e42700-af41-11ea-996a-a5d6ee6e9864.png>]]

[[<img width=250 src=https://user-images.githubusercontent.com/36441664/84743707-85c27100-afdc-11ea-8ef9-a7b9c8a13689.gif>]]

[[<img width=300 src=https://user-images.githubusercontent.com/36441664/84743742-9246c980-afdc-11ea-8b49-69e602a619b7.gif>]]

[[<img width=400 src=https://user-images.githubusercontent.com/36441664/84743767-97a41400-afdc-11ea-82d8-bd90af431fd2.gif>]]

[[<img width=600 src=https://user-images.githubusercontent.com/36441664/84743717-89ee8e80-afdc-11ea-8a28-fec921460325.gif>]]

[[https://user-images.githubusercontent.com/36441664/84743693-7f33f980-afdc-11ea-814d-16be4b1d95f6.gif]]

[[<img width=800 src=https://user-images.githubusercontent.com/36441664/84743781-9d99f500-afdc-11ea-8377-e0ecee9537ea.gif>]]

[[https://user-images.githubusercontent.com/36441664/84743740-91159c80-afdc-11ea-8061-abc2a146c11e.png]]

====Looping====

[[<img width=200 src=https://user-images.githubusercontent.com/36441664/84744062-f79aba80-afdc-11ea-9b8b-87dcfb8ee310.png>]]

[[<img width=300 src=https://user-images.githubusercontent.com/36441664/84743646-6fb4b080-afdc-11ea-86de-d072f0c047a5.gif>]]

[[<img width=400 src=https://user-images.githubusercontent.com/36441664/84744057-f5386080-afdc-11ea-8bd0-24a72f1f771d.jpg>]]

[[<img width=600 src=https://user-images.githubusercontent.com/36441664/84744060-f6698d80-afdc-11ea-87a3-7cee798b104b.gif>]]

[[<img width=700 src=https://user-images.githubusercontent.com/36441664/84744069-f8cbe780-afdc-11ea-964d-e71df0df5125.png>]]

[[<img width=700 src=https://user-images.githubusercontent.com/36441664/84744088-fcf80500-afdc-11ea-9245-8d9c6c8f50d1.jpg>]]

[[<img width=800 src=https://user-images.githubusercontent.com/36441664/84744053-f36e9d00-afdc-11ea-8234-0d5125a3fa52.png>]]

[[<img width=800 src=https://user-images.githubusercontent.com/36441664/84744099-fec1c880-afdc-11ea-900a-7a99eae0eb49.jpg>]]

[[https://user-images.githubusercontent.com/36441664/84744106-fff2f580-afdc-11ea-9369-71e83ee9dbc4.jpg]]

====Optimasi====

[[<img width=200 src=https://user-images.githubusercontent.com/36441664/84743564-57449600-afdc-11ea-925a-bb0646698716.png>]]

[[<img width=250 src=https://user-images.githubusercontent.com/36441664/84743566-5875c300-afdc-11ea-8bf8-9326261ded40.jpg>]]

[[<img width=300 src=https://user-images.githubusercontent.com/36441664/84743559-557ad280-afdc-11ea-96e6-5d15ead1e734.jpg>]]

[[<img width=400 src=https://user-images.githubusercontent.com/36441664/84743555-5449a580-afdc-11ea-91bc-a4bd095ef27d.png>]]

[[<img width=600 src=https://user-images.githubusercontent.com/36441664/84743561-56136900-afdc-11ea-895d-51791378b86c.png>]]

[[<img width=800 src=https://user-images.githubusercontent.com/36441664/84743571-59a6f000-afdc-11ea-845b-78cbca227d4c.png>]]

===Validasi===
[[https://user-images.githubusercontent.com/36441664/84532743-f6356d80-ad10-11ea-8bb1-0b64b9313969.jpg]]

[[<img width=200 src=https://user-images.githubusercontent.com/36441664/84743553-53b10f00-afdc-11ea-960f-ceb85e89e497.png>]]

[[<img width=250 src=https://user-images.githubusercontent.com/36441664/84743580-5c094a00-afdc-11ea-91c6-be1537887e21.jpg>]]

[[<img width=300 src=https://user-images.githubusercontent.com/36441664/84743576-5ad81d00-afdc-11ea-8cbb-167d0c3e3a73.gif>]]

[[<img width=400 src=https://user-images.githubusercontent.com/36441664/84743853-b60a0f80-afdc-11ea-8c9f-3502d2cbee97.png>]]

[[<img width=600 src=https://user-images.githubusercontent.com/36441664/84743860-b7d3d300-afdc-11ea-8149-f58600c76935.png>]]

[[<img width=800 src=https://user-images.githubusercontent.com/36441664/84743864-b9050000-afdc-11ea-8143-3e0dfde585a7.png>]]

====Capturing====

[[<img width=200 src=https://user-images.githubusercontent.com/36441664/84743611-64fa1b80-afdc-11ea-8138-7c040c99cf06.png>]]

[[<img width=250 src=https://user-images.githubusercontent.com/36441664/84743613-6592b200-afdc-11ea-90c9-ed5938a6e8ef.png>]]

[[<img width=300 src=https://user-images.githubusercontent.com/36441664/84743631-6a576600-afdc-11ea-8d1c-214107683107.png>]]

[[<img width=400 src=https://user-images.githubusercontent.com/36441664/84743618-66c3df00-afdc-11ea-8075-390dba87cf54.png>]]

[[<img width=600 src=https://user-images.githubusercontent.com/36441664/84743620-675c7580-afdc-11ea-836c-1c11b1000f6c.png>]]

[[https://user-images.githubusercontent.com/36441664/70721601-75c58e00-1d28-11ea-8329-d780c27ee7bd.png]]

[[https://user-images.githubusercontent.com/36441664/69497959-189e9f80-0f15-11ea-86bd-457378ca7567.png]]

====Directions====

* [[P vs. NP, A Primer (And a Proof Written in Racket)|https://jeremykun.com/2012/02/23/p-vs-np-a-primer-and-a-proof-written-in-racket/]]

[[Application#validasi|<img src=https://user-images.githubusercontent.com/36441664/84743844-b0acc500-afdc-11ea-8311-3affd4bf0c69.gif width=200>]]

[[Application#capturing|<img src=https://user-images.githubusercontent.com/36441664/84656283-a2a76780-af3c-11ea-930d-049952522888.png width=300>]]

[[Program#eksternal|<img src=https://user-images.githubusercontent.com/36441664/81076750-3c2f3280-8f16-11ea-953f-f2f03e4ac49f.png width=400>]]

[[Trace#komposisi|<img src=https://user-images.githubusercontent.com/36441664/81181797-2a619400-8fd7-11ea-8462-9e1aab20c709.jpg width=500>]]

[[Tree#identifikasi|<img src=https://user-images.githubusercontent.com/36441664/69990325-04434e00-1578-11ea-9e5a-c86bd88fe706.png width=800>]]

[[Directions#penyambungan|<img src=https://user-images.githubusercontent.com/36441664/84743524-4b58d400-afdc-11ea-9e64-5306a5811a33.jpg width=800>]]

==''Referensi''==
* [[Review Teori P dan NP - Program Studi Magister Informatika STEI-ITB (Pdf)|https://informatika.stei.itb.ac.id/~rinaldi.munir/TeoriKomputasi/2014-2015/IF5110%20-%20Review%20Teori%20P%20dan%20NP.pdf]]

