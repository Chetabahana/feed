<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.12.0" xml:lang="en-US">
  <compounddef id="classcsl_1_1Abstract" kind="class" language="C++" prot="public" abstract="yes">
    <compoundname>csl::Abstract</compoundname>
    <derivedcompoundref refid="classcsl_1_1AbstractBuildingBlock" prot="public" virt="non-virtual">csl::AbstractBuildingBlock</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1AbstractDuoFunc" prot="public" virt="non-virtual">csl::AbstractDuoFunc</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1AbstractFunc" prot="public" virt="non-virtual">csl::AbstractFunc</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1AbstractMultiFunc" prot="public" virt="non-virtual">csl::AbstractMultiFunc</derivedcompoundref>
    <derivedcompoundref refid="classcsl_1_1AbstractVectorial" prot="public" virt="non-virtual">csl::AbstractVectorial</derivedcompoundref>
    <includes refid="abstract_8h" local="no">abstract.h</includes>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="classcsl_1_1Abstract_1ad5fee68c1f3dcbda0e936926fed17616" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>csl::Abstract::Abstract</definition>
        <argsstring>()</argsstring>
        <name>Abstract</name>
        <qualifiedname>csl::Abstract::Abstract</qualifiedname>
        <briefdescription>
<para>Default Constructor. </para>
        </briefdescription>
        <detaileddescription>
<para>Initializes name empty and commutable to <bold>True</bold>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="90" column="5" bodyfile="src/csl/abstract.h" bodystart="90" bodyend="90"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a40bdc4c76fdbbf3cbac3af4dce8286ed" prot="public" static="no" const="no" explicit="no" inline="yes" virt="virtual">
        <type></type>
        <definition>virtual csl::Abstract::~Abstract</definition>
        <argsstring>()</argsstring>
        <name>~Abstract</name>
        <qualifiedname>csl::Abstract::~Abstract</qualifiedname>
        <briefdescription>
<para>Destructor. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="94" column="13" bodyfile="src/csl/abstract.h" bodystart="94" bodyend="96"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a5c796713828ebfb74a7d8787d7802a76" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::self</definition>
        <argsstring>()</argsstring>
        <name>self</name>
        <qualifiedname>csl::Abstract::self</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="98" column="10" bodyfile="src/csl/abstract.cpp" bodystart="30" bodyend="33"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aed56cb85894209a9bbc9b8bdada5e6ab" prot="public" static="no" const="yes" explicit="no" inline="no" virt="pure-virtual">
        <type>void</type>
        <definition>virtual void csl::Abstract::print</definition>
        <argsstring>(int mode=0, std::ostream &amp;out=std::cout, LibraryMode libMode=LibraryMode::NoLib) const =0</argsstring>
        <name>print</name>
        <qualifiedname>csl::Abstract::print</qualifiedname>
        <reimplementedby refid="classcsl_1_1Abs_1a08ced320bad3c444c1d51efde39c068b">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1afeaa37536bfa9de67a736d2884578514">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACos_1ac3a70d756d2c6f91ee35dc46f845b7f5">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACosh_1a1c9ce73586a90e166932281d29a8090f">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1Angle_1a6efd87ab8730302f18e72b19431cf3b7">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1Arbitrary_1ab5f7c2c30475e2dd9a13423923ff13bc">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASin_1ac1da66cfd9b73db5a47e92279011dd08">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASinh_1ab6ee807bccbe4394943f169ccc620c1f">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATan_1a309557f2c6332130e57396181f0cc64f">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATanh_1a16e9431afda48a0838e0f036501da476">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1BooleanOperator_1a2e61ed30827b9a42bf9b8a5ec24301ad">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1Commutator_1a4cb9ff06c9a69c826758da4b992d15b9">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complex_1a840991e02d47506b35ee49b16d8dd8b0">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1Constant_1a3fa4bb061f59a9da7278b3b0188c7236">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cos_1afa1a771ec452b284b470682fcb87b002">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cosh_1a01a5c90284d2e60271aec223efed3348">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1Derivative_1a4aacae07230cb240ff9349498cfc339a">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1DiracDelta_1ac5117381383dfaeb706b5d19b9971014">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1Exp_1acc132fb2a3e66943918158e1be8b2f92">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1Factorial_1ae5625935a6d612978db8b77d6b7a324e">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1Float_1a507979a5b36edb4e3f076f75ba010e7c">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1Imaginary_1a34b99b842894045a09aa9c796f9d765a">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1ImaginaryPart_1acc310b40a49a21b15ba3a613100d6fdd">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integer_1a1c8d479f0f4fee521934707dafd162ab">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integral_1ade5de0026bdfc743a5574f091340171c">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFactorial_1a334c8a8738b4f3fe1dd9c1c022f7e4a6">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFraction_1a3278490e3c91491cc8d0a07cccdc13d0">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1Log_1a86215b004fb03ac928ba6229d1c97535">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1Polynomial_1ace97cf2aeb447514487c478e5b2d5f90">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1ab214090619fd0e99b39b8912f8eed7b1">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1a6f7a134346d64c86bbc3bf855321a568">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1RealPart_1a139d225aa4b008c2d39e1cbe351e5904">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1ScalarIntegral_1a4010ee626fd75e493ac3117fad8d6819">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sin_1a05bd2fbbf3e80be7bab9a1df28c3f27f">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sinh_1abeeba07acff9c5b5cc8d2b90d4660ae5">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1a6fff095607bbdb39b0f1d946ef6c20fb">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tan_1a6a1e5434ee58f6eb13d4bacf43e97804">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tanh_1a7f8da1a8e95f15ebd43e291dd0e196d0">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1a0d83fa5e3869c4e375e4d5d3f0ae8757">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1a0b5baffa4b563fd8e2e8ec4ee00446b1">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1afac7a7dd245d9d1bc5f52700e2a6acb8">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1a67c31bd17fd8671bf460b6f164ed4ca7">print</reimplementedby>
        <reimplementedby refid="classcsl_1_1VectorIntegral_1a208b56fddd7449cbcd3bb85ceca972f6">print</reimplementedby>
        <reimplementedby refid="classmty_1_1FermionPropStruct_1a2749cf2587e94d51f80d2fa3b443113f">print</reimplementedby>
        <reimplementedby refid="classmty_1_1FeynmanIntegral_1a94d2ca6efffd2f24ff6bd06612b4aec9">print</reimplementedby>
        <reimplementedby refid="classmty_1_1Propagator_1a5d240f68dcabe6e6c5030eea6610992e">print</reimplementedby>
        <reimplementedby refid="classmty_1_1Wick_1a4ef14b6905a7785f2ee7f2722f725f19">print</reimplementedby>
        <param>
          <type>int</type>
          <declname>mode</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
          <defval>std::cout</defval>
        </param>
        <param>
          <type>LibraryMode</type>
          <declname>libMode</declname>
          <defval>LibraryMode::NoLib</defval>
        </param>
        <briefdescription>
<para>Displays the abstract in standard output. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>Tells if the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> is printed alone (default) or in another expr. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="108" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a2910dd30d90915c11d48c01cab618dda" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::printCode</definition>
        <argsstring>(int mode=0, std::ostream &amp;out=std::cout) const</argsstring>
        <name>printCode</name>
        <qualifiedname>csl::Abstract::printCode</qualifiedname>
        <reimplementedby refid="classcsl_1_1Abs_1a24944c16edb7e6e3a9b6143ab51755b4">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractNumerical_1a740642e1d76ca38507b0033a3460e330">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1ad12d45f7d849c24d2518395f6798652d">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACos_1ac2dc7814bd53d871802e020be91bc3ea">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACosh_1abfc5e10dfe43301088b9d34ddadaf050">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1Angle_1ab7e4f72fbbc332d9443e27ec725b8e02">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASin_1a5f4f6633b252e1d6d1c2b04113072d30">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASinh_1a04770377795e417756cc51e58264a72a">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATan_1a4b000c7025a2c5984775d1d8e8bd2cce">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATanh_1af08fb6cc775e16d68c75a83c40b2091f">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1BooleanOperator_1a7d2e313d16a2a87c949521eb83feed2c">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complex_1a42441dddb02718d2a4fae5140ccf8b69">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1Constant_1abe61f8646eb42e0314a42fa83d7e6a4e">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cos_1a8f4389d5b78458befe81d907f0675fcc">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cosh_1a4c17a7445be66f345b89788f92b94d95">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1Derivative_1a27b0ea4dcfff6cbb7b8c72e734d76b6a">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1DiracDelta_1ad49511d4da1a62ffe6217d7ffc4872ba">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1Exp_1a172bb61ec86da018e10569c90b82e763">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1Factorial_1a32ab2c90fbde1689c243cffc0591c0d6">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1Imaginary_1aed20550becfed8ba8f9b91ef5315e655">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integral_1a806c39d802157c6fbc2c9b7a28c1426d">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFactorial_1ae8d22660dbc2525bf892a5bed8b30463">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFraction_1a101a17888606be3f07bb280cafac2ecc">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1Log_1a1f2fb21bb54fe470c5d5fda206da0551">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1Polynomial_1a3d02026cf19bc33fe0b57ff747241d80">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1ad6a7a2422776b78a5852bdd1c7c224d9">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1a6e232ef31360d821242f56794a558c15">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1ScalarIntegral_1a1cbec4757962f5307479560e07c7e346">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sin_1a3452f2d6182500f63d462296c8d9cd80">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sinh_1ab22ee2d225a7038100f0be1513c3494c">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1aa6c53e2ba4c315375c4836b1794fbec3">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tan_1ae4f42a765329a7e32dd8b383d325044c">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tanh_1a91bd008cc3ed7885a62b41576b1a5a37">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1abc07f74c7642f18855bea42cbed1eef5">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1a8c28c7b5335fef612bce15a2a3e64a0c">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1a6d2cb1f66c717a35f4c447952720817c">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1a46ec1164529c21f0b4fbd2bb1db15c14">printCode</reimplementedby>
        <reimplementedby refid="classcsl_1_1VectorIntegral_1aa3fcad92cad86ec27c18b6ad03453da1">printCode</reimplementedby>
        <reimplementedby refid="classmty_1_1GeneratorElement_1a0a0f3048356d1d73fff965c16942389d">printCode</reimplementedby>
        <reimplementedby refid="classmty_1_1PolarizationField_1a5d60e41b929bf0aa8fcf49b5de67becb">printCode</reimplementedby>
        <reimplementedby refid="classmty_1_1Wick_1a6180e9af24f73ea22549514197f80a8a">printCode</reimplementedby>
        <param>
          <type>int</type>
          <declname>mode</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
          <defval>std::cout</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="112" column="18" bodyfile="src/csl/abstract.cpp" bodystart="86" bodyend="90"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a0645745feacf93470963b55f93cae1c0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::printProp</definition>
        <argsstring>(std::ostream &amp;fout=std::cout) const</argsstring>
        <name>printProp</name>
        <qualifiedname>csl::Abstract::printProp</qualifiedname>
        <reimplementedby refid="classcsl_1_1Complexified_1a42c425b2145c916331f881f217e14e4b">printProp</reimplementedby>
        <reimplementedby refid="classmty_1_1PolarizationField_1a4592cceedf21f55a616df8d85d866bda">printProp</reimplementedby>
        <param>
          <type>std::ostream &amp;</type>
          <declname>fout</declname>
          <defval>std::cout</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="119" column="18" bodyfile="src/csl/abstract.cpp" bodystart="141" bodyend="143"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a89e45ffc7b65f92e77e592f76f70934c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Abstract::printExplicit</definition>
        <argsstring>(int mode=0) const</argsstring>
        <name>printExplicit</name>
        <qualifiedname>csl::Abstract::printExplicit</qualifiedname>
        <param>
          <type>int</type>
          <declname>mode</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Displays explicitely the expression, with types of each component. This function is only used for debug. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>Mode of printing. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="125" column="10" bodyfile="src/csl/abstract.cpp" bodystart="145" bodyend="159"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aa067d4a97135bfe2052a7e21c28f75be" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::string</type>
        <definition>string csl::Abstract::printLaTeX</definition>
        <argsstring>(int mode=0) const</argsstring>
        <name>printLaTeX</name>
        <qualifiedname>csl::Abstract::printLaTeX</qualifiedname>
        <reimplementedby refid="classcsl_1_1Abs_1a4dcecd9b1e1dbca2386e4af8dd663ba5">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a8a568746d53548b8621fda445258e830">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACos_1acd36159ea83e46fe2ca50a3ada149bd5">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACosh_1aca6f5306a978ba8589f2757c0599473a">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1Angle_1a51993a606446fead779049e3581905f8">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1Arbitrary_1a2275ec73b2842df28cb80bd59bbf958d">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASin_1ae9ef3ca87aa148c1bdcdb4d62ae9f2dd">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASinh_1a470c061e6a77cedcf9f57bd01a53e1dc">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATan_1a851f824336d8fd176d2cc9264bfd8fcf">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATanh_1adb8ee7249faa4bf5c723e0f8c998ea02">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1BooleanOperator_1a629e5fb52431fa6cd91c245b920acd47">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1Commutator_1a1f359f9d2379cabeec2522b6bbbd034a">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complex_1a8405fa57577ecae2935fa40b703db69b">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1Constant_1a606d0d84686fe39def7bfed9bacd5817">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cos_1a0004c95693419ba41ad203caf20a7f64">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cosh_1a4f968c087cdf5402e49b67ea3ac5bf19">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1Derivative_1a8beb96c8fb56648031f7df13194f8eaf">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1DiracDelta_1aa3b109eb3dc25e8084df99b1f77fada4">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1Exp_1a4bf08517c64b660eb82cf2922e893cfc">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1Factorial_1a0f94e896bd5032efea33a4faae931980">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1Float_1a19efbc737f9188703d55730839b744c0">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1Imaginary_1a78ac0adf5aa6b8c4a159295ca8dd2fbb">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1ImaginaryPart_1af9c1420abf4c1060ce30061b75323899">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integer_1ab775bd9a73cd2a9c410e1fdc02c8b9b9">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integral_1a6c9ccd94f57b8319977903d7fb0b86e6">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFactorial_1ab1a3293c37e9e099f6c2e1ec977612ec">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFraction_1af5517b79f442b4fdc42116e717098cfe">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1Log_1adb9494e204b723c0401b679cde2b36e3">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1Polynomial_1af1a0a4d8e8fb9358c90da3ce04d078d1">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1aff8a636e76fdb85a66a389c312ca5729">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1a3bcfa6d3a4b9a8d1ab4255f01fe7edfd">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1RealPart_1a44828a44f3945f853c2b94e4b1e31820">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1ScalarIntegral_1a6b5309cffd01f21e5485a61b5bb351f3">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sin_1ab26f459fab68d5b382ff9a4be70b9c2d">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sinh_1a1cfab0be84d64aa34ba65ffdc8303937">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1a98d6f1d250495606344f29e78ba47ee0">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tan_1a69fc6716a19363bc3379d64faad91f28">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tanh_1a9ec76b9e7d1c85e6a20f100a3c1e975f">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1aa3b01cb3bd1dcef5901cc82ec29c66b3">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1a5e4794abc02ba5d8f80f76f64e9cab9c">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1ac36fad3d18e46c353b4d961867d257cf">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1a595fc7eb8f15fe01c80903a7fea41890">printLaTeX</reimplementedby>
        <reimplementedby refid="classcsl_1_1VectorIntegral_1a8d48fe368eea528433f18e5d8eb7c3a8">printLaTeX</reimplementedby>
        <reimplementedby refid="classmty_1_1FermionPropStruct_1a5692550cfc8d5e4a73b582d20163df82">printLaTeX</reimplementedby>
        <reimplementedby refid="classmty_1_1FeynmanIntegral_1a1c3521c6e7506af20bc1dc9c946e8261">printLaTeX</reimplementedby>
        <reimplementedby refid="classmty_1_1Propagator_1a3e70c97608eaa794f5be57d3e49316f7">printLaTeX</reimplementedby>
        <reimplementedby refid="classmty_1_1Wick_1ac9879e7155cbf684f4ef7d620c7927cf">printLaTeX</reimplementedby>
        <param>
          <type>int</type>
          <declname>mode</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Creates a LaTeX output for the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>Tells if the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> is printed alone (default) or in another expr. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The string corresponding to the LaTeX output. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="132" column="25" bodyfile="src/csl/abstract.cpp" bodystart="161" bodyend="166"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a4e69280b624b0e0c932f1cfa7417b55f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="pure-virtual">
        <type>std::vector&lt; <ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref> &gt;</type>
        <definition>virtual std::vector&lt; Parent &gt; csl::Abstract::getSubSymbols</definition>
        <argsstring>() const =0</argsstring>
        <name>getSubSymbols</name>
        <qualifiedname>csl::Abstract::getSubSymbols</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1ad855f9c5253c25f631c6646e3d28ae4b">getSubSymbols</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractElement_1a680ab53340473533609d65060d8457b8">getSubSymbols</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1a0d3f88b1d12d0900184101720f8e345b">getSubSymbols</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractLiteral_1a64980f64df102f1dc6000eb9d1e817b0">getSubSymbols</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1af5fc70d8f2b9e7df0dfff973a754432a">getSubSymbols</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractNumerical_1a88d337861838fb27a99439beaa423677">getSubSymbols</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1aa95d66839c20fc1b9cf8bd658b3237bb">getSubSymbols</reimplementedby>
        <reimplementedby refid="classcsl_1_1Constant_1a14f4fc82bb5f5ff43a2da36b3a5fc2bf">getSubSymbols</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1a2073cd345694641addf40b7af57aeac8">getSubSymbols</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1af028569513793f435ffbf644c0cd363f">getSubSymbols</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1aa9049a79ee6b2dfd50dbfae7d48560c9">getSubSymbols</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1a8e2806a06f054bc3a5396596ae765456">getSubSymbols</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="134" column="25"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a652101e34b2efa43114150e9af3c79d5" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1LibDependency" kindref="compound">LibDependency</ref></type>
        <definition>LibDependency csl::Abstract::getLibDependency</definition>
        <argsstring>() const</argsstring>
        <name>getLibDependency</name>
        <qualifiedname>csl::Abstract::getLibDependency</qualifiedname>
        <reimplementedby refid="classcsl_1_1Abs_1a6ea25bf9205a571f7e74af790546947b">getLibDependency</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACos_1a0eb50ec74075bac160c9e23daef96fd6">getLibDependency</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACosh_1aec2ad679d605a179fc8ecbef3ee3fc6e">getLibDependency</reimplementedby>
        <reimplementedby refid="classcsl_1_1Angle_1ac5dd7a0cc887b13291368105b068282d">getLibDependency</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASin_1ad7c642fdc63b49e10d3ecc0c78affb84">getLibDependency</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASinh_1a3c1199597f200052c7a186e15906ef36">getLibDependency</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATan_1a2bba9adc981c80698470fdd9a13f1609">getLibDependency</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATanh_1aa33835aedc83fee334212afaeb35e5c0">getLibDependency</reimplementedby>
        <reimplementedby refid="classcsl_1_1BooleanOperator_1ae971aca3ff1bbae502908785b3e360b3">getLibDependency</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cos_1a43536776f43511aa2fb3796ef4a3eaa3">getLibDependency</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cosh_1acb8c3e0f59dafcc560a94757417dafea">getLibDependency</reimplementedby>
        <reimplementedby refid="classcsl_1_1Exp_1a82a1c5d0d462e915c0cabdb2740f9f12">getLibDependency</reimplementedby>
        <reimplementedby refid="classcsl_1_1Factorial_1a9a66ceb864e2129380002591931afe8a">getLibDependency</reimplementedby>
        <reimplementedby refid="classcsl_1_1ImaginaryPart_1a0e3a2757d9aea806056cda8d15beef6c">getLibDependency</reimplementedby>
        <reimplementedby refid="classcsl_1_1Log_1ab0e40b984c17a57a84b85f431e42c930">getLibDependency</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1a9eee901c906f729e47145716117c6928">getLibDependency</reimplementedby>
        <reimplementedby refid="classcsl_1_1RealPart_1ae709d00afe1ec03e5e58a21b756157e0">getLibDependency</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sin_1af42efed2d3df9a996bcbffd3f879b256">getLibDependency</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sinh_1a91a754caacd304cdca280cb54bd23a2e">getLibDependency</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tan_1a300586d6678630715798b8e8d731a51a">getLibDependency</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tanh_1a33911ed17475514f065896a747303d0d">getLibDependency</reimplementedby>
        <reimplementedby refid="classmty_1_1FeynmanIntegral_1a8c7ec3e45f4eddb7a02d9cf267e0f724">getLibDependency</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="136" column="27" bodyfile="src/csl/abstract.cpp" bodystart="168" bodyend="171"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ac3978c71035bf1cda50f5b9031d631af" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>size_t</type>
        <definition>size_t csl::Abstract::memoryOverhead</definition>
        <argsstring>() const</argsstring>
        <name>memoryOverhead</name>
        <qualifiedname>csl::Abstract::memoryOverhead</qualifiedname>
        <reimplementedby refid="classcsl_1_1TensorElement_1ae7a6d8fc44218dcade0332e215f4b653">memoryOverhead</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="138" column="20" bodyfile="src/csl/abstract.cpp" bodystart="52" bodyend="55"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1af7f5e7466e754984a2c4394a112464f7" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::string const &amp;</type>
        <definition>std::string const  &amp; csl::Abstract::getName</definition>
        <argsstring>() const</argsstring>
        <name>getName</name>
        <qualifiedname>csl::Abstract::getName</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractElement_1ae80699e259632a43c4f69a125b64ae30">getName</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1aae5db88feee1be51e3ad429c6c10df58">getName</reimplementedby>
        <reimplementedby refid="classcsl_1_1Arbitrary_1a25dce08825f0efbf6715c8db35f981e6">getName</reimplementedby>
        <reimplementedby refid="classcsl_1_1Constant_1a8ab390edad6e1237057a217800526862">getName</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1a7ebe3e5b8b4ce47890e7ca4bbf6d634e">getName</reimplementedby>
        <briefdescription>
<para>Returns the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>&apos;s name. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><emphasis>name</emphasis> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="147" column="31" bodyfile="src/csl/abstract.cpp" bodystart="37" bodyend="40"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a9c4a302d1a3cbf4dd9394f5e5880d343" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::string const &amp;</type>
        <definition>std::string const  &amp; csl::Abstract::getLatexName</definition>
        <argsstring>() const</argsstring>
        <name>getLatexName</name>
        <qualifiedname>csl::Abstract::getLatexName</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractElement_1ad8d4ceaa06fb30861b1ce4336a465f54">getLatexName</reimplementedby>
        <reimplementedby refid="classcsl_1_1Constant_1a747f398eb32dedcaab2dfb1721d3a828">getLatexName</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1af284410cb02205537979bd43df22313d">getLatexName</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="149" column="31" bodyfile="src/csl/abstract.cpp" bodystart="42" bodyend="45"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a2263731ca94825f35281e69fb258cf87" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::getCommutable</definition>
        <argsstring>() const</argsstring>
        <name>getCommutable</name>
        <qualifiedname>csl::Abstract::getCommutable</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1a032adea087db90b6ed2c222942fdebd6">getCommutable</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractElement_1ab3418bd6d3548316885c8bda0a7464b8">getCommutable</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1ab41faa67ed807f3cc2c95f5f175e9099">getCommutable</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1a2bc449bd37728479b8c6b0a9eea3bccf">getCommutable</reimplementedby>
        <reimplementedby refid="classcsl_1_1Constant_1adfbd3cd70f84232b7518ff59b22ed0e6">getCommutable</reimplementedby>
        <reimplementedby refid="classcsl_1_1ImaginaryPart_1a2cb758975b92a34387f83895e261defe">getCommutable</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1aa26c6f1e6a43ab0d529c170466e810b0">getCommutable</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1aa26c6f1e6a43ab0d529c170466e810b0">getCommutable</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1aa26c6f1e6a43ab0d529c170466e810b0">getCommutable</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1aa26c6f1e6a43ab0d529c170466e810b0">getCommutable</reimplementedby>
        <reimplementedby refid="classcsl_1_1RealPart_1a0da475d679751428325bac460a651d85">getCommutable</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1ab418e2b424462798f44ebfe186b445c3">getCommutable</reimplementedby>
        <reimplementedby refid="classmty_1_1PolarizationField_1ae00e91ffaedfd7cfcccb95b5628d8b0b">getCommutable</reimplementedby>
        <reimplementedby refid="classmty_1_1QuantumField_1a043afe4327a0d3025e55f8ab34ce84fe">getCommutable</reimplementedby>
        <briefdescription>
<para>Allows to know if the object commutes with all the others. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><emphasis>commutable</emphasis> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="154" column="18" bodyfile="src/csl/abstract.cpp" bodystart="47" bodyend="50"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a77e067fc57c0c2e70d141079455fdbd7" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::getElementary</definition>
        <argsstring>() const</argsstring>
        <name>getElementary</name>
        <qualifiedname>csl::Abstract::getElementary</qualifiedname>
        <reimplementedby refid="classcsl_1_1Variable_1a0b23a1c79900363576d8dfcaa9821c95">getElementary</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="156" column="18" bodyfile="src/csl/abstract.cpp" bodystart="72" bodyend="77"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a021946e84d8c1a019908cac578b16fe8" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::getAllDependencies</definition>
        <argsstring>() const</argsstring>
        <name>getAllDependencies</name>
        <qualifiedname>csl::Abstract::getAllDependencies</qualifiedname>
        <reimplementedby refid="classcsl_1_1Variable_1a3a55a80d2d368f55e6b91ad8066c7352">getAllDependencies</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="158" column="18" bodyfile="src/csl/abstract.cpp" bodystart="79" bodyend="84"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a8ab79682cdff4c7d7b52c2e70ac23d85" prot="public" static="no" const="yes" explicit="no" inline="no" virt="pure-virtual">
        <type><ref refid="namespacecsl_1a70046459ec0082db8cb97005c13c9a54" kindref="member">csl::PrimaryType</ref></type>
        <definition>virtual csl::PrimaryType csl::Abstract::getPrimaryType</definition>
        <argsstring>() const =0</argsstring>
        <name>getPrimaryType</name>
        <qualifiedname>csl::Abstract::getPrimaryType</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1abafb2415e1952440db4b16c6138d6313">getPrimaryType</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1a18df1a5dbd7c9c75b1704fe958a55a5d">getPrimaryType</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractLiteral_1aa41c4506afb800db5eca9232df00720a">getPrimaryType</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1a1b6044133a95c411324d20afe460c55b">getPrimaryType</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractNumerical_1ab546a5a971f3547b7bbf2940465d70e9">getPrimaryType</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1afb6d645d2f0673a500eaf294ff822269">getPrimaryType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Arbitrary_1a489b4b7b94c0880c843db0e4cfc249d4">getPrimaryType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Constant_1a81c9c1235cc4b7a3d799a3581cbda675">getPrimaryType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Imaginary_1a45d77fd51e45fade354f8ec14c303ef7">getPrimaryType</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFactorial_1a04137e9d1e68e26f6313264aad3504e5">getPrimaryType</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1a1c246057031fbc18868bac66d13be37c">getPrimaryType</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1aab050fd18460d4842d8972a990363b0c">getPrimaryType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1a1b67145a27e8b33488f3243a97ce2064">getPrimaryType</reimplementedby>
        <briefdescription>
<para>Gives the <bold>primary</bold> <bold>type</bold> of <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>In the program this function is very often called. It allows different functions to know what type of expr they are manipulating (single number, scalar function with one argument, with multiple argumments, a <ref refid="classcsl_1_1Vector" kindref="compound">Vector</ref>, etc) in order to do special treatments or simplifications. <simplesect kind="return"><para>type (a non memorized integer corresponding to the type of abstract) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="169" column="30"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aa781456c3f801b37ce169c83514c51c1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="pure-virtual">
        <type><ref refid="namespacecsl_1ace591865c69b6315c533a1a325777312" kindref="member">csl::Type</ref></type>
        <definition>virtual csl::Type csl::Abstract::getType</definition>
        <argsstring>() const =0</argsstring>
        <name>getType</name>
        <qualifiedname>csl::Abstract::getType</qualifiedname>
        <reimplementedby refid="classcsl_1_1Abs_1aec650f01292bf5d1381d587e489a4810">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1a96910b875bda50dd7111e0f03477e36d">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1a77d642a8a42845ad66da5faa78cb3c27">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACos_1a6533f24c81b914bd04f440e19cbb3a16">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACosh_1a1cd22dc7959d90a17fa747c05f1ac70a">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Angle_1a2a0a138a9196c8c5f195a822f7a8a982">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Arbitrary_1ad803441e87d253727977a2731de05e3e">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASin_1aff7945ce6a7782ffc619ebcef75ef15f">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASinh_1a8864eabb24d35309797271892591a61f">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATan_1aef622a35036fcdd32527b881dc14e559">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATanh_1adb3c6afec3dde358d4afc272fe3e6177">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1BooleanOperator_1add90f411fddb5ef6874ba38119c77dea">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Commutator_1adac744ad959f7f67f5274f6725efd2b6">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complex_1ab203dc18378296c2b7d484773bec8746">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Constant_1afa00a556bebd39436c680106e79e5d96">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cos_1a1fb5b606bba498a4ae74ea3ea6f669a3">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cosh_1a49c09e3519a2307ef7c8713c643249ef">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Derivative_1afede83f7ca9724579f293d4289857d00">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1DiracDelta_1afde4d766b81d980647c55bda65ed519a">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Exp_1a6e36f13b9963e395c6d9ce5f58fbbaa1">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Factorial_1ac31a3e15b4bf0d7604bbdadd2080cc7f">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Float_1a23bf3dff3c0506d854366653bb9a177d">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1HighDTensor_1a0434d931a5d7533c32b7b4dc359c24e1">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Imaginary_1add1fe835290daf5c85d3850931351fef">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1ImaginaryPart_1a4644adb36c50f172991f587ab0eef89e">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integer_1a93751bbb2c3673de15a6a4f7f6f138ff">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integral_1af4eedf08f912f9fbb576a01778eecaea">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFactorial_1ac9dab3ccc2491163dec9d020078fb281">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFraction_1abebe0ae65269c3fdddc7759008cc488d">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Log_1a87bd2f7fce0e7a74fdfcbd438553d4c7">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Matrix_1ad51abe5758a67621ef124901192dd7a2">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Polynomial_1aaba60af7af69c8f95c2a52c9f3669cdd">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1a8d7c1cdb87061dd7aa472ed9fe344a8b">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1af0bd5312033ca6006d54e117503cc52b">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1RealPart_1a10f26df41d893a03dd72b734469b7bf3">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1ScalarIntegral_1af090ec91b6cf2512df62e86d9b7b032a">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sin_1a9f090098e2afc33ef5ce79391a207164">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sinh_1a482b3aa41cdfda7b21a08914963e9ea4">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1afdde4c81bf81217accd1b02b8e2b4dbf">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tan_1a13e3eefa59b9a66427401b7a9693cb55">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tanh_1a4a30d37ea900d3ce7ac37016bf669bd8">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1a16ff4a3a49daf68786abbe407d1d5b8c">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1a7b99f83fdff13fb508ea8e671d4dc834">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1ab78b88ff1b49707ee98aee3211214044">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1acbc90bf0cbc0c78553b26fbfa7eb207a">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1Vector_1a2b3aef310427653b07c7963a606faca8">getType</reimplementedby>
        <reimplementedby refid="classcsl_1_1VectorIntegral_1a514f7d0f5a9cff6c43d786717a030ad7">getType</reimplementedby>
        <reimplementedby refid="classmty_1_1Wick_1aefeea9f14f55cea79442aa1f211c202e">getType</reimplementedby>
        <briefdescription>
<para>Gives the <bold>type</bold> of <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>In the program this function is very often called. It allows different functions to know what type of expr they are manipulating (cos, product, number, etc) in order to do special treatments or simplifications. <simplesect kind="return"><para>type (a non memorized integer corresponding to the type of abstract) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="179" column="23"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a5856c3d55a6d1406970f3656e61efe8e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>int</type>
        <definition>int csl::Abstract::getDim</definition>
        <argsstring>() const</argsstring>
        <name>getDim</name>
        <qualifiedname>csl::Abstract::getDim</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1afda6fa063a671a3a0feee716621c19c3">getDim</reimplementedby>
        <briefdescription>
<para>Gives the <bold>dimension</bold> of the object. </para>
        </briefdescription>
        <detaileddescription>
<para>Allows to know if we are manipulating a pure scalar (i.e. that can have a real value) or something else. There is the particular case of the <ref refid="classcsl_1_1Imaginary" kindref="compound">Imaginary</ref> <bold>i</bold> that is considered as a scalar for simplicity but in reality cannot be evaluated with a real. Example: 1 + <bold>i</bold> cannot be reduced. <simplesect kind="return"><para>dim (a non memorized integer corresponding to the dimension of the abstract) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="190" column="17" bodyfile="src/csl/abstract.cpp" bodystart="67" bodyend="70"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ad74c068f1da78856321932b6b6ae17dc" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::isBuildingBlock</definition>
        <argsstring>() const</argsstring>
        <name>isBuildingBlock</name>
        <qualifiedname>csl::Abstract::isBuildingBlock</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractBuildingBlock_1aee083330a4490359012cf0e656758a44">isBuildingBlock</reimplementedby>
        <briefdescription>
<para>Tells if the expression is a Building Block or not. </para>
        </briefdescription>
        <detaileddescription>
<para>Building blocks are derived classes that cannot contain further expressions, i.e. expressions that are the leafs of the recursive tree reprensent mathematical expressions: numerical or pure literal objects (variable, constant etc). <simplesect kind="return"><para><bold>True</bold> if <emphasis>*this</emphasis> is a Building Block. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="200" column="18" bodyfile="src/csl/abstract.cpp" bodystart="488" bodyend="491"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ae89eb7b1a9e0259a60154563f3315907" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>int</type>
        <definition>int csl::Abstract::getOrderOf</definition>
        <argsstring>(Expr_info expr) const</argsstring>
        <name>getOrderOf</name>
        <qualifiedname>csl::Abstract::getOrderOf</qualifiedname>
        <reimplementedby refid="classcsl_1_1Polynomial_1aa0ca7b4b1bfbc8665e2b9e1739d10c2a">getOrderOf</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1a18b8f330620d6c9c47c101e4f6435a90">getOrderOf</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1abbd390d2c92c1b3187355c77ad3404c7">getOrderOf</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1a90f4bd8e0a54da800a0a1a67608fb080">getOrderOf</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="202" column="17" bodyfile="src/csl/abstract.cpp" bodystart="493" bodyend="496"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ac09992d147b39388c8936b3bff648930" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::isArbitrary</definition>
        <argsstring>() const</argsstring>
        <name>isArbitrary</name>
        <qualifiedname>csl::Abstract::isArbitrary</qualifiedname>
        <reimplementedby refid="classcsl_1_1Arbitrary_1a53ca5235ba7ad6a7bd7f157557b0e11f">isArbitrary</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="204" column="18" bodyfile="src/csl/abstract.cpp" bodystart="498" bodyend="501"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a216b7bd3930fbf047e5bf8f69e9b964c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::isIndexed</definition>
        <argsstring>() const</argsstring>
        <name>isIndexed</name>
        <qualifiedname>csl::Abstract::isIndexed</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1a3c528c48d0b95db2e506f1d6959c5e67">isIndexed</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1a25e37d9d40927ef216a5b10958fa83ba">isIndexed</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1aee96fe96e6cf30e1022ee8f489884aa5">isIndexed</reimplementedby>
        <reimplementedby refid="classcsl_1_1BooleanOperator_1a23ae1ecdbcef223a30e11aaa6c992732">isIndexed</reimplementedby>
        <reimplementedby refid="classcsl_1_1IProd_1a046bd2f7ea7fb90fdf1dadad1a69af64">isIndexed</reimplementedby>
        <reimplementedby refid="classcsl_1_1ISum_1a1b7f9344411c6dbf4e132798833c6a68">isIndexed</reimplementedby>
        <reimplementedby refid="classcsl_1_1Polynomial_1a83502630a7e4016e818c2f8332a68594">isIndexed</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1acb1ea1810e83874623d07f370efde5c2">isIndexed</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1ad9ce7a5183d105402cdafab290b93c91">isIndexed</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1acc36470e69d6edf43f6dd7b6db0365d2">isIndexed</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1a9bc54de57d7301838f673c014ed9d79f">isIndexed</reimplementedby>
        <reimplementedby refid="classcsl_1_1VectorIntegral_1ab3961d7313002bd6e4d0c342bd2cd9a1">isIndexed</reimplementedby>
        <reimplementedby refid="classmty_1_1FermionPropStruct_1a87eedca3ca384eee83372ecaef79e372">isIndexed</reimplementedby>
        <reimplementedby refid="classmty_1_1FeynmanIntegral_1a2356dc790afafc8a0f102490f47dc5b5">isIndexed</reimplementedby>
        <reimplementedby refid="classmty_1_1Propagator_1a64bb51cbde78978918ab6f6d2e79d675">isIndexed</reimplementedby>
        <reimplementedby refid="classmty_1_1QuantumField_1ac75fb08538ad65a86c3cd814de873e4c">isIndexed</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><bold>True</bold> if the expression is indexed. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="209" column="18" bodyfile="src/csl/abstract.cpp" bodystart="503" bodyend="506"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ac73aba0c48a4b5740f7bfa09e438ca99" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::isReal</definition>
        <argsstring>() const</argsstring>
        <name>isReal</name>
        <qualifiedname>csl::Abstract::isReal</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1afcc87b9f871955a482fa7c435c5ab68c">isReal</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1ae6828f21be014625ca502d5f40981502">isReal</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1ae240dfbf5dec5abdcd3006e69b40563c">isReal</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a2160f94ea8c3453104f4f38cdf87dc12">isReal</reimplementedby>
        <reimplementedby refid="classcsl_1_1BooleanOperator_1af9a8fea573c902be82146ae3e56cf5a3">isReal</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complex_1ad11186b2c93f279247bf3a1ec7ec439d">isReal</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complexified_1a4c69b308c3d305cfa532eb5c653072a0">isReal</reimplementedby>
        <reimplementedby refid="classcsl_1_1ImaginaryPart_1ae015127b4d5f86a99e0914b48b2d7e18">isReal</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1a06954004fdc62d399847915ced3431c2">isReal</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1ae0608fd2fa4b22da81d692483f01b9fb">isReal</reimplementedby>
        <reimplementedby refid="classcsl_1_1RealPart_1afe8b4b055b05d67927ff177b8c5e0d94">isReal</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1a9097ff85c564b700a829fd16ace7e4b3">isReal</reimplementedby>
        <reimplementedby refid="classmty_1_1QuantumField_1a8fd0d9ad227900df5231b0912c6a7320">isReal</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="211" column="18" bodyfile="src/csl/abstract.cpp" bodystart="508" bodyend="511"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1acb67e8e96735b8f116d0e7ab33d7be77" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::isPurelyImaginary</definition>
        <argsstring>() const</argsstring>
        <name>isPurelyImaginary</name>
        <qualifiedname>csl::Abstract::isPurelyImaginary</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1ab71346e18c63f56e01526b34783d34cc">isPurelyImaginary</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1ade1aa692134fee323c2a20824932b506">isPurelyImaginary</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1a7ba1daf07d310140f4c417e23d37e6eb">isPurelyImaginary</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a43c9ebd8953d2f51b7bc7a8b7e97ccd3">isPurelyImaginary</reimplementedby>
        <reimplementedby refid="classcsl_1_1BooleanOperator_1a323c74fa5260e24f6da692f42155c493">isPurelyImaginary</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complex_1af7a51edded0bfb795da8c3d3521b2d75">isPurelyImaginary</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complexified_1aa3de4cb73eb624830da28f07ef0fa4d4">isPurelyImaginary</reimplementedby>
        <reimplementedby refid="classcsl_1_1ImaginaryPart_1a0eaf96b5e9c097907357acb5cd637130">isPurelyImaginary</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1a217c3b0f93aa2cbb24bca5a70dbe7384">isPurelyImaginary</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1a1ae03daccbb1d0ff134d51f8b2a64fb4">isPurelyImaginary</reimplementedby>
        <reimplementedby refid="classcsl_1_1RealPart_1a794e67cfc724500de30cf4de91f81d63">isPurelyImaginary</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1ae03e0ca52605cf8b352c0b55674ef198">isPurelyImaginary</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="213" column="18" bodyfile="src/csl/abstract.cpp" bodystart="513" bodyend="516"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a22a594845a29429c9b4f19c92bd18cad" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::isComplexConjugate</definition>
        <argsstring>() const</argsstring>
        <name>isComplexConjugate</name>
        <qualifiedname>csl::Abstract::isComplexConjugate</qualifiedname>
        <reimplementedby refid="classcsl_1_1Complexified_1a3f583f018b34b63b321976a8bcedf430">isComplexConjugate</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="215" column="18" bodyfile="src/csl/abstract.cpp" bodystart="518" bodyend="521"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1af2ce38838e35c5785f92373a1d830668" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::isHermitianConjugate</definition>
        <argsstring>() const</argsstring>
        <name>isHermitianConjugate</name>
        <qualifiedname>csl::Abstract::isHermitianConjugate</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="217" column="18" bodyfile="src/csl/abstract.cpp" bodystart="523" bodyend="526"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a470d9f1267fba4a82e13af4a39470f81" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0e" kindref="member">csl::ComplexProperty</ref></type>
        <definition>csl::ComplexProperty csl::Abstract::getComplexProperty</definition>
        <argsstring>() const</argsstring>
        <name>getComplexProperty</name>
        <qualifiedname>csl::Abstract::getComplexProperty</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractElement_1a0b2c014c2c35cad27d9df5240bfb8548">getComplexProperty</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complexified_1a3579397ed08ed6d5a027e69d49f54a59">getComplexProperty</reimplementedby>
        <reimplementedby refid="classcsl_1_1Constant_1a15735420c900f77bbbf5553dad5bf6c2">getComplexProperty</reimplementedby>
        <reimplementedby refid="classcsl_1_1Imaginary_1a3c3c7924a7849335d01370e0afb50f6d">getComplexProperty</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1ad53cd1d4ef87b4975190f26b0b08d747">getComplexProperty</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="219" column="34" bodyfile="src/csl/abstract.cpp" bodystart="528" bodyend="533"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ae35385480a1be08f5e7433535b58ac0b" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::setComplexProperty</definition>
        <argsstring>(csl::ComplexProperty prop)</argsstring>
        <name>setComplexProperty</name>
        <qualifiedname>csl::Abstract::setComplexProperty</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractElement_1a7d9bb4605dbd97ea98f721611adadd72">setComplexProperty</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a135c8f0acf06bfc038a459a3283e309b">setComplexProperty</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complexified_1aeef08a8dd0256b5e9f6aa0cb0a40e936">setComplexProperty</reimplementedby>
        <reimplementedby refid="classcsl_1_1Constant_1acb60a110ea90e6519c5a80a49984b759">setComplexProperty</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1a987b31dab7bf754dbe034a4a7dc0cf2e">setComplexProperty</reimplementedby>
        <param>
          <type><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0e" kindref="member">csl::ComplexProperty</ref></type>
          <declname>prop</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="221" column="18" bodyfile="src/csl/abstract.cpp" bodystart="535" bodyend="537"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a37ebc247831d6629d44117a490fca120" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::setConjugated</definition>
        <argsstring>(bool t_conjugated)</argsstring>
        <name>setConjugated</name>
        <qualifiedname>csl::Abstract::setConjugated</qualifiedname>
        <reimplementedby refid="classcsl_1_1Complexified_1a22b60556c965e51ab733e6eb5441783c">setConjugated</reimplementedby>
        <param>
          <type>bool</type>
          <declname>t_conjugated</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="223" column="18" bodyfile="src/csl/abstract.cpp" bodystart="539" bodyend="541"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a9a014bfd266b5f8471f23580e271979b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::isInteger</definition>
        <argsstring>() const</argsstring>
        <name>isInteger</name>
        <qualifiedname>csl::Abstract::isInteger</qualifiedname>
        <reimplementedby refid="classcsl_1_1Float_1a2588061b9db6b5af2253bc181b859ef8">isInteger</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integer_1ac5571ab9be29c389391e69d8794b93a8">isInteger</reimplementedby>
        <briefdescription>
<para>Tells if the expression is an integer. Either an <ref refid="classcsl_1_1Integer" kindref="compound">Integer</ref> object directly, or a <ref refid="classcsl_1_1Float" kindref="compound">Float</ref> that has an integer value. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><bold>True</bold> if <emphasis>*this</emphasis> is an <ref refid="classcsl_1_1Integer" kindref="compound">Integer</ref> or a <ref refid="classcsl_1_1Float" kindref="compound">Float</ref> with integer value. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="238" column="18" bodyfile="src/csl/abstract.cpp" bodystart="543" bodyend="546"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a628563238145f3a9acc331f1a89ce32f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::getValued</definition>
        <argsstring>() const</argsstring>
        <name>getValued</name>
        <qualifiedname>csl::Abstract::getValued</qualifiedname>
        <reimplementedby refid="classcsl_1_1Constant_1a8e05cf80cbeffe60e0e09bc9d15001bd">getValued</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1ad0ba237abda5d2a01a50a36a5daf6248">getValued</reimplementedby>
        <briefdescription>
<para>Tells if the expression is valued, i.e. is a function of numbers and valued literals (a <ref refid="classcsl_1_1Variable" kindref="compound">Variable</ref> or <ref refid="classcsl_1_1Constant" kindref="compound">Constant</ref> is not valued by default). </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><bold>True</bold> if the expression is valued. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="244" column="18" bodyfile="src/csl/abstract.cpp" bodystart="173" bodyend="178"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a78f98ba06476e464e3fd2fce0d1f8243" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>long double</type>
        <definition>long double csl::Abstract::getValue</definition>
        <argsstring>() const</argsstring>
        <name>getValue</name>
        <qualifiedname>csl::Abstract::getValue</qualifiedname>
        <reimplementedby refid="classcsl_1_1Constant_1a96386d249c7171141d18c9b48cfa5a33">getValue</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFactorial_1a579d7c365479e561e598195e10da65f9">getValue</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1aed2e30529caec691269a11608b678e41">getValue</reimplementedby>
        <briefdescription>
<para>Returns the value of the expression, if it has one <bold>explicitely</bold>. In particular, it will work only on Numbers and valued Literals, not on functions. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The value of the expression. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="249" column="25" bodyfile="src/csl/abstract.cpp" bodystart="548" bodyend="553"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a69a657baf1c35ed581e9db2c47a71c99" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>long double</type>
        <definition>long double csl::Abstract::getDeltaPlus</definition>
        <argsstring>() const</argsstring>
        <name>getDeltaPlus</name>
        <qualifiedname>csl::Abstract::getDeltaPlus</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="251" column="25" bodyfile="src/csl/abstract.cpp" bodystart="555" bodyend="558"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aa22f0e4c9c91f43b5cd61cbb873869eb" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>long double</type>
        <definition>long double csl::Abstract::getDeltaMinus</definition>
        <argsstring>() const</argsstring>
        <name>getDeltaMinus</name>
        <qualifiedname>csl::Abstract::getDeltaMinus</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="253" column="25" bodyfile="src/csl/abstract.cpp" bodystart="560" bodyend="563"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a6aa6bcc7cb8ee1574f29dc6ab6c6f0ed" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>long long int</type>
        <definition>long long int csl::Abstract::getNum</definition>
        <argsstring>() const</argsstring>
        <name>getNum</name>
        <qualifiedname>csl::Abstract::getNum</qualifiedname>
        <reimplementedby refid="classcsl_1_1Arbitrary_1a0e1f9042536b8ec8f361e7fd556b58d4">getNum</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFraction_1aafccd523414a7c7ae8d2a4081bbc76a8">getNum</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The numerator for a <ref refid="classcsl_1_1IntFraction" kindref="compound">IntFraction</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="261" column="27" bodyfile="src/csl/abstract.cpp" bodystart="180" bodyend="183"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a9531d78d67c82e288c0130da5b1ba80b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>long long int</type>
        <definition>long long int csl::Abstract::getDenom</definition>
        <argsstring>() const</argsstring>
        <name>getDenom</name>
        <qualifiedname>csl::Abstract::getDenom</qualifiedname>
        <reimplementedby refid="classcsl_1_1IntFraction_1ab3c87296f84c24abd4e5d0531b992404">getDenom</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The denominator for a <ref refid="classcsl_1_1IntFraction" kindref="compound">IntFraction</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="264" column="27" bodyfile="src/csl/abstract.cpp" bodystart="185" bodyend="188"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aa034448201c9e7998bbbb5e409636b30" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>int</type>
        <definition>int csl::Abstract::getNArgs</definition>
        <argsstring>(int axis=0) const</argsstring>
        <name>getNArgs</name>
        <qualifiedname>csl::Abstract::getNArgs</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1a2effb7bc0153b8c4e6d3c695d3b245cb">getNArgs</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1ae32e5909a9d7616ceac05b22a74b1284">getNArgs</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1af12bbdfb8a1b45d722d37f2444443457">getNArgs</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a2689157ec6445f198e36dadb4d9aef78">getNArgs</reimplementedby>
        <param>
          <type>int</type>
          <declname>axis</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Returns the number of arguments of the expression. If the expression is a building block (<ref refid="classcsl_1_1AbstractBuildingBlock" kindref="compound">AbstractBuildingBlock</ref>), this function returns 0. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The number of arguments of the expression. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="275" column="17" bodyfile="src/csl/abstract.cpp" bodystart="190" bodyend="194"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a3794843945b8a39e2c1be073c9bacdf5" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>size_t</type>
        <definition>size_t csl::Abstract::size</definition>
        <argsstring>() const</argsstring>
        <name>size</name>
        <qualifiedname>csl::Abstract::size</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1a0c134489522dacd21756e7faaafed79c">size</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1ab02f71922f94812d9ef24766ce51aaa2">size</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1a773f619ff0c678e3d1e8e34559a00d50">size</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1ad9eb779b7f16721eb18b6a47037db518">size</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1a877666789a952f0dbf0e37bd91383108">size</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="277" column="20" bodyfile="src/csl/abstract.cpp" bodystart="418" bodyend="421"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a0c3c3fe5010f24e8a8765ea06415c003" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::empty</definition>
        <argsstring>() const</argsstring>
        <name>empty</name>
        <qualifiedname>csl::Abstract::empty</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1ada1ce81d61672e15a142fe8d3bee98bd">empty</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="279" column="18" bodyfile="src/csl/abstract.cpp" bodystart="423" bodyend="428"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aad54ed41b2ce9bad3364fe30ad1a0d71" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>csl::vector_expr::iterator</type>
        <definition>csl::vector_expr::iterator csl::Abstract::begin</definition>
        <argsstring>()</argsstring>
        <name>begin</name>
        <qualifiedname>csl::Abstract::begin</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1a6236c27a797993973fb45dc9f4906962">begin</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1aa8225d3dd07be192735c766e8d267774">begin</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A csl::vector_expr::iterator at the beginning of argument for multi-argument expressions. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="284" column="40" bodyfile="src/csl/abstract.cpp" bodystart="430" bodyend="435"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a61e4e80d998a888a1a74d9ea3e10c0f1" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>csl::vector_expr::iterator</type>
        <definition>csl::vector_expr::iterator csl::Abstract::end</definition>
        <argsstring>()</argsstring>
        <name>end</name>
        <qualifiedname>csl::Abstract::end</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1a178ccaec7d4546873084591d93398153">end</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a06f69d432a047d7b48757d8362de68d4">end</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A csl::vector_expr::iterator at the end of argument for multi-argument expressions. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="289" column="40" bodyfile="src/csl/abstract.cpp" bodystart="437" bodyend="442"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1adff373df9477d4e38581d09cc6d2fee4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>csl::vector_expr::const_iterator</type>
        <definition>csl::vector_expr::const_iterator csl::Abstract::begin</definition>
        <argsstring>() const</argsstring>
        <name>begin</name>
        <qualifiedname>csl::Abstract::begin</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1aa405a3e5cd03bb390ce3e804fe8af806">begin</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a135f3df162ac8e7128a3e666e26cb81b">begin</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A csl::vector_expr::iterator at the beginning of argument for multi-argument expressions. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="294" column="46" bodyfile="src/csl/abstract.cpp" bodystart="444" bodyend="449"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ae2761d54f13310e13f5076d565edd7ef" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>csl::vector_expr::const_iterator</type>
        <definition>csl::vector_expr::const_iterator csl::Abstract::end</definition>
        <argsstring>() const</argsstring>
        <name>end</name>
        <qualifiedname>csl::Abstract::end</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1a42f8f99108068dca2bd7a259577a0bcf">end</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1ada11a590d79c87baf92a98888ee32c44">end</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A csl::vector_expr::iterator at the end of argument for multi-argument expressions. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="299" column="46" bodyfile="src/csl/abstract.cpp" bodystart="451" bodyend="456"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ac33a42309d629d47bfdbede4e152414e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
        <definition>Expr const  &amp; csl::Abstract::getArgument</definition>
        <argsstring>(int iArg=0) const</argsstring>
        <name>getArgument</name>
        <qualifiedname>csl::Abstract::getArgument</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1a6db2c19ea96bee60189534d583fc2af3">getArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1adf8cb8650883f5ea7729cdabec2aeab0">getArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1a75ae783c1bd8e55ccc005af538599def">getArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a2320c9f9c71eb81a2348175dd14404a9">getArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1a3f571d26e241f9a943e11191c3ebe9a6">getArgument</reimplementedby>
        <param>
          <type>int</type>
          <declname>iArg</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="warning"><para>This function must not be called for building blocks, one must check first that the expression has arguments. </para>
</simplesect>
<simplesect kind="return"><para>The i^{th} argument of the expression. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="305" column="24" bodyfile="src/csl/abstract.cpp" bodystart="458" bodyend="463"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a06f542034e95744148f4fce5a4893e63" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
        <definition>Expr &amp; csl::Abstract::getArgument</definition>
        <argsstring>(int iArg=0)</argsstring>
        <name>getArgument</name>
        <qualifiedname>csl::Abstract::getArgument</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1abd56e93ef0544827fa7931f68b8edd06">getArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1af02355fee3c7cda15993cfcf553d6f92">getArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1af168c84e071262cc48108cf991526651">getArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a0fbb75333c68d6c9a2d2e277d34bca3f">getArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1af2b7c69a2465d6c4c302c97a275d44a8">getArgument</reimplementedby>
        <param>
          <type>int</type>
          <declname>iArg</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="307" column="18" bodyfile="src/csl/abstract.cpp" bodystart="467" bodyend="472"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a898d6cf2a7f348feacab189447bee1eb" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
        <definition>Expr const  &amp; csl::Abstract::getArgument</definition>
        <argsstring>(const std::vector&lt; int &gt; &amp;indices) const</argsstring>
        <name>getArgument</name>
        <qualifiedname>csl::Abstract::getArgument</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a7a03ddf294e576016a8114f46eb900f9">getArgument</reimplementedby>
        <param>
          <type>const std::vector&lt; int &gt; &amp;</type>
          <declname>indices</declname>
        </param>
        <briefdescription>
<para>Allows to get specific arguments of expressions in multiple dimensions, by giving the indices in each dimension. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="warning"><para>This function must not be called for building blocks, one must check first that the expression has arguments. </para>
</simplesect>
<simplesect kind="return"><para>The argument {i,j,...} of the expression. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="315" column="24" bodyfile="src/csl/abstract.cpp" bodystart="474" bodyend="479"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aa689fb64eecb86edbde6c745d1ce756b" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
        <definition>Expr &amp; csl::Abstract::getArgument</definition>
        <argsstring>(const std::vector&lt; int &gt; &amp;indices)</argsstring>
        <name>getArgument</name>
        <qualifiedname>csl::Abstract::getArgument</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a2da0f7388c5c61c4a18c5e5dba6fdd69">getArgument</reimplementedby>
        <param>
          <type>const std::vector&lt; int &gt; &amp;</type>
          <declname>indices</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="317" column="18" bodyfile="src/csl/abstract.cpp" bodystart="481" bodyend="486"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ac83c44ae1e5315a38083bdb7acd8f3fa" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>const csl::vector_expr &amp;</type>
        <definition>const csl::vector_expr &amp; csl::Abstract::getVectorArgument</definition>
        <argsstring>() const</argsstring>
        <name>getVectorArgument</name>
        <qualifiedname>csl::Abstract::getVectorArgument</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1a5e910beb3bdf8459306fe0cda78c1c76">getVectorArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1ad91b47a309a8fc9c5ed9e4b827d84155">getVectorArgument</reimplementedby>
        <briefdescription>
<para>Allows to get the entire std::vector of arguments of the expression. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="warning"><para>This function must not be called for building blocks, one must check first that the expression has arguments. </para>
</simplesect>
<simplesect kind="return"><para>The std::vector of argument. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="324" column="36" bodyfile="src/csl/abstract.cpp" bodystart="410" bodyend="416"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ae85f810bbadbc792210c958e8f1b2ffb" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::getVariable</definition>
        <argsstring>() const</argsstring>
        <name>getVariable</name>
        <qualifiedname>csl::Abstract::getVariable</qualifiedname>
        <reimplementedby refid="classcsl_1_1Derivative_1a257f22195ee64163e7ff5ee99b6ecdc1">getVariable</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integral_1a0a44c0ebf7c356c5ee7ac288b471edb9">getVariable</reimplementedby>
        <reimplementedby refid="classcsl_1_1Polynomial_1ad633f5e1ef2f0d4984bb268b65ebafec">getVariable</reimplementedby>
        <reimplementedby refid="classcsl_1_1ScalarIntegral_1a330a8f285ec3b13b75cd444d88f1fd67">getVariable</reimplementedby>
        <reimplementedby refid="classcsl_1_1VectorIntegral_1a0bdc27a5f2a2533af9aaf96f4582ed07">getVariable</reimplementedby>
        <briefdescription>
<para>Accessor to the variable that defines certain types of expressions. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><bold>variable</bold>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="333" column="18" bodyfile="src/csl/abstract.cpp" bodystart="908" bodyend="911"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a9500a21d75d03c695ec0c76493600b38" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>int</type>
        <definition>int csl::Abstract::getOrder</definition>
        <argsstring>() const</argsstring>
        <name>getOrder</name>
        <qualifiedname>csl::Abstract::getOrder</qualifiedname>
        <reimplementedby refid="classcsl_1_1Derivative_1a8debf6f0fe771b1c0fa0280faf0f3283">getOrder</reimplementedby>
        <reimplementedby refid="classcsl_1_1Polynomial_1acdfc0c1919d2b4989019e53a80c89f33">getOrder</reimplementedby>
        <briefdescription>
<para>Accessor to the order (integer) that defines certain types of expressions. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><bold>order</bold>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="339" column="17" bodyfile="src/csl/abstract.cpp" bodystart="595" bodyend="600"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aa83df1d9dc202457113e5b38bd694fae" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>int</type>
        <definition>int csl::Abstract::getSign</definition>
        <argsstring>() const</argsstring>
        <name>getSign</name>
        <qualifiedname>csl::Abstract::getSign</qualifiedname>
        <reimplementedby refid="classcsl_1_1Commutator_1abac8376052445d0359e4919f781f185d">getSign</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The <bold>sign</bold> for a <ref refid="classcsl_1_1Commutator" kindref="compound">Commutator</ref> type expression. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="343" column="17" bodyfile="src/csl/abstract.cpp" bodystart="602" bodyend="607"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a9347e75b0cd0b75e0f0a38db93b29d83" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::isAnOperator</definition>
        <argsstring>() const</argsstring>
        <name>isAnOperator</name>
        <qualifiedname>csl::Abstract::isAnOperator</qualifiedname>
        <reimplementedby refid="classcsl_1_1Operator_1a740ec7cf6f100e21ab3e6e1dde93374b">isAnOperator</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1a740ec7cf6f100e21ab3e6e1dde93374b">isAnOperator</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1a740ec7cf6f100e21ab3e6e1dde93374b">isAnOperator</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1a740ec7cf6f100e21ab3e6e1dde93374b">isAnOperator</reimplementedby>
        <briefdescription>
<para>Tells if the expression is an operator (like a derivetive operator). </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><bold>True</bold> if the expression is an <ref refid="classcsl_1_1Operator" kindref="compound">Operator</ref>. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="349" column="18" bodyfile="src/csl/abstract.cpp" bodystart="609" bodyend="612"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a464f4f0613db9b4b0a4efe26a3a03d60" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::isEmpty</definition>
        <argsstring>() const</argsstring>
        <name>isEmpty</name>
        <qualifiedname>csl::Abstract::isEmpty</qualifiedname>
        <reimplementedby refid="classcsl_1_1Operator_1aee71c873c2f3042ea748f1e9e07f7d6c">isEmpty</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1aee71c873c2f3042ea748f1e9e07f7d6c">isEmpty</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1aee71c873c2f3042ea748f1e9e07f7d6c">isEmpty</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1aee71c873c2f3042ea748f1e9e07f7d6c">isEmpty</reimplementedby>
        <briefdescription>
<para>Tells for a <ref refid="classcsl_1_1Derivative" kindref="compound">Derivative</ref> or an <ref refid="classcsl_1_1Integral" kindref="compound">Integral</ref> if the argument is empty i.e. if the object must apply on the next argument encountered on the right. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><bold>True</bold> if the <ref refid="classcsl_1_1Derivative" kindref="compound">Derivative</ref> or <ref refid="classcsl_1_1Integral" kindref="compound">Integral</ref> awaits an argument. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="356" column="18" bodyfile="src/csl/abstract.cpp" bodystart="614" bodyend="619"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a75d9abfa88d9d09a89d3a4becd9e6429" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::operatorAppliesOn</definition>
        <argsstring>(Expr_info expr) const</argsstring>
        <name>operatorAppliesOn</name>
        <qualifiedname>csl::Abstract::operatorAppliesOn</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractIntegral_1a582655eaae1d2cae4084fbda6f1c64f7">operatorAppliesOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1Derivative_1a18753e44375a06fe88dfebb3308751e5">operatorAppliesOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1ImaginaryPart_1a7f64a21b5e2f5805c43b7f7226633547">operatorAppliesOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integral_1a2fd4f32293d42cfa077b425c72dc55fe">operatorAppliesOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1RealPart_1a8d8d56ddd9a937687c68073ae5c8dabb">operatorAppliesOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1adf338110c2e609411e6e82120c3c5013">operatorAppliesOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1VectorIntegral_1a5d205d4d8851e175d20412464a6023fb">operatorAppliesOn</reimplementedby>
        <reimplementedby refid="classmty_1_1Wick_1adfcfc33cfd36ed41e9193766e196ff1b">operatorAppliesOn</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="358" column="18" bodyfile="src/csl/abstract.cpp" bodystart="621" bodyend="626"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a9c3ec3dfe1fbd8ead5c8d9aca421a863" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::getOperand</definition>
        <argsstring>() const</argsstring>
        <name>getOperand</name>
        <qualifiedname>csl::Abstract::getOperand</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractIntegral_1a0e22ef62f91cf61f7d3067d7ae4af007">getOperand</reimplementedby>
        <reimplementedby refid="classcsl_1_1Derivative_1a08574b1aa7967ca4f6b98f4ed9534bc0">getOperand</reimplementedby>
        <reimplementedby refid="classcsl_1_1ImaginaryPart_1abaabfff6c5bbda6ce39627bf632d380d">getOperand</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integral_1a304552a9becfb10cb337210117de575c">getOperand</reimplementedby>
        <reimplementedby refid="classcsl_1_1RealPart_1a10e389ad0a81beffe8c0a134f4f48847">getOperand</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1aba17709ddc3ea5ae260a6b713a032355">getOperand</reimplementedby>
        <reimplementedby refid="classmty_1_1Wick_1a2867e3ba4a214f063df3d7f22c73af21">getOperand</reimplementedby>
        <briefdescription>
<para>Returns the operand of an <ref refid="classcsl_1_1Operator" kindref="compound">Operator</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><bold>operand</bold> of an <ref refid="classcsl_1_1Operator" kindref="compound">Operator</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="363" column="18" bodyfile="src/csl/abstract.cpp" bodystart="628" bodyend="634"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a625efe55a17b97a1c0f085bdbf3a962a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::vector&lt; int &gt;</type>
        <definition>vector&lt; int &gt; csl::Abstract::getShape</definition>
        <argsstring>() const</argsstring>
        <name>getShape</name>
        <qualifiedname>csl::Abstract::getShape</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a8cee385d5b699162c8a400e4b44ed7d7">getShape</reimplementedby>
        <briefdescription>
<para>Accessor to the shape of the tensor in the form of a std::vector of integers. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><bold>shape</bold>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="373" column="25" bodyfile="src/csl/abstract.cpp" bodystart="405" bodyend="408"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a3d6b1e294cf24dea17c3c4361226138b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::getInfBoundary</definition>
        <argsstring>() const</argsstring>
        <name>getInfBoundary</name>
        <qualifiedname>csl::Abstract::getInfBoundary</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractIntegral_1a5e2cb02036b59f4464171827f6ee571c">getInfBoundary</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integral_1ae9bdb2dc1ade49e8146acd13ed0f54cd">getInfBoundary</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="379" column="18" bodyfile="src/csl/abstract.cpp" bodystart="1164" bodyend="1169"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a2fcc223dbf5d880e923c07df142df5c8" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::getSupBoundary</definition>
        <argsstring>() const</argsstring>
        <name>getSupBoundary</name>
        <qualifiedname>csl::Abstract::getSupBoundary</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractIntegral_1a47ca4952bec0b1baa08f38560d287adf">getSupBoundary</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integral_1a0cd3b45c79f3137aff11562e70d78853">getSupBoundary</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="381" column="18" bodyfile="src/csl/abstract.cpp" bodystart="1183" bodyend="1188"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aad7104a5b8855272a92a47c58f29e958" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::setSupBoundary</definition>
        <argsstring>(Expr const &amp;t_inf)</argsstring>
        <name>setSupBoundary</name>
        <qualifiedname>csl::Abstract::setSupBoundary</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractIntegral_1ac6597e5d240e330fe823c42ba1a55d5f">setSupBoundary</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>t_inf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="383" column="18" bodyfile="src/csl/abstract.cpp" bodystart="1171" bodyend="1175"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a5ecdb6ce7a2d9643da2f6161a06dfbbf" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::setInfBoundary</definition>
        <argsstring>(Expr const &amp;t_inf)</argsstring>
        <name>setInfBoundary</name>
        <qualifiedname>csl::Abstract::setInfBoundary</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractIntegral_1a1094c1bb7a0748fa855b8f2c2bb8705f">setInfBoundary</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>t_inf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="385" column="18" bodyfile="src/csl/abstract.cpp" bodystart="1177" bodyend="1181"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1add364193f7a78ac28f7001c7f4036453" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>int</type>
        <definition>int csl::Abstract::getNIndices</definition>
        <argsstring>() const</argsstring>
        <name>getNIndices</name>
        <qualifiedname>csl::Abstract::getNIndices</qualifiedname>
        <reimplementedby refid="classcsl_1_1TensorElement_1a5ddd03efb94ea0017def76cd6777f745">getNIndices</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The number of indices of an <bold>Indicial</bold> expression. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="394" column="17" bodyfile="src/csl/abstract.cpp" bodystart="196" bodyend="201"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a3234ce243f6a2e11950be42f10100943" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Index" kindref="compound">Index</ref></type>
        <definition>Index csl::Abstract::getIndex</definition>
        <argsstring>(int i=0) const</argsstring>
        <name>getIndex</name>
        <qualifiedname>csl::Abstract::getIndex</qualifiedname>
        <reimplementedby refid="classcsl_1_1TensorElement_1a029c4358822daed54f4f775032896790">getIndex</reimplementedby>
        <param>
          <type>int</type>
          <declname>i</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>i</parametername>
</parameternamelist>
<parameterdescription>
<para>Spot of the index to get. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the i^{th} index of an <bold>Indicial</bold> expression. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="399" column="19" bodyfile="src/csl/abstract.cpp" bodystart="203" bodyend="208"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1af0d95f3edc0562b1d75d60b670119842" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::resetIndexStructure</definition>
        <argsstring>()</argsstring>
        <name>resetIndexStructure</name>
        <qualifiedname>csl::Abstract::resetIndexStructure</qualifiedname>
        <reimplementedby refid="classcsl_1_1TensorElement_1a1ca07618e533c2ca4b4cc3646195a64d">resetIndexStructure</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="401" column="18" bodyfile="src/csl/abstract.cpp" bodystart="210" bodyend="212"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ae125a32b6f3d0368b6055d4e58c1ff3f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1IndexStructure" kindref="compound">IndexStructure</ref></type>
        <definition>IndexStructure csl::Abstract::getIndexStructure</definition>
        <argsstring>() const</argsstring>
        <name>getIndexStructure</name>
        <qualifiedname>csl::Abstract::getIndexStructure</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1a7b6c806179b294bbbcd606cb9257fd99">getIndexStructure</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1a53ef9c900304f02f54ce6ea1485b4537">getIndexStructure</reimplementedby>
        <reimplementedby refid="classcsl_1_1IProd_1ae5870d95277493876ab0464e98d30c6a">getIndexStructure</reimplementedby>
        <reimplementedby refid="classcsl_1_1ISum_1ab5cffff2ab64b2f15099955102849bdb">getIndexStructure</reimplementedby>
        <reimplementedby refid="classcsl_1_1Polynomial_1a7990b3e8d7eb1fc76e6270c71eb4a89c">getIndexStructure</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1aab730479855c747fa6baafe4c50ca8cf">getIndexStructure</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1a3dc05ca45a03e8a7f8459812e07b85f6">getIndexStructure</reimplementedby>
        <reimplementedby refid="classcsl_1_1VectorIntegral_1a2b23eb2012ae1b985e0e2318f11cf3f5">getIndexStructure</reimplementedby>
        <reimplementedby refid="classmty_1_1FermionPropStruct_1a1c804a9b083017522ea907130f9ddda9">getIndexStructure</reimplementedby>
        <reimplementedby refid="classmty_1_1Propagator_1a4eed1878efc6b43f841bc7a5a660801a">getIndexStructure</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The index structure of the <bold>Indicial</bold> expression </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="405" column="28" bodyfile="src/csl/abstract.cpp" bodystart="214" bodyend="217"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ae6a9a9ef3efd6bb83b62c0a353742d25" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1IndexStructure" kindref="compound">IndexStructure</ref></type>
        <definition>IndexStructure csl::Abstract::getIndexStructure</definition>
        <argsstring>(csl::Space const *space) const</argsstring>
        <name>getIndexStructure</name>
        <qualifiedname>csl::Abstract::getIndexStructure</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Space" kindref="compound">csl::Space</ref> const *</type>
          <declname>space</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="407" column="20" bodyfile="src/csl/abstract.cpp" bodystart="219" bodyend="228"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1addb848bf4cdea207484a71e9b1006ead" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>const <ref refid="classcsl_1_1IndexStructure" kindref="compound">IndexStructure</ref> &amp;</type>
        <definition>const IndexStructure &amp; csl::Abstract::getIndexStructureView</definition>
        <argsstring>() const</argsstring>
        <name>getIndexStructureView</name>
        <qualifiedname>csl::Abstract::getIndexStructureView</qualifiedname>
        <reimplementedby refid="classcsl_1_1TensorElement_1abe312de6a76204dfcdc98cf4711bf353">getIndexStructureView</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="409" column="34" bodyfile="src/csl/abstract.cpp" bodystart="230" bodyend="236"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a632e28530a68539fadacd7ab7ffc8be1" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1IndexStructure" kindref="compound">IndexStructure</ref> &amp;</type>
        <definition>IndexStructure &amp; csl::Abstract::getIndexStructureView</definition>
        <argsstring>()</argsstring>
        <name>getIndexStructureView</name>
        <qualifiedname>csl::Abstract::getIndexStructureView</qualifiedname>
        <reimplementedby refid="classcsl_1_1TensorElement_1a15b5b8ef2a249fda36f7491b634270fb">getIndexStructureView</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="411" column="28" bodyfile="src/csl/abstract.cpp" bodystart="238" bodyend="244"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aa4136dc23f1fba4bf897b54c8592ccfc" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1IndexStructure" kindref="compound">IndexStructure</ref></type>
        <definition>IndexStructure csl::Abstract::getFreeIndexStructure</definition>
        <argsstring>() const</argsstring>
        <name>getFreeIndexStructure</name>
        <qualifiedname>csl::Abstract::getFreeIndexStructure</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The free index structure of the <bold>Indicial</bold> expression </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="415" column="28" bodyfile="src/csl/abstract.cpp" bodystart="246" bodyend="249"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ab150130c9f67daaf6aba52b9f6b90941" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref></type>
        <definition>Parent csl::Abstract::getParent</definition>
        <argsstring>() const</argsstring>
        <name>getParent</name>
        <qualifiedname>csl::Abstract::getParent</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractElement_1a9e50d48ea0ee472c5c07f3985cc6c641">getParent</reimplementedby>
        <reimplementedby refid="classcsl_1_1Constant_1af7a592da98893ac5bfc3b145ace1fa01">getParent</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1a3eea13fd67db0b8f0b5accea6adefb21">getParent</reimplementedby>
        <reimplementedby refid="classcsl_1_1VectorIntegral_1a956aaa1428471ce72c9c273cd5ce4ac8">getParent</reimplementedby>
        <briefdescription>
<para>For indicial expressions this function returns a pointer to the parent object of type <ref refid="classcsl_1_1TensorParent" kindref="compound">TensorParent</ref> (not an expression). </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><bold>parent</bold> for TensorElement-type expression. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="421" column="20" bodyfile="src/csl/abstract.cpp" bodystart="251" bodyend="254"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a15f775b5add9af8727ead2cfaab78ba2" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1AbstractParent" kindref="compound">Parent_info</ref></type>
        <definition>Parent_info csl::Abstract::getParent_info</definition>
        <argsstring>() const</argsstring>
        <name>getParent_info</name>
        <qualifiedname>csl::Abstract::getParent_info</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractElement_1acde43ab4cab544c3c0aa0d695e67b4ad">getParent_info</reimplementedby>
        <reimplementedby refid="classcsl_1_1Constant_1a1bf504bfdad642c5267dcb48523e6357">getParent_info</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1a2d4f53faf350d6f171e66069ebe62d8c">getParent_info</reimplementedby>
        <reimplementedby refid="classcsl_1_1VectorIntegral_1afc921c41b5d2519cf1aa69be77c3c42a">getParent_info</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="423" column="25" bodyfile="src/csl/abstract.cpp" bodystart="256" bodyend="259"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a06b32036fea6a2583f506a6ef9508d74" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor csl::Abstract::getPoint</definition>
        <argsstring>() const</argsstring>
        <name>getPoint</name>
        <qualifiedname>csl::Abstract::getPoint</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1a1e789c914e462e7f289e56f55ef83076">getPoint</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1a9d3a9a67f2990981805efd146e6fc6fe">getPoint</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1aa82b52395acc9570f21ecca507dde7e2">getPoint</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1ac80748b3601cff1ed0df3b721316b950">getPoint</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="425" column="20" bodyfile="src/csl/abstract.cpp" bodystart="261" bodyend="264"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a42125e9765a771c47819548d342b0b28" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>int</type>
        <definition>int csl::Abstract::getNContractedPairs</definition>
        <argsstring>() const</argsstring>
        <name>getNContractedPairs</name>
        <qualifiedname>csl::Abstract::getNContractedPairs</qualifiedname>
        <briefdescription>
<para>Returns the number of contracted pairs of indices <bold>in an Indicial expression</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The number of contracted pairs of indices. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="431" column="17" bodyfile="src/csl/abstract.cpp" bodystart="377" bodyend="382"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a946d175d946da102c5f4cc91840703cb" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>csl::vector_expr</type>
        <definition>csl::vector_expr csl::Abstract::getPermutations</definition>
        <argsstring>(bool optimize=true) const</argsstring>
        <name>getPermutations</name>
        <qualifiedname>csl::Abstract::getPermutations</qualifiedname>
        <reimplementedby refid="classcsl_1_1TensorElement_1aa0f1ab4f63aa28f3c759a666fb15636a">getPermutations</reimplementedby>
        <param>
          <type>bool</type>
          <declname>optimize</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Returns a std::vector of all possible permutations of an <bold>Indicial</bold> expression. The possible permutations are determined from the posible symmetries and anti-symmetries of the object. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A std::vector containing all possible permutations of the tensor. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="438" column="30" bodyfile="src/csl/abstract.cpp" bodystart="391" bodyend="396"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1af04c0e4426f0bf9df365afe0148d59df" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::set&lt; std::pair&lt; int, int &gt; &gt;</type>
        <definition>set&lt; pair&lt; int, int &gt; &gt; csl::Abstract::getContractedPair</definition>
        <argsstring>() const</argsstring>
        <name>getContractedPair</name>
        <qualifiedname>csl::Abstract::getContractedPair</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>All contracted pairs of indices of an <bold>Indicial</bold> expression. </para>
</simplesect>
<simplesect kind="warning"><para>This function is not yet well implemented and may not be useful in the future. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="445" column="22" bodyfile="src/csl/abstract.cpp" bodystart="398" bodyend="403"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1af29c2898c5d3ba96de8018a0838c402c" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::copy</definition>
        <argsstring>() const</argsstring>
        <name>copy</name>
        <qualifiedname>csl::Abstract::copy</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="452" column="10" bodyfile="src/csl/abstract.h" bodystart="1621" bodyend="1624"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aaa996819710adc3b7529c74a628be623" prot="public" static="no" const="yes" explicit="no" inline="no" virt="pure-virtual">
        <type>unique_Expr</type>
        <definition>virtual unique_Expr csl::Abstract::copy_unique</definition>
        <argsstring>() const =0</argsstring>
        <name>copy_unique</name>
        <qualifiedname>csl::Abstract::copy_unique</qualifiedname>
        <reimplementedby refid="classcsl_1_1Abs_1a9e8bfb1bba417cae71f8065eacd8f981">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1ae3c098ec3de74dad72d9db7d47136a95">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACos_1ad851470aeea63286ecfdcc6f12d156e7">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACosh_1a22a0609753914ac81a791ba995720e59">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1Angle_1a5af8be992760e0f8ad8cdde8de314ade">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1Arbitrary_1a49ab42288e91d3d2fc5d2af3b473b4df">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASin_1a42020c0397a009144d1e65986c655b4f">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASinh_1aa55dfb7b3d6151fe6586ecd74fc916e4">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATan_1a86353f455d43183d37ddca0bf3c6c106">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATanh_1ae09d04d421aa395e7fd816c71fb20e16">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1BooleanOperator_1a560ae0e731ccb57a931eaba5cc568c2f">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1Commutator_1acebde40eb4cc005b398da5a87239708c">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complex_1a3759099b246aa5b877989c77c14f58c2">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1Constant_1a11f44a05bffb953fc4fbd36bc0d04d15">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cos_1af5dcbcf10e42b05c2f0d2aaa815e99e5">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cosh_1a06847c8162010026754a25d076bc21a0">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1Derivative_1ad0c193436a7ed2780f670aa7d5a14f0e">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1DiracDelta_1a1fc27f2e7a215765640cba689d533c8e">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1Exp_1aeaa47fe9059af2c8a48aa34604c220db">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1Factorial_1acbc0b6f14066fe4720adcc375257369e">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1Float_1a66ce8918a94fd410f7d2219545f5d970">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1Imaginary_1afdf5f1cb8b973d3c624a397363d53ed0">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1ImaginaryPart_1af53d7cf2b42dc1fcd33dce9bfc9009d3">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integer_1a669dda9736e0dfb2a6a9936bf29c333d">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integral_1af05740ddb613f991a030a9bfb86e9758">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFactorial_1a8e9ef50e7108a81dc8e1a37a35c7f972">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFraction_1a6e51f37a0cbc06fe486ec1263c344923">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1Log_1acb98dd7d54a887ac3facde5a7f0ac7b6">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1Polynomial_1a8bd5ed06c56cf3688c6ca017f427b959">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1aa65a81928a14ff87976abf1b2535c4e0">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1a6432de87c86ccfa67a36f0f8e0b351a1">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1RealPart_1a1b576eddd5ee0586dceb0cd197067c82">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1ScalarIntegral_1ada84ae9ddd5ebbfa8b720db92aca78e8">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sin_1a80b80bb1066f6b85f30e3c7cde07830f">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sinh_1aabb5ebd4b0d9c5919007a5c1410198e9">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1ab58bfbee5ab0c201025df4c519220fa7">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tan_1aae96cefc727a51f8680fadb9e8383704">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tanh_1ae084bbdef658a0dd37e1217feea4c1aa">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1a36e27ebf0e0c82941829b8ed015a26fc">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1a089c8106691497aa93d1c1f684752110">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1a2fd246ff5dd8ac7e1d1e474ac03b6a57">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1a03953dcb92cc290d5d0c159174921302">copy_unique</reimplementedby>
        <reimplementedby refid="classcsl_1_1VectorIntegral_1af1de791cb43ae4cc093394af35354d75">copy_unique</reimplementedby>
        <reimplementedby refid="classmty_1_1FermionPropStruct_1ad9b8b0a126ba2dfe42cece7d5daef74c">copy_unique</reimplementedby>
        <reimplementedby refid="classmty_1_1FeynmanIntegral_1a50e5b07398345ed989987bf2a92b15e0">copy_unique</reimplementedby>
        <reimplementedby refid="classmty_1_1GeneratorElement_1aa99f75f7b163a58841be014a1b31f9e4">copy_unique</reimplementedby>
        <reimplementedby refid="classmty_1_1PolarizationField_1a49af3f0b5f7b003faab9ac47efeb0d9a">copy_unique</reimplementedby>
        <reimplementedby refid="classmty_1_1Propagator_1ac71a7f6902559bcecad97efaa2ab8d03">copy_unique</reimplementedby>
        <reimplementedby refid="classmty_1_1QuantumField_1a7e4429f566881e4a32e04f735af59766">copy_unique</reimplementedby>
        <reimplementedby refid="classmty_1_1Wick_1af3e25ae449a6e6960643e3795be166a4">copy_unique</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="454" column="25"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a09648782dcf2e81abb5b864f476cc410" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::deepCopy</definition>
        <argsstring>() const</argsstring>
        <name>deepCopy</name>
        <qualifiedname>csl::Abstract::deepCopy</qualifiedname>
        <reimplementedby refid="classcsl_1_1Abs_1a832e6ec5deebe08e37701d7173da5196">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a68121249b62f27fee6927b20e667d4b6">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACos_1a99b03bcbe1a8285e87b212f437a00cfa">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACosh_1a98a21644a917296a1fd580c18c01a835">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1Angle_1ab40319ba597427547a8faa1ebc6fd442">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASin_1a3f11c775ccbe06e2dc6bf21403d85cdc">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASinh_1a5f44031ba4d07c71725cd383e64f038c">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATan_1a014a0345cd159f47c4b1da7ec3f29acc">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATanh_1a35f4d60adf203c00d5e8134bf00dcb44">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1BooleanOperator_1a3f676d20f0fc5753b977723dd1e0149b">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1Commutator_1afe6761309659175ae18a0d4bbf6cfbce">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cos_1ad3853d00f663d05595bcbb0beab7eda8">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cosh_1a4045825eca5dfa4de99e109924a411e2">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1Derivative_1a26bfb0ca01305552d2ac89697fe1dab6">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1DiracDelta_1ab2cb89e4234b7ad19e4f0ce44c9bb00c">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1Exp_1a576d3972188d5376e0d44991f2083ec6">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1Factorial_1acf7df5ba353ced1d4ccae2d290337f66">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1ImaginaryPart_1a44dde51b6af440e4586867276c4d76f4">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integral_1a509500e5bd659b47ec78e8fe8247585a">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1Log_1afbc3c2fdfcbb72d9a6bea0276bb35637">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1Polynomial_1ab9ba2bd77b3fa1b85cb4b8b44dfbc40b">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1ab6c7bd15ee3c7ba272519c6580bdc3e5">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1a6c78b513ad84145b6429d067e637e51d">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1RealPart_1abbd7378363c204c1844e2a932c9d4e29">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1ScalarIntegral_1a515acf05b5178ebc9626c8a60644e85b">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sin_1ae8e5180e61b536c90270637f356e83c3">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sinh_1aa1ad9b8f5d22f7578b4989ce79282323">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1af845c0183f86a68d848358e8e0cedf9a">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tan_1ae8099185abacd31289e149b905f14640">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tanh_1ae392e42e7842f92629e3d6f0a1dbb2b7">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1a85eae07c84149a410984807125d6f556">deepCopy</reimplementedby>
        <reimplementedby refid="classcsl_1_1VectorIntegral_1a01142ce87c05709f76c267b3fa7b60d6">deepCopy</reimplementedby>
        <reimplementedby refid="classmty_1_1FermionPropStruct_1a3ebda495464f3ff5bd89844fe5f43a2a">deepCopy</reimplementedby>
        <reimplementedby refid="classmty_1_1FeynmanIntegral_1aad952dca3a2670200e7f9d7d52aec85f">deepCopy</reimplementedby>
        <reimplementedby refid="classmty_1_1Propagator_1aeed6121c2788b74c9b8919ced2ee2615">deepCopy</reimplementedby>
        <reimplementedby refid="classmty_1_1Wick_1a68069b18da724b37c30fc47fc7d889e0">deepCopy</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="456" column="18" bodyfile="src/csl/abstract.cpp" bodystart="690" bodyend="693"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aaeab3809e91989adbdf29c3f56d905b6" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::refresh</definition>
        <argsstring>() const</argsstring>
        <name>refresh</name>
        <qualifiedname>csl::Abstract::refresh</qualifiedname>
        <reimplementedby refid="classcsl_1_1Abs_1a4ef231b350c82884e6eda81463de85b7">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a4164e7fdb8f91e942bc8be981c321e39">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACos_1a6b822acc939c34ec38d7151e4fc2bea3">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACosh_1a1f3fbdfd90c21971d0958a4d1bbb0900">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Angle_1a7eccdd4149e54c0f46493156746c777b">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASin_1a3174a0c5bf6e08d1104dc2f3bb5d33bf">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASinh_1a18c71b51195423ac14941c161e307e11">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATan_1a5cf50f73e04e1fbb2bfe4259bc4be143">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATanh_1a2d658eb10ef51b123e33859f57f025cc">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1BooleanOperator_1a709bfc0016755b4719631504bca96c9b">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Commutator_1adeb9429718baac7a4febda797a6a7c1c">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complex_1aa4b9a83722d6088da865e5c3ff74f0ab">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cos_1ac3ca4c97da349619de812b35cd8bba19">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cosh_1a3e930ac5d94ffc7f2689e208a4210098">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Derivative_1ad7e771fbafdf54c92dce227e04274617">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1DiracDelta_1abbbd226a80ecc0158198c91c18439aa7">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Exp_1a92912c020966505d6d7be8e2974711e4">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Factorial_1af37794011a7d18012b911cde59b04769">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Float_1af1315466029c7a1a8825843cfbccc4f7">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1ImaginaryPart_1a02ff39bf7a81c4a2f5e7183c601fb494">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integral_1a186ba6cd9df4e179bfd9c83e3ed4950f">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFactorial_1ad411005860f73fc135c22d607928633e">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFraction_1a98cf13cca04face0520b8e60095be66b">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Log_1a0cbc3d7f19c222dee17ad751e24841c5">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Polynomial_1ae21066ba070523572cbdc1897a43135f">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1aa9052e1a1df74dbf75b848b52bfab391">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1a77738ecfdfe91ca3ca95c95b725be576">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1RealPart_1ac746e897ce3481218355b4616293d337">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1ScalarIntegral_1a6de5c328f096c9b52de27142fd05bd17">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sin_1abd398268ec1f0af72b03e8286c8f5a38">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sinh_1a08006a166b47e1f6ff53f74f323134c8">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1ac51d6c285b472a82f58891277d55b7a0">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tan_1a2be2822bd3323c2885f3a5e3e25dd213">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tanh_1a4fa1499bee2d68714ff2a7751f1a6a38">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1acb67e501bd671dd0f0d8bfde9379d51b">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1aaddb4d5269b0b77fa8a9361ec0ecd281">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1a61c01a40bd7efdaa5d20e70a74efa215">refresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1VectorIntegral_1a343587abafa7b586bc561e4ee006c3dd">refresh</reimplementedby>
        <reimplementedby refid="classmty_1_1FermionPropStruct_1a43bd1ad5e7e58de97587d1c2cd249fd6">refresh</reimplementedby>
        <reimplementedby refid="classmty_1_1GeneratorElement_1a507a94cc6ee9d6ef14b91c0defe60fe5">refresh</reimplementedby>
        <reimplementedby refid="classmty_1_1Propagator_1a2ae1a2d85f5b5426a565b964b7d54201">refresh</reimplementedby>
        <reimplementedby refid="classmty_1_1Wick_1a6ab97a3fe089eff179f0108a82a32c2d">refresh</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="458" column="18" bodyfile="src/csl/abstract.cpp" bodystart="695" bodyend="698"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a10358c33402ed520dc5888b25bb26af3" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::deepRefresh</definition>
        <argsstring>() const</argsstring>
        <name>deepRefresh</name>
        <qualifiedname>csl::Abstract::deepRefresh</qualifiedname>
        <reimplementedby refid="classcsl_1_1Abs_1ac8052c60bed0b91575015fc12f368500">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a0b8721d9b3e21d66177396f4986daaf5">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACos_1a7bb81a3f943c20b8438f23ac2dda0999">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACosh_1a862134dbe39a35a3a6b569fb500d1f7c">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Angle_1ac68cf253d6b4198d4d934e2738eac922">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASin_1ab72b9b9b6155b0422a7692ebee9294e4">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASinh_1a8fd2f9a2ef43351dc196aafe51b3fd8a">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATan_1a9efcd6c66980afd90eb1d88256a227e5">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATanh_1abc2610238c874f1fcc5cb5353f3a153a">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1BooleanOperator_1a1a7179fc417a001b58b2da483381a71d">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Commutator_1ac186c3221d41b5eb5767fac0e84a2e00">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cos_1ab3c49dacb6008a6af54232a1880e38d7">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cosh_1ab49e6b0cb7d9ca62cb8a8bfdbdde1ede">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Derivative_1a0bf34398d67ca11b30b62bc0ea96eb3b">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1DiracDelta_1aed735df04c527c3698d527de793eafb2">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Exp_1aa3b78a6bf320ca4021d7220022aaa421">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Factorial_1a722e7b46f3ea179d88af350176b38127">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1ImaginaryPart_1a86f78dd12ac7d075fe8a9b733edfdc9b">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integral_1af7946ac29d688e8101c625d2410380df">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Log_1a47e66d3b3fa7953eba85628fdb490603">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Polynomial_1ae7913d6071ceb654983937919cadf377">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1a68f9d90d8f3e929b405f62b95b959e8f">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1a864b6337e4d97c072b8276bca9b4b0f0">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1RealPart_1a82ea13f60674212e5e1b1e862dde0c06">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1ScalarIntegral_1afe1fbea96856501467e41aef130549f7">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sin_1a6269198df979d6e79374e6c783142c9b">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sinh_1a985dd6289a3997bd6783eb52d31877c6">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1ad293e6cc7616876a4f66f11ec8d7cee4">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tan_1a0ab870ce977011edda5f1ec444853ec6">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tanh_1a5e93755d62a29be39a8e120947b06933">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1a9d93b947a2e4f55e14ba514cdbd3d4d8">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1ad0dbe5ebe94a2c21e0a8a195730820c4">deepRefresh</reimplementedby>
        <reimplementedby refid="classcsl_1_1VectorIntegral_1a4cdc68d467313a0efb3fe8a581fdbfa5">deepRefresh</reimplementedby>
        <reimplementedby refid="classmty_1_1FermionPropStruct_1af0b2b0b1eaec2154dfb9be9f314684d6">deepRefresh</reimplementedby>
        <reimplementedby refid="classmty_1_1FeynmanIntegral_1a5ca28df28b7eec34101bebcd5802630b">deepRefresh</reimplementedby>
        <reimplementedby refid="classmty_1_1Propagator_1a1cd17128c7468afd1e0108df83e5d627">deepRefresh</reimplementedby>
        <reimplementedby refid="classmty_1_1Wick_1a3420589c41211e239c575094b4892443">deepRefresh</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="460" column="18" bodyfile="src/csl/abstract.cpp" bodystart="700" bodyend="703"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a867135c96776248add60018f4aa7a578" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::setName</definition>
        <argsstring>(const std::string &amp;t_name)</argsstring>
        <name>setName</name>
        <qualifiedname>csl::Abstract::setName</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractElement_1aed5a0c9faec5b41fb1feb52764c4237f">setName</reimplementedby>
        <reimplementedby refid="classcsl_1_1Constant_1aa1d8e4b670f8bf97a1253a9056178248">setName</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1a48c1ccf9f8ff0fa0b533f7e986340b85">setName</reimplementedby>
        <param>
          <type>const std::string &amp;</type>
          <declname>t_name</declname>
        </param>
        <briefdescription>
<para>Change the name of the abstract. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t_name</parametername>
</parameternamelist>
<parameterdescription>
<para>Replaces name. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="469" column="18" bodyfile="src/csl/abstract.cpp" bodystart="57" bodyend="59"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a7bb29d316b8f64652cef472a6c23f001" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::setCommutable</definition>
        <argsstring>(bool t_commutable)</argsstring>
        <name>setCommutable</name>
        <qualifiedname>csl::Abstract::setCommutable</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractElement_1ab8f5f04326a3320b48a315ec5cee60d9">setCommutable</reimplementedby>
        <reimplementedby refid="classcsl_1_1Constant_1ad3f5b9cfa86f3c63c75fc48669c80c03">setCommutable</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1ac51328102c02c7f24ace7742db02537c">setCommutable</reimplementedby>
        <param>
          <type>bool</type>
          <declname>t_commutable</declname>
        </param>
        <briefdescription>
<para>Allows the abstract to commute or not. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t_commutable</parametername>
</parameternamelist>
<parameterdescription>
<para>Must be <bold>true</bold> if the abstract can commute. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="474" column="18" bodyfile="src/csl/abstract.cpp" bodystart="61" bodyend="65"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aaf7f0692cb84ca861a5b3b641bea518b" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::setValue</definition>
        <argsstring>(long double t_value)</argsstring>
        <name>setValue</name>
        <qualifiedname>csl::Abstract::setValue</qualifiedname>
        <reimplementedby refid="classcsl_1_1Constant_1a4ce673bdd9773d4837b386ae44611fb0">setValue</reimplementedby>
        <reimplementedby refid="classcsl_1_1Float_1a42a8b3b242e0fb3e9b19f10f14bb21a4">setValue</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integer_1a5ce6964933d7a9a7df7e8e4254b446be">setValue</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFactorial_1af6af261cc740ac8b4037f5a89599f4ad">setValue</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1acc912f9063706e9222537df9f2035ed1">setValue</reimplementedby>
        <param>
          <type>long double</type>
          <declname>t_value</declname>
        </param>
        <briefdescription>
<para>Sets the value if there is one (for Numerical and Literal valued). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="487" column="18" bodyfile="src/csl/abstract.cpp" bodystart="758" bodyend="762"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aa49c51bd285830e724f103e9fb61c464" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::setValue</definition>
        <argsstring>(Expr const &amp;t_value)</argsstring>
        <name>setValue</name>
        <qualifiedname>csl::Abstract::setValue</qualifiedname>
        <reimplementedby refid="classcsl_1_1Constant_1a4d5f1fdb9ec4ce8e55371e901f740089">setValue</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1aac53cf77ee5ed15069bc26bc8ee35c30">setValue</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>t_value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="489" column="18" bodyfile="src/csl/abstract.cpp" bodystart="764" bodyend="768"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aa6a04bb56578e7da143b3cd8d8fb7b26" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::setElementary</definition>
        <argsstring>(bool t_elementary)</argsstring>
        <name>setElementary</name>
        <qualifiedname>csl::Abstract::setElementary</qualifiedname>
        <reimplementedby refid="classcsl_1_1Variable_1aa0b96d40d172090ed1cee53f2058c8bd">setElementary</reimplementedby>
        <reimplementedby refid="classcsl_1_1Vector_1ab6c6058a3155af849b8606e03ed33b40">setElementary</reimplementedby>
        <param>
          <type>bool</type>
          <declname>t_elementary</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="495" column="18" bodyfile="src/csl/abstract.cpp" bodystart="770" bodyend="774"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aa6a40ceb6eb1aa79711ca126d5bdda02" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::setAllDependencies</definition>
        <argsstring>(bool t_allDependencies)</argsstring>
        <name>setAllDependencies</name>
        <qualifiedname>csl::Abstract::setAllDependencies</qualifiedname>
        <reimplementedby refid="classcsl_1_1Variable_1ab2baf34780f8a6fa99293c354f74f370">setAllDependencies</reimplementedby>
        <param>
          <type>bool</type>
          <declname>t_allDependencies</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="497" column="18" bodyfile="src/csl/abstract.cpp" bodystart="776" bodyend="780"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1abbab11282e5c6ac46b018642ff129f47" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::addDependency</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>addDependency</name>
        <qualifiedname>csl::Abstract::addDependency</qualifiedname>
        <reimplementedby refid="classcsl_1_1Variable_1a21ec42e2e7bda288321d8b297a2b39cc">addDependency</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="499" column="18" bodyfile="src/csl/abstract.cpp" bodystart="782" bodyend="786"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a0e778c682b6cb02642b90e8ec8765441" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::removeDependency</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>removeDependency</name>
        <qualifiedname>csl::Abstract::removeDependency</qualifiedname>
        <reimplementedby refid="classcsl_1_1Variable_1a49aa7d5d73de3b780f5de9a70ecf03f2">removeDependency</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="501" column="18" bodyfile="src/csl/abstract.cpp" bodystart="788" bodyend="792"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aab2d2ac186b56d17d2cc0a105e145b11" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::setArgument</definition>
        <argsstring>(const Expr &amp;expr, int iArg=0)</argsstring>
        <name>setArgument</name>
        <qualifiedname>csl::Abstract::setArgument</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1ab9ed03e7424e97a17464fb76e14bb213">setArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1a701d14b482a47a85c6cd5266118604cb">setArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1a6cf9bbbcd0b0b3f75121f1c0a5cf4d57">setArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1ae67f1daf87e45e15b82dd2827f6ba55f">setArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1IProd_1a9c6895c9d37d17614f54e3baeec96585">setArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1adce6c89ecb493c05627b42f036e49b5b">setArgument</reimplementedby>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>iArg</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Sets the argument at position <bold>iArg</bold> (default=0). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression that replaces the argument. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>iArg</parametername>
</parameternamelist>
<parameterdescription>
<para>the position of the argument to change. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="511" column="18" bodyfile="src/csl/abstract.cpp" bodystart="794" bodyend="798"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a45c3adb7ba4e2b8442247246a3792b44" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::setArgument</definition>
        <argsstring>(const Expr &amp;expr, const std::vector&lt; int &gt; &amp;indices)</argsstring>
        <name>setArgument</name>
        <qualifiedname>csl::Abstract::setArgument</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a47a8b2fbd9233c706cb5fcf05f96bc7f">setArgument</reimplementedby>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>const std::vector&lt; int &gt; &amp;</type>
          <declname>indices</declname>
        </param>
        <briefdescription>
<para>Sets the argument at position <bold>{i</bold>,j,...} for multi-dimensions expressions. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression that replaces the argument. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>indices</parametername>
</parameternamelist>
<parameterdescription>
<para>An std::vector containing the series of indices corresponding to the argument to replace. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="519" column="18" bodyfile="src/csl/abstract.cpp" bodystart="800" bodyend="804"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1afa50c743b8e7e76e637e98f165ad4e5d" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::setEmpty</definition>
        <argsstring>(bool t_empty)</argsstring>
        <name>setEmpty</name>
        <qualifiedname>csl::Abstract::setEmpty</qualifiedname>
        <reimplementedby refid="classcsl_1_1Operator_1a79761fde19842386022873d3332d2454">setEmpty</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1a79761fde19842386022873d3332d2454">setEmpty</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1a79761fde19842386022873d3332d2454">setEmpty</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1a79761fde19842386022873d3332d2454">setEmpty</reimplementedby>
        <param>
          <type>bool</type>
          <declname>t_empty</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="522" column="18" bodyfile="src/csl/abstract.cpp" bodystart="806" bodyend="810"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a70df7be4486affa8dc891e3f25bf499f" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::setOperand</definition>
        <argsstring>(const Expr &amp;operand)</argsstring>
        <name>setOperand</name>
        <qualifiedname>csl::Abstract::setOperand</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractIntegral_1a65250576bfa5547fe8eb17c37e0d3ed7">setOperand</reimplementedby>
        <reimplementedby refid="classcsl_1_1Derivative_1aef758e6375f3faf33875d9a1228cec44">setOperand</reimplementedby>
        <reimplementedby refid="classcsl_1_1ImaginaryPart_1a6e749b2756439d060e103585a11af231">setOperand</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integral_1af49dcf27651f1e5e149093da246dae8f">setOperand</reimplementedby>
        <reimplementedby refid="classcsl_1_1RealPart_1a3e065209200a53a0a5d13d4731298832">setOperand</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1ab78ef96e45ffe45a9fd18b315ad73db9">setOperand</reimplementedby>
        <reimplementedby refid="classmty_1_1Wick_1a853f3ab48a815d6769cedaffa0f0ade0">setOperand</reimplementedby>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>operand</declname>
        </param>
        <briefdescription>
<para>Sets the operand of an operator. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>operand</parametername>
</parameternamelist>
<parameterdescription>
<para>New operand. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="527" column="18" bodyfile="src/csl/abstract.cpp" bodystart="818" bodyend="822"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ae7b8a14fc746ed72e4d5abd63373c5ba" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::setOperandPrivate</definition>
        <argsstring>(const Expr &amp;operand, bool leaveEmpty)</argsstring>
        <name>setOperandPrivate</name>
        <qualifiedname>csl::Abstract::setOperandPrivate</qualifiedname>
        <reimplementedby refid="classcsl_1_1Operator_1a5a4637f0cc00891717e62a6bdfbd212f">setOperandPrivate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1a5a4637f0cc00891717e62a6bdfbd212f">setOperandPrivate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1a5a4637f0cc00891717e62a6bdfbd212f">setOperandPrivate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1a5a4637f0cc00891717e62a6bdfbd212f">setOperandPrivate</reimplementedby>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>operand</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>leaveEmpty</declname>
        </param>
        <briefdescription>
<para>Sets the operand of an operator. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>operand</parametername>
</parameternamelist>
<parameterdescription>
<para>New operand. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>leaveEmpty</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean that tells if the operator must stay empty (if true, then it will again apply later) or not (if false). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="534" column="18" bodyfile="src/csl/abstract.cpp" bodystart="812" bodyend="816"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a83fee8ed28079bcac107455d58be9d5d" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::setVectorArgument</definition>
        <argsstring>(const csl::vector_expr &amp;t_argument)</argsstring>
        <name>setVectorArgument</name>
        <qualifiedname>csl::Abstract::setVectorArgument</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1a8e6df749f2e0afdbe8ae0993235dda54">setVectorArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a2d072812c1918ec0097729d353003198">setVectorArgument</reimplementedby>
        <param>
          <type>const csl::vector_expr &amp;</type>
          <declname>t_argument</declname>
        </param>
        <briefdescription>
<para>Replaced the entire std::vector of argument. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t_argument</parametername>
</parameternamelist>
<parameterdescription>
<para>std::vector of expressions to copy. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="539" column="18" bodyfile="src/csl/abstract.cpp" bodystart="823" bodyend="827"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aa47ddab3aa047e86be34c70358d53548" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::setVariable</definition>
        <argsstring>(Expr const &amp;t_variable)</argsstring>
        <name>setVariable</name>
        <qualifiedname>csl::Abstract::setVariable</qualifiedname>
        <reimplementedby refid="classcsl_1_1ScalarIntegral_1a45ed19c09732a6083f2f2640c869690e">setVariable</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>t_variable</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="541" column="18" bodyfile="src/csl/abstract.cpp" bodystart="829" bodyend="833"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a5437e7f685edf8549e6d3b34572343f8" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::insert</definition>
        <argsstring>(const Expr &amp;expr, bool side=1)</argsstring>
        <name>insert</name>
        <qualifiedname>csl::Abstract::insert</qualifiedname>
        <reimplementedby refid="classcsl_1_1Prod_1ae065e3860edfd408a1cdef2bfb259b2e">insert</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1a8967f1bfbae1e49e21bd5f79939b2a63">insert</reimplementedby>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>side</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
<para>Inserts an expression in a sum or a product. </para>
        </briefdescription>
        <detaileddescription>
<para>Allows to insert an element in a sum or product without comparing all existing terms. This saves time when inserting element by element. The <bold>side</bold> parameter allows to insert to the left (side = 0) or to the right (side = 1) in products (useful when considering non commutating expressions. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to insert. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>side</parametername>
</parameternamelist>
<parameterdescription>
<para>Side of insertion for <ref refid="classcsl_1_1Prod" kindref="compound">Prod</ref> expressions. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="556" column="18" bodyfile="src/csl/abstract.cpp" bodystart="705" bodyend="709"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a3003698af4978e774eeb2e62038f7432" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::setParent</definition>
        <argsstring>(const Parent &amp;t_parent)</argsstring>
        <name>setParent</name>
        <qualifiedname>csl::Abstract::setParent</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractElement_1af55db25120693bf64ed360105cb4357c">setParent</reimplementedby>
        <reimplementedby refid="classcsl_1_1VectorIntegral_1aee6ef6c5969f6a2ff6bd7855fcf8862e">setParent</reimplementedby>
        <param>
          <type>const <ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref> &amp;</type>
          <declname>t_parent</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="562" column="18" bodyfile="src/csl/abstract.cpp" bodystart="266" bodyend="270"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1acc0eb077e25c9a67d15269cf8d5f0511" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::Abstract::replaceIndex</definition>
        <argsstring>(const Index &amp;indexToReplace, const Index &amp;newIndex, bool refresh=true) const</argsstring>
        <name>replaceIndex</name>
        <qualifiedname>csl::Abstract::replaceIndex</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1aeaa65642df3b0311a2f0056335011ab9">replaceIndex</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1a0714debb1e4fe6d8b6bf1b915771b30c">replaceIndex</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1a636313fd58465a56d3b41cb74f9ffaff">replaceIndex</reimplementedby>
        <reimplementedby refid="classcsl_1_1IProd_1a8f32fd847835d145cc8b4ff062d03c7d">replaceIndex</reimplementedby>
        <reimplementedby refid="classcsl_1_1ISum_1ad3f536e97dbf9f257fc08d6a1ad1d597">replaceIndex</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1ae304eceb527459e79e9cc635350b1a70">replaceIndex</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1a02fe69a766b8eade9d5de6cbea8054a6">replaceIndex</reimplementedby>
        <reimplementedby refid="classmty_1_1FermionPropStruct_1ad2f7566f463b5a34fa80ccf66bf08650">replaceIndex</reimplementedby>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>indexToReplace</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>newIndex</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>refresh</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>For indicial expressions, this function searches <bold>indexToContract</bold> and replaces it with newIndex. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>indexToContract</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> that is newly contracted. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>newIndex</parametername>
</parameternamelist>
<parameterdescription>
<para>Dummy new index that replaces <bold>indexToContract</bold> in the expression. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if the index has been found. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="572" column="27" bodyfile="src/csl/abstract.cpp" bodystart="272" bodyend="275"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ac9e54a236015d14af42b0bcde41953f3" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::Abstract::replaceIndices</definition>
        <argsstring>(std::vector&lt; Index &gt; const &amp;indexToReplace, std::vector&lt; Index &gt; const &amp;newIndex, bool refresh=true, bool flipped=false) const</argsstring>
        <name>replaceIndices</name>
        <qualifiedname>csl::Abstract::replaceIndices</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1aa0da071b14916bfbe1b12a388346e415">replaceIndices</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1ad1203eab976b86d48100179c93d05178">replaceIndices</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1a3db6d93888f6b8bb5719549e522a4afa">replaceIndices</reimplementedby>
        <reimplementedby refid="classcsl_1_1IProd_1abfe07d5009e2813511d936c662ddbef3">replaceIndices</reimplementedby>
        <reimplementedby refid="classcsl_1_1ISum_1a480bc2101ef3e41a874e897fda68524a">replaceIndices</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1ad55b628d2e960ed410b59d5e3d58ce16">replaceIndices</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1a9ad3c1eabb60fb445f9054699f9d949d">replaceIndices</reimplementedby>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &gt; const &amp;</type>
          <declname>indexToReplace</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &gt; const &amp;</type>
          <declname>newIndex</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>refresh</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>flipped</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="577" column="5" bodyfile="src/csl/abstract.cpp" bodystart="277" bodyend="283"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a9372ddd521fa661c5d3371e0d8d4dfc3" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::replaceIndexInPlace</definition>
        <argsstring>(Index const &amp;oldIndex, Index const &amp;newIndex)</argsstring>
        <name>replaceIndexInPlace</name>
        <qualifiedname>csl::Abstract::replaceIndexInPlace</qualifiedname>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1a3641cf8c169a05bff45ac4882c0cb596">replaceIndexInPlace</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1a16558db6dbbfcf52c37b52f8a883b5a6">replaceIndexInPlace</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> const &amp;</type>
          <declname>oldIndex</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> const &amp;</type>
          <declname>newIndex</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="582" column="18" bodyfile="src/csl/abstract.cpp" bodystart="285" bodyend="287"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aed79d20a0821205e6430c80a474117d3" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::Abstract::contractIndex</definition>
        <argsstring>(const Index &amp;index) const</argsstring>
        <name>contractIndex</name>
        <qualifiedname>csl::Abstract::contractIndex</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="585" column="19" bodyfile="src/csl/abstract.cpp" bodystart="289" bodyend="294"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aa4cba37520821432f37e212fefbc2534" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>csl::vector_expr</type>
        <definition>csl::vector_expr csl::Abstract::breakSpace</definition>
        <argsstring>(const Space *brokenSpace, const std::vector&lt; const Space * &gt; &amp;newSpace) const</argsstring>
        <name>breakSpace</name>
        <qualifiedname>csl::Abstract::breakSpace</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> *</type>
          <declname>brokenSpace</declname>
        </param>
        <param>
          <type>const std::vector&lt; const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> * &gt; &amp;</type>
          <declname>newSpace</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="588" column="5" bodyfile="src/csl/abstract.cpp" bodystart="297" bodyend="305"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1af0f40b77914e45f56bf87839d00211d7" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>csl::vector_expr</type>
        <definition>virtual csl::vector_expr csl::Abstract::breakSpace</definition>
        <argsstring>(const Space *brokenSpace, const std::vector&lt; const Space * &gt; &amp;newSpace, const std::vector&lt; std::string &gt; &amp;indexNames) const</argsstring>
        <name>breakSpace</name>
        <qualifiedname>csl::Abstract::breakSpace</qualifiedname>
        <reimplementedby refid="classcsl_1_1IProd_1a1af490741907446eb7839206e4546846">breakSpace</reimplementedby>
        <reimplementedby refid="classcsl_1_1ISum_1a2eefc8e1ba66dadb617955d89a2bb9d3">breakSpace</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1af224ac3745a73a90fa4d6e746072c983">breakSpace</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1aafc27871bb78f0a07df8aa097d3d8a0e">breakSpace</reimplementedby>
        <param>
          <type>const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> *</type>
          <declname>brokenSpace</declname>
        </param>
        <param>
          <type>const std::vector&lt; const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> * &gt; &amp;</type>
          <declname>newSpace</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::string &gt; &amp;</type>
          <declname>indexNames</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="592" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a70f946f9c59df045ef7416320ade89c7" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::setIndexStructure</definition>
        <argsstring>(const IndexStructure &amp;t_index)</argsstring>
        <name>setIndexStructure</name>
        <qualifiedname>csl::Abstract::setIndexStructure</qualifiedname>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1ae976c5be78ef54ca485001a9807d75bc">setIndexStructure</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1a387f69126ae40d711755945ef023de92">setIndexStructure</reimplementedby>
        <param>
          <type>const <ref refid="classcsl_1_1IndexStructure" kindref="compound">IndexStructure</ref> &amp;</type>
          <declname>t_index</declname>
        </param>
        <briefdescription>
<para>Replaces the index structure of the object, that must be an <bold>Indicial</bold> expression. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t_index</parametername>
</parameternamelist>
<parameterdescription>
<para>A std::vector of <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> which takes the place of the structure index. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="601" column="18" bodyfile="src/csl/abstract.cpp" bodystart="314" bodyend="318"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a3c175411df619e7504feb6d888fc82f1" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::setPoint</definition>
        <argsstring>(const Tensor &amp;t_point)</argsstring>
        <name>setPoint</name>
        <qualifiedname>csl::Abstract::setPoint</qualifiedname>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1a9c002e3c12a2d4f959795431d28b4099">setPoint</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1a7e1e7f28a0fcc04320d737dad3f59c21">setPoint</reimplementedby>
        <param>
          <type>const <ref refid="classcsl_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>t_point</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="603" column="18" bodyfile="src/csl/abstract.cpp" bodystart="320" bodyend="324"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a4f90ebb7cf7c26782bd36bc2a67fc5d4" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::setFullySymmetric</definition>
        <argsstring>()</argsstring>
        <name>setFullySymmetric</name>
        <qualifiedname>csl::Abstract::setFullySymmetric</qualifiedname>
        <briefdescription>
<para>Sets an <bold>Indicial</bold> object fully symmetric. Allows to set quickly a frequent property of tensors. This function then erases all properties of symmetry / antisymmetry and sets <bold>fullySymmetric</bold> to <bold>True</bold>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="610" column="18" bodyfile="src/csl/abstract.cpp" bodystart="353" bodyend="357"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ac318016372d14b795893fe7e59199084" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::setFullyAntiSymmetric</definition>
        <argsstring>()</argsstring>
        <name>setFullyAntiSymmetric</name>
        <qualifiedname>csl::Abstract::setFullyAntiSymmetric</qualifiedname>
        <briefdescription>
<para>Sets an <bold>Indicial</bold> object fully anti-symmetric. Allows to set quickly a frequent property of tensors. This function then erases all properties * of symmetry / antisymmetry and sets <bold>fullyAntiSymmetric</bold> to <bold>True</bold>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="617" column="18" bodyfile="src/csl/abstract.cpp" bodystart="359" bodyend="363"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ad431770faa4291116a50175193a11a88" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::addSymmetry</definition>
        <argsstring>(int i1, int i2)</argsstring>
        <name>addSymmetry</name>
        <qualifiedname>csl::Abstract::addSymmetry</qualifiedname>
        <param>
          <type>int</type>
          <declname>i1</declname>
        </param>
        <param>
          <type>int</type>
          <declname>i2</declname>
        </param>
        <briefdescription>
<para>Add a symmetry between the i1^{th} and the i2^{th} indices. If those indices are anti-symmetric, an error is thrown. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>i1</parametername>
</parameternamelist>
<parameterdescription>
<para>Position of the first index. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>i2</parametername>
</parameternamelist>
<parameterdescription>
<para>Position of the second index. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="624" column="18" bodyfile="src/csl/abstract.cpp" bodystart="365" bodyend="369"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a5549ac0c186b3c6febf332245a25a82c" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::addAntiSymmetry</definition>
        <argsstring>(int i1, int i2)</argsstring>
        <name>addAntiSymmetry</name>
        <qualifiedname>csl::Abstract::addAntiSymmetry</qualifiedname>
        <param>
          <type>int</type>
          <declname>i1</declname>
        </param>
        <param>
          <type>int</type>
          <declname>i2</declname>
        </param>
        <briefdescription>
<para>Add an anti-symmetry between the i1^{th} and the i2^{th} indices. If those indices are symmetric, an error is thrown. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>i1</parametername>
</parameternamelist>
<parameterdescription>
<para>Position of the first index.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>i2</parametername>
</parameternamelist>
<parameterdescription>
<para>Position of the second index. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="630" column="18" bodyfile="src/csl/abstract.cpp" bodystart="371" bodyend="375"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1abe9aceabbc0a99642e84c9025dbdc767" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>int</type>
        <definition>int csl::Abstract::permut</definition>
        <argsstring>(int i1, int i2)</argsstring>
        <name>permut</name>
        <qualifiedname>csl::Abstract::permut</qualifiedname>
        <param>
          <type>int</type>
          <declname>i1</declname>
        </param>
        <param>
          <type>int</type>
          <declname>i2</declname>
        </param>
        <briefdescription>
<para>Tries to permut indices at place <bold>i1</bold> and <bold>i2</bold>. If those two indices have a symmetry property, indices are swaped and the symmetry is returned. Else the fnuction does nothing and returns 0. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>i1</parametername>
</parameternamelist>
<parameterdescription>
<para>Position of the first index.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>i2</parametername>
</parameternamelist>
<parameterdescription>
<para>Position of the second index. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1 if the permutation <bold>(i1,i2) is symmetric</bold>. </para>
</simplesect>
<simplesect kind="return"><para>-1 if the permutation <bold>(i1,i2) is anti-symmetric</bold>. </para>
</simplesect>
<simplesect kind="return"><para>0 else (and do not permut the two indices). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="640" column="17" bodyfile="src/csl/abstract.cpp" bodystart="384" bodyend="389"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aad25c117c8dfc4d9718ba41e8d3f33a6" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::getNumericalFactor</definition>
        <argsstring>() const</argsstring>
        <name>getNumericalFactor</name>
        <qualifiedname>csl::Abstract::getNumericalFactor</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractNumerical_1ac3c2bbe76a12e7e7d08009b82e1fb7c1">getNumericalFactor</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1aefbb5ef66721e97b90dc1bb82b9e6823">getNumericalFactor</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1a31991415ad6e7e8e5e9b703f9128af39">getNumericalFactor</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1ae5a42358fbbca3043d216049222455d6">getNumericalFactor</reimplementedby>
        <briefdescription>
<para>Returns the numerical factor of the expression, i.e. returns <bold>C</bold> if the expression if of the form <bold>C*x</bold> (<bold>x</bold> having a numerical factor equal to 1), and return 1 else. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>This function returns the factor in an Expression (then of Numerical type). </para>
</simplesect>
<simplesect kind="return"><para>The numerical factor in front of the expression. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="659" column="18" bodyfile="src/csl/abstract.cpp" bodystart="565" bodyend="568"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a204dbd37b63432cb08932b995f49d3f4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>int</type>
        <definition>int csl::Abstract::getNFactor</definition>
        <argsstring>() const</argsstring>
        <name>getNFactor</name>
        <qualifiedname>csl::Abstract::getNFactor</qualifiedname>
        <reimplementedby refid="classcsl_1_1Pow_1a5f65eed081f73e0c0ff2c9c5247e5aa9">getNFactor</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1a065a0b483082e58a478016d0821427ab">getNFactor</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The number of possible factors for the expression </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="663" column="17" bodyfile="src/csl/abstract.cpp" bodystart="570" bodyend="573"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ac34c9c6f05e692faeed2f030514787ad" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>csl::vector_expr</type>
        <definition>csl::vector_expr csl::Abstract::getFactors</definition>
        <argsstring>() const</argsstring>
        <name>getFactors</name>
        <qualifiedname>csl::Abstract::getFactors</qualifiedname>
        <reimplementedby refid="classcsl_1_1Pow_1ae28914863f9dfd25c0acdeb372ef2455">getFactors</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1aaa4dca91f1ce4fc9d6f04d528e07db90">getFactors</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1ab2e21f4faf128cc9d9e471370def40e7">getFactors</reimplementedby>
        <briefdescription>
<para>Allows to get a std::vector of all terms than could factor the expression. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A std::vector containing the possible factors of <bold>*this</bold>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="669" column="30" bodyfile="src/csl/abstract.cpp" bodystart="575" bodyend="578"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a1d36e7a5acc50766d5cd3f6d59df978d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>std::optional&lt; Expr &gt; csl::Abstract::getTerm</definition>
        <argsstring>() const</argsstring>
        <name>getTerm</name>
        <qualifiedname>csl::Abstract::getTerm</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractBuildingBlock_1a58c627e31c2a42adec4caf39030123aa">getTerm</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractNumerical_1a092aae72532fd13bcc79392bd18ebfad">getTerm</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1a71c50f5ed80151b5d75afe6e14164d78">getTerm</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1a428ffb91c3529b4835d6bfa6289765d8">getTerm</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1aa265b9928bffd0aefe456d9dbe3637b8">getTerm</reimplementedby>
        <briefdescription>
<para>This function returns the same expression as *this but amputated of its numerical factor. Example: (4*cos(x) -&gt; cos(x)). </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The term without numerical factor corresponding to <bold>*this</bold>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="675" column="27" bodyfile="src/csl/abstract.cpp" bodystart="580" bodyend="583"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ac513c930caa9939c2b9557f36a34ee69" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::getExponents</definition>
        <argsstring>(std::vector&lt; Expr &gt; const &amp;factors, std::vector&lt; Expr &gt; &amp;exponents) const</argsstring>
        <name>getExponents</name>
        <qualifiedname>csl::Abstract::getExponents</qualifiedname>
        <reimplementedby refid="classcsl_1_1Pow_1a6906b6f3c06c1e1c7aad71d272eac65f">getExponents</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1a1b3dfc8deb0baece750b925ef1a95402">getExponents</reimplementedby>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; const &amp;</type>
          <declname>factors</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; &amp;</type>
          <declname>exponents</declname>
        </param>
        <briefdescription>
<para>Fills in a vector the exponents corresponding to some factors for the expression. </para>
        </briefdescription>
        <detaileddescription>
<para>For example, an expression like <formula id="0">$ 2ax^2\cos y $</formula> will have exponents <formula id="1">$ (1, 2, 0) $</formula> for the set of factors <formula id="2">$ (a, x, y). $</formula> <bold>factors</bold> and <bold>exponents</bold> must of course be of the same size. Otherwise the behaviour is undefined.</para>
<para><simplesect kind="note"><para>This function assumes that the expression is canonical, in particular that no terms like <formula id="3">$ x\cdot x^2 $</formula> can appear.</para>
</simplesect>
<simplesect kind="note"><para>This function does not take into account factors in sums like <formula id="4">$ (1 + x) $</formula> (this will return a factor 0 for <formula id="5">$ x $</formula>).</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>factors</parametername>
</parameternamelist>
<parameterdescription>
<para>Factors. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>exponents</parametername>
</parameternamelist>
<parameterdescription>
<para>Exponents (out variable, modified during the run). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="695" column="18" bodyfile="src/csl/abstract.cpp" bodystart="585" bodyend="593"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1afd9d0336808e8adf4ccdccb51587ed8c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::checkIndexStructure</definition>
        <argsstring>(const std::vector&lt; Index &gt; &amp;t_index) const</argsstring>
        <name>checkIndexStructure</name>
        <qualifiedname>csl::Abstract::checkIndexStructure</qualifiedname>
        <reimplementedby refid="classcsl_1_1TensorElement_1ad9d1474eb8d1c53835ffb3891e01b020">checkIndexStructure</reimplementedby>
        <param>
          <type>const std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &gt; &amp;</type>
          <declname>t_index</declname>
        </param>
        <briefdescription>
<para>Checks the compatibility of the index structure of an <bold>Indicial</bold> expression with another. In a sum, two terms must have exaclty the same index structure. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t_index</parametername>
</parameternamelist>
<parameterdescription>
<para>A std::vector of <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> to compare. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if the two structures match. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="709" column="18" bodyfile="src/csl/abstract.cpp" bodystart="326" bodyend="331"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a1ebd84082bb93418408cc0babe2dffe2" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>virtual bool csl::Abstract::checkIndexStructure</definition>
        <argsstring>(const std::initializer_list&lt; Index &gt; &amp;index) const</argsstring>
        <name>checkIndexStructure</name>
        <qualifiedname>csl::Abstract::checkIndexStructure</qualifiedname>
        <param>
          <type>const std::initializer_list&lt; <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &gt; &amp;</type>
          <declname>index</declname>
        </param>
        <briefdescription>
<para>Checks the compatibility of the index structure of an <bold>Indicial</bold> expression with another. In a sum, two terms must have exaclty the same index structure. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t_index</parametername>
</parameternamelist>
<parameterdescription>
<para>A std::initializer_list of <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> to compare. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if the two structures match. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="718" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a7caee12abb451168149779a668dfc59e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>virtual bool csl::Abstract::compareWithDummy</definition>
        <argsstring>(Expr_info expr, std::map&lt; Index, Index &gt; &amp;constraints, bool keepAllCosntraints=false) const</argsstring>
        <name>compareWithDummy</name>
        <qualifiedname>csl::Abstract::compareWithDummy</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1af16a648041a09ff87602427add048ee0">compareWithDummy</reimplementedby>
        <reimplementedby refid="classcsl_1_1IProd_1a55b05e348d5a51d47d119059659b0ccb">compareWithDummy</reimplementedby>
        <reimplementedby refid="classcsl_1_1ISum_1a55c31985f0a3ee26f551f28c7b651d1d">compareWithDummy</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1ac28ceccb0fea566ae54b2d01b70548f5">compareWithDummy</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1acd1ac409b891dd033c1792f5473d8d10">compareWithDummy</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1a7568ac709f768fc70a4797731b7d9e7a">compareWithDummy</reimplementedby>
        <reimplementedby refid="classcsl_1_1VectorIntegral_1a6a1e720e6db9d81db825d18cea8a334a">compareWithDummy</reimplementedby>
        <reimplementedby refid="classmty_1_1QuantumField_1a60fc0d4a50c72d78f81bd9c73329d4f2">compareWithDummy</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::map&lt; <ref refid="classcsl_1_1Index" kindref="compound">Index</ref>, <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &gt; &amp;</type>
          <declname>constraints</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>keepAllCosntraints</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Comparison disregarding name of dummy indices, i.e. the two expressions * are equals even if dummy indices have not the same names in *this and * expr. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to compare.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>constraints</parametername>
</parameternamelist>
<parameterdescription>
<para>List of existing constraints between indices (it is modified in the function).</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if expr == *this taking constraints into account. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="729" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a0f16fda9fe72a89c61ece36101a11d95" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::compareWithDummy</definition>
        <argsstring>(Expr_info expr, bool keepAllCosntraints=false) const</argsstring>
        <name>compareWithDummy</name>
        <qualifiedname>csl::Abstract::compareWithDummy</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>keepAllCosntraints</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="733" column="10" bodyfile="src/csl/abstract.cpp" bodystart="347" bodyend="351"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aea8459b3206eb3a2297eeea7688e9520" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>int</type>
        <definition>int csl::Abstract::getParity</definition>
        <argsstring>(Expr_info t_variable) const</argsstring>
        <name>getParity</name>
        <qualifiedname>csl::Abstract::getParity</qualifiedname>
        <reimplementedby refid="classcsl_1_1Abs_1a3b735634cb0181f048b6fd23dea5a614">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACos_1a95a6076fdc3cae921b5cde90a835e74e">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACosh_1a2dcbe0e8c6fc07d7d4ca3b02c24ced42">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1Angle_1a1c2c4dff4cecb505f6d9ce05701dfde0">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASin_1a142897732f1f6c347bc4e65c344bbb27">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASinh_1a22a4862646c4cbaffcff45a8876c0648">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATan_1abce45fbcda74eb7acf909c5c711176c0">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATanh_1afb2c14500cc281ef0a642294bda73e99">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1Commutator_1ad15cf75bcb8e00335ac9f8fd36f1b048">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1Constant_1a969cc1cbf65be1a69d2693911b3c4617">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cos_1a8a840d5af4c79bf20430b144ee0da9b1">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cosh_1a1ad8069e9a1236eb00551780684b1240">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1Derivative_1a7d906b1b3929000ec0a6100bb5957697">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1DiracDelta_1a7a0264b21f4abad295c61e89ead32b88">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1Exp_1a074d3618469cd4ab010d6c48c47f4976">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1Factorial_1a687d7064e35ad99d4981e940c509440d">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integral_1a75d07b7ec8e8ede6c9c15157e6a4b47f">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1Log_1a53b05a1dd7c973da172358bb673e4549">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1Polynomial_1abba6b5b6abd6d86b1aa3f51ebd34201d">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1af0de63b31d13243da82cea81cdda9c39">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1a68dff5c0b393ad75f5e7e0ac97d229dc">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sin_1a51c0924da089969435b2fb45118e9a52">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sinh_1a32616979f93899f873439e54c65ab376">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1abd3105d37243fd781e0b2da2de60c295">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tan_1a888df766c47e82b50a9e2bd72192cbbb">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tanh_1a33d8c0c83c0e2c9500448ceba8b61428">getParity</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1a12415e4c7a0296803e0b4fb6a174ac4b">getParity</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>t_variable</declname>
        </param>
        <briefdescription>
<para>Returns the parity property of the expression with respect to <bold>t_variable</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t_variable.</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1 if the expression is <bold>even</bold> in <bold>t_variable</bold>. </para>
</simplesect>
<simplesect kind="return"><para>-1 if the expression is <bold>odd</bold> in <bold>t_variable</bold>. </para>
</simplesect>
<simplesect kind="return"><para>0 else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="747" column="17" bodyfile="src/csl/abstract.cpp" bodystart="923" bodyend="926"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a27ad666bf7d533607da9675b0c645ee9" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::askTerm</definition>
        <argsstring>(Expr_info expr, bool exact=false) const</argsstring>
        <name>askTerm</name>
        <qualifiedname>csl::Abstract::askTerm</qualifiedname>
        <reimplementedby refid="classcsl_1_1Pow_1aca1c3fe5c3b30c69807073da07fe9d4e">askTerm</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1adb2f82801fb73fb0baaaa18079e6cfa5">askTerm</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1a1620a408e74aa2b452a176f006fb3e5c">askTerm</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1a6ec375934423dbb60f6d00ea13ec7f80">askTerm</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>exact</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Check if <bold>expr</bold> can factor <bold>*this</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para>In almost every case this corresponds just to the comparison ** *this == expr**. For <ref refid="classcsl_1_1Prod" kindref="compound">Prod</ref>, <ref refid="classcsl_1_1Pow" kindref="compound">Pow</ref>, Fraction types (all that are multiplicative) we must check if the factor hides in a product. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Factor to search in the expression. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if <bold>expr</bold> is a possible factor. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="757" column="18" bodyfile="src/csl/abstract.cpp" bodystart="711" bodyend="714"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a40fe2ccf376dadd21b2d7a0f134d86c6" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::dependsOn</definition>
        <argsstring>(Expr_info expr) const</argsstring>
        <name>dependsOn</name>
        <qualifiedname>csl::Abstract::dependsOn</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1a423dcc1eccb833f88b3f98caa52189a9">dependsOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1a8c3e75947048293c9c6cc0c8e261049f">dependsOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractIntegral_1a72eadc4f6452f7139be88c9bfe0c8649">dependsOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1a9d64fefa1c3718d1fe431edfa4934e71">dependsOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractNumerical_1afe459bd13460da89d77acb73d19baa59">dependsOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1acca79f2a53255ee6b10d51efc658cb19">dependsOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1Constant_1a93af5fcd73748abeb661cd37206902d2">dependsOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integral_1ae3d145e84f749ba49f57d59a277742c5">dependsOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1a618856543c22406e8c7eed5b8a5a9c65">dependsOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1a14ad4f8a47af9ea009bcea3385e45bc3">dependsOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1ab452e8d298be5e58e28e92aa6eca1c25">dependsOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1aa8f5dda90b3f915c633745740e579abd">dependsOn</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Check recursively if the expression depends on <bold>expr</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to search. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if a dependency in <bold>expr</bold> is found. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="764" column="18" bodyfile="src/csl/abstract.cpp" bodystart="870" bodyend="873"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a9d7d8586a0df66ba8da33528d6400e66" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::dependsOn</definition>
        <argsstring>(Parent_info parent) const</argsstring>
        <name>dependsOn</name>
        <qualifiedname>csl::Abstract::dependsOn</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1a460268d704974e083a355e66126e35e1">dependsOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractNumerical_1aaf4b8f1aac21827fd06f743f711933a1">dependsOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a87b6428015d2a220210ad0d10f2333a8">dependsOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1af1249fbc711db9da848ef8f80ce9a9bd">dependsOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1a016485a4c1fe60991263a4dea94eed6e">dependsOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1aeb70122164b2685fc291090258f59b9b">dependsOn</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1AbstractParent" kindref="compound">Parent_info</ref></type>
          <declname>parent</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="766" column="18" bodyfile="src/csl/abstract.cpp" bodystart="875" bodyend="878"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ac3c9887977249e4d71ea36c6377b3581" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::dependsExplicitlyOn</definition>
        <argsstring>(Expr_info expr) const</argsstring>
        <name>dependsExplicitlyOn</name>
        <qualifiedname>csl::Abstract::dependsExplicitlyOn</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1a6642c1edceccda7928bbd70256446428">dependsExplicitlyOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1aa67b2133ef52393513ecbdc72e45acb0">dependsExplicitlyOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractIntegral_1ab675c7672e9523a8fdfaf71f9741bb93">dependsExplicitlyOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1ad072ccb3f8007430a6d6dce53f32b441">dependsExplicitlyOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractNumerical_1a1cc3b916f6ff6b0b63c17095c1375adc">dependsExplicitlyOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a5dfd1e8233507457f725e10e2624ec0f">dependsExplicitlyOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integral_1a467c09b5b03f5e5a6ee28410ded0d09f">dependsExplicitlyOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1af76375171fcd6824d8410030fb2d5c28">dependsExplicitlyOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1a22a5c9686859930af78f51a85b31160d">dependsExplicitlyOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1a43644a7030777b98a28cbaa15f229bfa">dependsExplicitlyOn</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Check recursively if <bold>expr</bold> is present in the expression. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to search. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if <bold>expr</bold> is found. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="773" column="18" bodyfile="src/csl/abstract.cpp" bodystart="880" bodyend="883"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a0b26ad7a44e497af296318287bac539a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::dependsExplicitlyOn</definition>
        <argsstring>(Parent_info parent) const</argsstring>
        <name>dependsExplicitlyOn</name>
        <qualifiedname>csl::Abstract::dependsExplicitlyOn</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1afb8fc18946f96492b94896ab680e2dd1">dependsExplicitlyOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1aa5181cc8b11edcdb189ca7491cf6ba82">dependsExplicitlyOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1a7c3599e88ef45e1abc9c878432c67ade">dependsExplicitlyOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractNumerical_1a8880d9ad418a9556b559fbdab2bb746b">dependsExplicitlyOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a774421b7d986b3e88533c4e20c206c12">dependsExplicitlyOn</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1a254af52dc9947ef7fa1625ea9c9f77ef">dependsExplicitlyOn</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1AbstractParent" kindref="compound">Parent_info</ref></type>
          <declname>parent</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="775" column="18" bodyfile="src/csl/abstract.cpp" bodystart="885" bodyend="888"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a3f68d0cd93dfe2ac02d6d4afc80fb41a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::commutesWith</definition>
        <argsstring>(Expr_info expr, int sign=-1) const</argsstring>
        <name>commutesWith</name>
        <qualifiedname>csl::Abstract::commutesWith</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractBuildingBlock_1add4dd8d4ed4ea0d8817fdd79abd744cc">commutesWith</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1ac84821d717ca9ab1aed295b644fe8cae">commutesWith</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1ae2422de442a3c2b7d3011012a5cb7a46">commutesWith</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1ac54eff0c503e2c2947b232622261c998">commutesWith</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a7a90b9f26666f4aff635bfbf7cd865b6">commutesWith</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1adc9dd8a7ee3c9092e6d94d88d3e9f9fe">commutesWith</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1adc9dd8a7ee3c9092e6d94d88d3e9f9fe">commutesWith</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1adc9dd8a7ee3c9092e6d94d88d3e9f9fe">commutesWith</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1adc9dd8a7ee3c9092e6d94d88d3e9f9fe">commutesWith</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1aa9de316c2975e097ea77162d7d1040c8">commutesWith</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1adfa4fb552a7ff6ab32eeea0a39dc97cd">commutesWith</reimplementedby>
        <reimplementedby refid="classmty_1_1QuantumField_1a00022859c6f9a262b82fde583c7b675e">commutesWith</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>sign</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Tells if the object commutes with expr. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if <bold>*this</bold> commutes with <bold>expr</bold>. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="782" column="18" bodyfile="src/csl/abstract.cpp" bodystart="890" bodyend="893"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a299b1fd6c2b9d80ad90a08c7acef28d2" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::Abstract::findSubExpression</definition>
        <argsstring>(Expr_info subExpression, const Expr &amp;newExpression) const</argsstring>
        <name>findSubExpression</name>
        <qualifiedname>csl::Abstract::findSubExpression</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractBuildingBlock_1a4000d3f204c1957f5cffc0677dd754c0">findSubExpression</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1a86ac8ca4a6eed274d004d989f3a65f3d">findSubExpression</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1a2844b245ea8608c32be1ae2794a12858">findSubExpression</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1acb17ac601dd6fb6c98a6de6983d41009">findSubExpression</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1a6658c74878dc31902a45b75994baef85">findSubExpression</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>subExpression</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>newExpression</declname>
        </param>
        <briefdescription>
<para>Searches a sub-expression and replaces it. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>subExpression</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to search. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>newExpression</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression that replaces <bold>subExpression</bold> if it is found. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The expression with the replacement done. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="790" column="5" bodyfile="src/csl/abstract.cpp" bodystart="895" bodyend="901"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1acae10d5685ccec295fbd9be7996073cb" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>int</type>
        <definition>int csl::Abstract::isPolynomial</definition>
        <argsstring>(Expr_info expr) const</argsstring>
        <name>isPolynomial</name>
        <qualifiedname>csl::Abstract::isPolynomial</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1a424f5c3e08f3548d1be123b599eaac2f">isPolynomial</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractElement_1a9f3e30eeaace6c5c21cda6895daa2de9">isPolynomial</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1a699c366fc3c292e8a70941e1c4ee5b0c">isPolynomial</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1a8014e107c584b6450d3cc1ce78e154ca">isPolynomial</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1a52d9ee469cf861e08a58588ce3edf1c4">isPolynomial</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1ad52e8f95508d38377324e9ef8fb4c28d">isPolynomial</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Determines if the expression is a mononomial term in <bold>expr</bold>, i.e. a term of the form C*expr^n with C independent of expr, n integer. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Variable" kindref="compound">Variable</ref> of the supposed mononomial. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The order of the exponent if there is one (n in the example). </para>
</simplesect>
<simplesect kind="return"><para>-1 else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="799" column="17" bodyfile="src/csl/abstract.cpp" bodystart="903" bodyend="906"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ab79c1d8df9e6b1a3eca66958f7dc489d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::matchShape</definition>
        <argsstring>(Expr_info expr, bool exact=false) const</argsstring>
        <name>matchShape</name>
        <qualifiedname>csl::Abstract::matchShape</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1ab24d4b6eae7dbe9783aabf2bfcb7a224">matchShape</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>exact</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>In the case of a vectorial-type expression, this function checks if the shape of expr matches itself. </para>
        </briefdescription>
        <detaileddescription>
<para>If <bold>exact</bold> is true, the function search an exact match i.e. either the two shapes are exactly equal or one of the two objects is a scalar. If <bold>exact</bold> is false, this function only search for a possible dot product between the two expressions, and see if the last axis of <bold>*this</bold> matches the first of <bold>expr</bold> (or if one of the two objects is scalar also). Then, a product \sum _k (*this)[i,j,...,k]*expr[k,l,m,...] is possible.<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression of which we compare the shape. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>exact</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean than specifies if we need an exact match or not. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if the two shapes correspond. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="814" column="18" bodyfile="src/csl/abstract.cpp" bodystart="987" bodyend="992"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aa31e08c251d96b8ea8ec8d385895c1ff" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::hasContractionProperty</definition>
        <argsstring>(Expr_info B) const</argsstring>
        <name>hasContractionProperty</name>
        <qualifiedname>csl::Abstract::hasContractionProperty</qualifiedname>
        <reimplementedby refid="classcsl_1_1TensorElement_1a511992d33dc54c1fb8d0c4c17afa5f8c">hasContractionProperty</reimplementedby>
        <reimplementedby refid="classmty_1_1PolarizationField_1ade831a2a0692e924629fcf55e35858b0">hasContractionProperty</reimplementedby>
        <reimplementedby refid="classmty_1_1QuantumField_1a36e3defd0cde58df005e9e8ebb64a135">hasContractionProperty</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>B</declname>
        </param>
        <briefdescription>
<para>Tells (for an Indicial type) if there is a special contraction property with <bold>B</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression with which we test if there is a special contraction. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if there is a contraction. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="822" column="18" bodyfile="src/csl/abstract.cpp" bodystart="994" bodyend="997"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a94bf1455397fdd2df8dbbc3b41c2f3f4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::hasChainContractionProperty</definition>
        <argsstring>() const</argsstring>
        <name>hasChainContractionProperty</name>
        <qualifiedname>csl::Abstract::hasChainContractionProperty</qualifiedname>
        <reimplementedby refid="classcsl_1_1TensorElement_1acb6f22178e26a8cc694ae2ffc01c2075">hasChainContractionProperty</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="824" column="18" bodyfile="src/csl/abstract.cpp" bodystart="999" bodyend="1002"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aec707d949f0f98e08ab4642c93dd9eb5" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::vector&lt; <ref refid="classcsl_1_1ContractionChain" kindref="compound">ContractionChain</ref> &gt;</type>
        <definition>vector&lt; ContractionChain &gt; csl::Abstract::getContractionProperties</definition>
        <argsstring>() const</argsstring>
        <name>getContractionProperties</name>
        <qualifiedname>csl::Abstract::getContractionProperties</qualifiedname>
        <reimplementedby refid="classcsl_1_1TensorElement_1a5f1b1ae7f3655cccd70bf09a60075b7b">getContractionProperties</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="826" column="25" bodyfile="src/csl/abstract.cpp" bodystart="1004" bodyend="1009"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ad874fc858295a737e6ce884530f1109b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::contraction</definition>
        <argsstring>(Expr_info B) const</argsstring>
        <name>contraction</name>
        <qualifiedname>csl::Abstract::contraction</qualifiedname>
        <reimplementedby refid="classcsl_1_1TensorElement_1a2a301cd1beb0eecde2b83c1ca6167c59">contraction</reimplementedby>
        <reimplementedby refid="classmty_1_1PolarizationField_1a1a8b9b886fd8e7ab972815f7d309c61d">contraction</reimplementedby>
        <reimplementedby refid="classmty_1_1QuantumField_1a1983a5ae691c9e8bcf09aa3e6d948638">contraction</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>B</declname>
        </param>
        <briefdescription>
<para>Applies a special contraction of indices. Before calling this function we must check that there is indeed a contraction by calling the function <ref refid="classcsl_1_1Abstract_1aa31e08c251d96b8ea8ec8d385895c1ff" kindref="member">hasContractionProperty()</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression with which <bold>*this</bold> contracts. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The result of the contraction. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="834" column="18" bodyfile="src/csl/abstract.cpp" bodystart="1011" bodyend="1016"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1abd35096982e92b669ea55d960c5f44be" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::contraction</definition>
        <argsstring>(const csl::vector_expr &amp;chain) const</argsstring>
        <name>contraction</name>
        <qualifiedname>csl::Abstract::contraction</qualifiedname>
        <param>
          <type>const csl::vector_expr &amp;</type>
          <declname>chain</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="836" column="18" bodyfile="src/csl/abstract.cpp" bodystart="1018" bodyend="1023"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a543d5a4f0432e166b492ad28a860a65f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>long double</type>
        <definition>long double csl::Abstract::evaluateScalar</definition>
        <argsstring>() const</argsstring>
        <name>evaluateScalar</name>
        <qualifiedname>csl::Abstract::evaluateScalar</qualifiedname>
        <reimplementedby refid="classcsl_1_1Abs_1abd250986b9ce084c98fb968db0fb587b">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACos_1a24cd3961c5c39c3788a702410c437808">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACosh_1a3cece5a5ecb328b31e7f235b43bdab67">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1Angle_1ab6f5cc0b8e682f2d670d65c76402a738">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASin_1af81b867514a85671642e52445b18e4d9">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASinh_1a22b8dc76ae36362de29bb2614925a8b6">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATan_1a5cc44ce49897c4488538e7b2f8ecf0b3">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATanh_1a7a486ca2937c53a6d5940c2245da87b5">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1Commutator_1a1540b8e45df030f7828a092370feafaf">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complex_1a4a5a2813d3cba5cc8c761959f3dd17fb">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1Constant_1ab324b60959cde778500b675b3bf6433e">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cos_1a6eb534b4b475261522c8c93ce594646c">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cosh_1a403d11f101661cb030e72f41907fdfc7">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1Derivative_1a2cdecc31aec95ae92fdbb0a24f3f8589">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1Exp_1a396b88644ca6fe350fff11960592c4b7">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1Factorial_1a59bdb12cae8d39b453b2f345f4a388ad">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1Float_1a244fc461c1b78ecdf0791d64cef8100d">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1Imaginary_1a6c195a0913b72cd58940bd06fedd8432">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integer_1a3b0670d4d8bddf30871f72a15a30f856">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFactorial_1aa25285ce9c79edb763716c5d903febc0">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFraction_1a73241811979616fa6106f9ba2addd23e">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1Log_1a557c51c92ffe849c9f96e9a9f65d39de">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1Polynomial_1a7a0909807aa3cd11e0d213370c742bb4">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1aa2d9132cb7ca63dfba3eb81466a9c3c9">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1a3bfdd94f06244aa5af7027901d9e00dd">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sin_1af7b3d229ea8b52816102b4facbd7d6bb">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sinh_1ad2e6606fa0e330acc102e4057a627425">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1aa8f5632f8b3be2615f29085195c7abe2">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tan_1a01cd6db9fc2543411cba9362d082b54d">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tanh_1ae507f59e44931085e7ac8a7d85a28ee5">evaluateScalar</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1a07be9df0d692e8a4dcd7ac913baee1ac">evaluateScalar</reimplementedby>
        <briefdescription>
<para><bold>Evaluates</bold> the value of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>Tries to replace all variables by a real value. If it is not possible (for example treating a <ref refid="classcsl_1_1Vector" kindref="compound">Vector</ref> or an <ref refid="classcsl_1_1Imaginary" kindref="compound">Imaginary</ref>) the considered object is replaced by 0. A warning message is displayed in the case of i. <simplesect kind="return"><para>The value of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> (double). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="851" column="25" bodyfile="src/csl/abstract.cpp" bodystart="835" bodyend="840"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aa3a4cb7f30e2a422fe27a513e03d6600" prot="public" static="no" const="yes" explicit="no" inline="no" virt="pure-virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>virtual std::optional&lt; Expr &gt; csl::Abstract::evaluate</definition>
        <argsstring>(csl::eval::mode user_mode=csl::eval::base) const =0</argsstring>
        <name>evaluate</name>
        <qualifiedname>csl::Abstract::evaluate</qualifiedname>
        <reimplementedby refid="classcsl_1_1Abs_1ac08757293e89b6352824ae09843a5c18">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractElement_1ad0583927014b475eb57853429c91df20">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1a224c6e6a26a42ac2dba35e30e2e7a521">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractIntegral_1a03f67aec1f7e9b74fd65383e0fc6600f">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1afaf73d258e30ae78513cfaa4d7c65d59">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACos_1a17e119e2f6d22f0b6c1f149e2ebefcd5">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACosh_1a1b3ac8c059d26ae9142d9f240f7aeb78">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Angle_1a2f0b4708a98d477767a53218adf0affa">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Arbitrary_1ab4744294dedcb8b4402b76f821b275cf">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASin_1afd6d69a61c924d596c1f7adb859893b0">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASinh_1a6489126c02c25e4cfb295db5d85cadd5">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATan_1a275592a7ba6a9985e921b3a791dc461f">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATanh_1ad9ee39eda573051de9b45699ed886f83">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1BooleanOperator_1a7c7105988581c2948846ef14a43335b0">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Commutator_1a41beafb3d55c2f33e20a904a09ded5a9">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complex_1a0651cc75f7010f12fdd80cd0d458b568">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Constant_1a77a25c084010808eae31429df43996eb">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cos_1a3baf3fecf9ea48db4ba1fbbfd3aee05b">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cosh_1ad40b853fb9959e63b514ed9c71b5bf2a">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Derivative_1a5165c55343cf326d361e7f4c44df986f">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Exp_1a9927422cac69f3ef722551ac4d37d33f">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Factorial_1ab104048896f3aafb93bf35a73d8fa783">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Float_1ab4d0c0ffa060f4a4242fa1920b5f7c7e">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Imaginary_1aac1fdac38ead90cfe0d4033896cfb13a">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1ImaginaryPart_1a8423033a6934636a15e47b5ccb0df70e">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integer_1a029be2af666fd37d37412473cceeb546">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integral_1a058cb4c2238b8ff1c66908c80d21fd8f">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFactorial_1a5cfc7511cbf57edd5f47d3bbde9d0798">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFraction_1aff12a6c06a577d55f295d3d474118a73">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1IProd_1ac336baabde24424fc39efd66acc084ca">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Log_1a6007d682abe9cd508476984a051c0844">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Polynomial_1a4ef2dc0f782257d31ba7f5028cbd5e34">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1aa12ddb1c3b4952756d9eb15196a1674f">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1abd8408064c53f614ef5e2bdff399c6d3">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1RealPart_1aeb57b368c5ae7caa278ca998cb3a4782">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sin_1a9977b55ee7079bf9bc7205a57975dd5f">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sinh_1aa7b24dd1844a99aa1bf73f59829d6cb0">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1af3c54e000687a23ad678c77760ffaaf1">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tan_1a1c5025345411cb71d081394524492ae1">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tanh_1a094ae3e5b29e66a9d4319fb774b5bfcb">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1aaaa0e8d228945bad2ef6a8474a6df0c0">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1a55ad56ca57e69bdcb5b77e6d0bf254c7">evaluate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1a96c4549dce7d30db1f06180f8d3d0145">evaluate</reimplementedby>
        <reimplementedby refid="classmty_1_1FermionPropStruct_1abb0fa2b49a92048ade3c2d35b8c603b6">evaluate</reimplementedby>
        <reimplementedby refid="classmty_1_1FeynmanIntegral_1ae538afaabb237eeab882efc0112294ad">evaluate</reimplementedby>
        <reimplementedby refid="classmty_1_1Propagator_1a0a3615ae1fbafd41d788ec49b8f72389">evaluate</reimplementedby>
        <reimplementedby refid="classmty_1_1Wick_1af4646e4a1567e6e87e3112f177d7aa52">evaluate</reimplementedby>
        <param>
          <type>csl::eval::mode</type>
          <declname>user_mode</declname>
          <defval>csl::eval::base</defval>
        </param>
        <briefdescription>
<para><bold>Evaluates</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>Replaces all variables by their value and evaluating. This function must be used instead of <ref refid="classcsl_1_1Abstract_1a543d5a4f0432e166b492ad28a860a65f" kindref="member">evaluateScalar()</ref> when treating not only real scalars.* In particular (x=2, y=3) x+iy evaluates to 3+ 3i whereas <ref refid="classcsl_1_1Abstract_1a543d5a4f0432e166b492ad28a860a65f" kindref="member">evaluateScalar()</ref> would return 3. <simplesect kind="return"><para>The abstract result of the evaluation. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="860" column="27"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aecab8c872023a2d0771e7e4f83bb05f8" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::Abstract::derive</definition>
        <argsstring>(Expr_info expr) const</argsstring>
        <name>derive</name>
        <qualifiedname>csl::Abstract::derive</qualifiedname>
        <reimplementedby refid="classcsl_1_1Abs_1afe47e46685e38164123937fffa8c3072">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractIntegral_1a9570853b5def96e519e54fc81a14f840">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACos_1aa0c7176fd612d3d1ed3f1f61eb900399">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACosh_1acb4452efbe7c588945a6f4e78d69d2fc">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1Angle_1a739e0603cbf9fdee3c3a5373ff96a04a">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASin_1afec8424240e853545a33c5c260195716">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASinh_1a4fb38ca160a4e8e770885ecaf2cc62f8">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATan_1a4b4ed4cfcd4c834f3a99ac2a474bad51">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1ATanh_1a96c5e0b223b93c2a4469a73dfe3924f6">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1Commutator_1a74087e962f48d16fce0c02537372eea6">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complex_1acb2b53b0866d8fb7fb6a3911285944aa">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1Constant_1ac7602a9ee61e0821667fa6264c003a0b">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cos_1ae4305e350e7d257c189df1d051169f9c">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cosh_1a028b7c99b3703dd1fb12c47cada7aaaf">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1Derivative_1af13a07941f0d3c519aca857daa01ee10">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1DiracDelta_1aa5b3c23a06e1de1af366eac1470784d6">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1Exp_1aff1fdef24f13fcc5f8ccccb8152eaa63">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1Factorial_1aff04d4330b43f2a0c54d1f2089d09e97">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1Float_1ad8c19d92099f26157248fc9023f9f599">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1Imaginary_1a41cff9496eaf914c3a55a2ded645d334">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integer_1a341c2f0b7aa9cd523ff5ee48c9ba49f0">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integral_1a1c9d0d773d2fcc59eaf1e72dd55695df">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFactorial_1ab973e4c55cd0ecc72949b97de3029c98">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFraction_1a36c47cf74777eb484bd138d826c23edc">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1Log_1a6fa3e9448a30bfb341a7ef9253841240">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1Polynomial_1ac50287568d1413fc72734a631e1e9f5c">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1a01955e262d0a06de299d1debf1e14da8">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1a3830459faf91d3cf17c7fa401fb00557">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sin_1a4a9faa3552509a110f6182306a3dd66c">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sinh_1a8c235daf099d1ff4ebbff9fa846a7e82">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1a7dd23134290bcfeffb529e2c03ca17ff">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tan_1a53bc7f2997e0380a6d148c2f1dbf395a">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tanh_1a4a70018c2b554641a3ab51291ca4a878">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1a7a1fc7737cce9da527d3796d2fd711d8">derive</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1a22efd34dbcb5934a5acaf95efeef91b3">derive</reimplementedby>
        <reimplementedby refid="classmty_1_1Propagator_1afecab05b1d6f115e0e088de0fdba9cec">derive</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Calculates the derivative of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> wrt another. </para>
        </briefdescription>
        <detaileddescription>
<para>It is possible to derive wrt any complicated expr. In this case however, the calculation is <bold>not</bold> <bold>always</bold> <bold>mathematically</bold> <bold>correct</bold>. The program just searches for equal <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> or <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> with the same name. In particular dx/d(exp(x))=0. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression wrt which we derive. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The derivative. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="871" column="27" bodyfile="src/csl/abstract.cpp" bodystart="740" bodyend="743"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a0bc0de9c4ce5f77fc716af0f502d13d3" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::Abstract::factor</definition>
        <argsstring>(bool full=false) const</argsstring>
        <name>factor</name>
        <qualifiedname>csl::Abstract::factor</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractBuildingBlock_1a2f12cede626ece5382c9869d32c32146">factor</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1a0a9110ce4150f135902865efdd99c130">factor</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1ad13204b56adf098d9c4b886ea7b8681f">factor</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1ad9eed372c276bc55ce8614a94962fef6">factor</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a9b1f0b9354e966da0d740965ec068ccd">factor</reimplementedby>
        <reimplementedby refid="classcsl_1_1ISum_1a04d25076743802b4a5d98f082e3441c6">factor</reimplementedby>
        <reimplementedby refid="classcsl_1_1Polynomial_1ae49aeb195fc59129d3c9e087b32a35b1">factor</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1af56a4a850dcb91db747ff8ca36f458a2">factor</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1a984d8c40c787a0d7350aa0de1969c65f">factor</reimplementedby>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para><bold>Factors</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>This function tries to factor the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> wrt any <bold>factor</bold>. This will be more involved in calculation than the other factorizing function that takes the factor as a parameter. So this function <bold>must be used only</bold> if we don&apos;t know the factors we want at the end. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>full</parametername>
</parameternamelist>
<parameterdescription>
<para>If true the factorization is <bold>recursive</bold> through all the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="881" column="27" bodyfile="src/csl/abstract.cpp" bodystart="726" bodyend="729"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a8fb3d657c65606d520688db6401fe650" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::Abstract::factor</definition>
        <argsstring>(Expr_info factor, bool full=false) const</argsstring>
        <name>factor</name>
        <qualifiedname>csl::Abstract::factor</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractBuildingBlock_1a447f940bf0a08d13297fde0b50b4cb84">factor</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1a8bfd43c575fadc19e46948953af5f2a5">factor</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1a281d2d19b84b9b5fec66dbf1eb89a27d">factor</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1a71ffe88901a200f59bdb88d4adf09a44">factor</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a368c2a6b5fb359cc8f6f209ec548f0ad">factor</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1aeb31f0009bdb90913b98c693578b54a3">factor</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1afff58e758180748e03f566e9ac83e728">factor</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>factor</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para><bold>Factors</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> wrt a <bold>particular</bold> <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>factor</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> wrt which we try to factor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>full</parametername>
</parameternamelist>
<parameterdescription>
<para>If true the factorization is <bold>recursive</bold> through all the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="888" column="27" bodyfile="src/csl/abstract.cpp" bodystart="730" bodyend="733"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ab3746f1d3667846824ea51b8a2e00d31" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::Abstract::collect</definition>
        <argsstring>(std::vector&lt; Expr &gt; const &amp;factors, bool full=false) const</argsstring>
        <name>collect</name>
        <qualifiedname>csl::Abstract::collect</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1ac4f47febdbe3b773bce05b39d506e452">collect</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1a2b1a66c3b926cd7a95060464a3bb6a62">collect</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1accd66bc16179cf88684a6db68e277921">collect</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1af1f3a6d6201fef00ca9d4ad334cd01bd">collect</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1aeec6c024c50776cf5439872586451579">collect</reimplementedby>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; const &amp;</type>
          <declname>factors</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Collects terms in sum according to some factors given by the user. </para>
        </briefdescription>
        <detaileddescription>
<para>This function allows the factor with some specific scalar variables. For example, <formula id="6">$ ax + ay + by $</formula> can be factored in two ways. Either with <formula id="7">$ (a, b) $</formula> which gives <formula id="8">$ a(x+y) + by $</formula> ; or with <formula id="9">$ (x, y) $</formula> which gives <formula id="10">$ ax + (a+b)y $</formula>. With the collect function it is possible to choose precisely the set of variables that will be factored to express results in a standard way.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>factors</parametername>
</parameternamelist>
<parameterdescription>
<para>Factors to search in the expression. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>full</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean (default = false) that tells if the collection must be recursive (full expression depth).</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The collected expression if modifications have been done. </para>
</simplesect>
<simplesect kind="return"><para>std::nullopt else.</para>
</simplesect>
<simplesect kind="note"><para>This function will probably replace the <ref refid="classcsl_1_1Abstract_1a0bc0de9c4ce5f77fc716af0f502d13d3" kindref="member">factor()</ref> function in the future.</para>
</simplesect>
<simplesect kind="note"><para>For now, the collect function does not support factorization by indicial tensors, whereas <ref refid="classcsl_1_1Abstract_1a0bc0de9c4ce5f77fc716af0f502d13d3" kindref="member">factor()</ref> does. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="915" column="27" bodyfile="src/csl/abstract.cpp" bodystart="735" bodyend="738"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a43520e1d6d5fdad9b50f77c6e027f928" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::suppressTerm</definition>
        <argsstring>(Expr_info expr) const</argsstring>
        <name>suppressTerm</name>
        <qualifiedname>csl::Abstract::suppressTerm</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractIntegral_1ac5fa23e3bd78501937629e10d1938ea5">suppressTerm</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integral_1a0c07c13fb5d171702866ce1a7418b166">suppressTerm</reimplementedby>
        <reimplementedby refid="classcsl_1_1IProd_1aca4461b782859509b8a9a1deb3846bc3">suppressTerm</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1a4c86c0033639557a339816bf9a80a9a7">suppressTerm</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1ad278cc42d80c2429fc3f6cd2abe38b33">suppressTerm</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1a37d045772a3fbedf76bf72588ee2e212">suppressTerm</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Remove a factor from an expr, that must have been determined before. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>factor</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to remove </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The expr in which <bold>factor</bold> has been removed </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="923" column="18" bodyfile="src/csl/abstract.cpp" bodystart="745" bodyend="748"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a4eeedaeaa39e75facf1060dce7c57a8f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>std::optional&lt; Expr &gt; csl::Abstract::suppressExponent</definition>
        <argsstring>(Expr const &amp;factor, Expr const &amp;exponent) const</argsstring>
        <name>suppressExponent</name>
        <qualifiedname>csl::Abstract::suppressExponent</qualifiedname>
        <reimplementedby refid="classcsl_1_1Pow_1a3f66770914a5aeb7b83cbfa5f1b9eca6">suppressExponent</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1a3b491384c2717ae8b618d91dd8db39f1">suppressExponent</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>factor</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>exponent</declname>
        </param>
        <briefdescription>
<para>Returns the expression where the factor <bold>factor^exponent</bold> has been suppressed. </para>
        </briefdescription>
        <detaileddescription>
<para>This function works the same manner as <ref refid="classcsl_1_1Abstract_1ac513c930caa9939c2b9557f36a34ee69" kindref="member">getExponents()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>factor</parametername>
</parameternamelist>
<parameterdescription>
<para>Factor to suppress. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>exponent</parametername>
</parameternamelist>
<parameterdescription>
<para>Exponent of the factor to suppress.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The modified expression if the factor has been found. </para>
</simplesect>
<simplesect kind="return"><para>std::nullopt else.</para>
</simplesect>
<simplesect kind="note"><para>This function may replace in the future the functions <ref refid="classcsl_1_1Abstract_1a27ad666bf7d533607da9675b0c645ee9" kindref="member">askTerm()</ref> and <ref refid="classcsl_1_1Abstract_1a43520e1d6d5fdad9b50f77c6e027f928" kindref="member">suppressTerm()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="940" column="27" bodyfile="src/csl/abstract.cpp" bodystart="750" bodyend="756"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a3a87ab082152fea4fc2444659028b840" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::Abstract::expand</definition>
        <argsstring>(bool full=false, bool inPlace=false) const</argsstring>
        <name>expand</name>
        <qualifiedname>csl::Abstract::expand</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractBuildingBlock_1a7cbbd2edd75a84057f1622826c1efd3a">expand</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1a5dbc9bf69fbe0beb1034b21f83ba6aba">expand</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1a8bc591288c134387b71c758229d65f54">expand</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1aa7b240760c1c7d930053fbd38c812196">expand</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a09396a6b80940ac8c99604e9b845c815">expand</reimplementedby>
        <reimplementedby refid="classcsl_1_1Exp_1a53d5fa8b9bf211862d9c6dde6fcad3a6">expand</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1a7e4ec8aa653557544dd3063af72d816f">expand</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1a7e4ec8aa653557544dd3063af72d816f">expand</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1a7e4ec8aa653557544dd3063af72d816f">expand</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1a7e4ec8aa653557544dd3063af72d816f">expand</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1ad5d18f22f9eed16868b1e8e14a0797c3">expand</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1a2c508afc1d4a74cd1ca69b1f900993d5">expand</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1add5adbf1747cd9343c96dca5a2b7479b">expand</reimplementedby>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>inPlace</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para><bold>Develops</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>This function concerns only products (and exponents) that will be flatten to give at the end a sum of independant terms.<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>full</parametername>
</parameternamelist>
<parameterdescription>
<para>If true the expandment is <bold>recursive</bold> through all the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The expand <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="949" column="27" bodyfile="src/csl/abstract.cpp" bodystart="716" bodyend="719"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aeb48aaaa856582b6359037fe94d2419b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::Abstract::expand_if</definition>
        <argsstring>(std::function&lt; bool(Expr const &amp;)&gt; const &amp;f, bool full=false, bool inPlace=false) const</argsstring>
        <name>expand_if</name>
        <qualifiedname>csl::Abstract::expand_if</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1adda5dcff671af0afed2ce13d81b1a903">expand_if</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1a3be99a2a139aeb34596b598bafa9975d">expand_if</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1af09641d4d997d869626ff660ca4d3f8b">expand_if</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a8907475ad6468725bafe0c81dfbeb688">expand_if</reimplementedby>
        <reimplementedby refid="classcsl_1_1Exp_1a0742b26f0efd5a82473f3d8b26524fcd">expand_if</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1a453d864df2f26dcedca00592cc49ea55">expand_if</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1a453d864df2f26dcedca00592cc49ea55">expand_if</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1a453d864df2f26dcedca00592cc49ea55">expand_if</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1a453d864df2f26dcedca00592cc49ea55">expand_if</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1a9b2bb69232d43c764369d8859662ecda">expand_if</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1aa6bb716b3dea854dd7e897976cf08788">expand_if</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1a1fee5554d976f77bf0e2dd5a451890b7">expand_if</reimplementedby>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>inPlace</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para><bold>Develops</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>This function concerns only products (and exponents) that will be flatten to give at the end a sum of independant terms.<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Functions that returns a boolean that determines which arguments must be expanded in products.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>full</parametername>
</parameternamelist>
<parameterdescription>
<para>If true the expandment is <bold>recursive</bold> through all the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The expand <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="960" column="5" bodyfile="src/csl/abstract.cpp" bodystart="720" bodyend="725"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a415f64fdddaae445014d5e052956f889" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::Abstract::getRealPart</definition>
        <argsstring>() const</argsstring>
        <name>getRealPart</name>
        <qualifiedname>csl::Abstract::getRealPart</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractBuildingBlock_1acd32aa346383a68ef69a48b56669deff">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1abccb4ba9f313edd3a3939c317afbc14e">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1ab1d0e4f2b4d063838158829972c2160a">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1a4740c75c01e1d8aeb7db075fc5377789">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1ab99d86f5bed81171962f0cf99415bfba">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACos_1a16301f8ed54cac63ac5389fc179f24d6">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASin_1ac0f8218b321a2294612e25d3e57c2318">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1BooleanOperator_1aaedb35156c894b14afd91ca75d620fd3">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complex_1a0a71859b7fdc28a6cd36290823282746">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complexified_1a5de9b50162c5af5177a928e855e6b71b">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cos_1addc14896700e9950baee3374a09b558d">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cosh_1a3d88db8dd64a46ef1cc70b1a0d19bca3">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1DiracDelta_1af86344bc4071f901591cc1b50b915257">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Exp_1a3e803100efb959d15e40b0e69aa9a369">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Imaginary_1a3f78df436661ecce2ebfdd97324435c7">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Log_1ab37426baaea4c8e148ee683b488d0fb2">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1a74b08ed837b9be3299e99b5b355cb4d4">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sin_1a35ffd397f83edf315fd120c96f44063a">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sinh_1a5888952203e8271368e1aa19681afac4">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1a340d0daf8560d7d9ec73a30a0e5b4fce">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tan_1a89fd2f3ff51edc27812a0440189da5cc">getRealPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tanh_1a64eca21f5e81ff0a85e9d2bbd919edcd">getRealPart</reimplementedby>
        <briefdescription>
<para><bold>Evaluates</bold> the <bold>real part</bold> of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> and returns it. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The real part of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="967" column="27" bodyfile="src/csl/abstract.cpp" bodystart="636" bodyend="639"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a43f44bbb3685fc9f4a0402223b2e1004" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::getImaginaryPart</definition>
        <argsstring>() const</argsstring>
        <name>getImaginaryPart</name>
        <qualifiedname>csl::Abstract::getImaginaryPart</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1a484a42c8d029d02f2def2df2bf24c7c0">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1a24aee4ffda2255a56fd2eb2e04c9baad">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1a232e9782e303c525a18f436e5e5f97b9">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a4d3d4dbce8837fc40b19131a019044a3">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACos_1aab3e1ceb5273ff6ada3c1d0d207f75d3">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASin_1ab7c943492f3eb479cc7f846049e86811">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1BooleanOperator_1a54853bc9447a6cf90ab9f6adc56e5825">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complex_1a38b17d76b63dc1afdb59c4405b1aff6d">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complexified_1a11702661de0ea3b9c59b1f23af0ca0c0">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cos_1adfb13db23ecb0b199fd19ce03a68af09">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cosh_1a86f7a0850d4ee1968733701c27273fce">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1DiracDelta_1aea8385f39d0ddccf6b45caa1942ec3cd">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Exp_1a08b474f3f0dbf2255e4c142ad5e095e1">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Imaginary_1ae7380d519a460d8cf1dff4f676b9df78">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Log_1a2c9e7604ea16b86991190c95a48b6819">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1add2e178b9370eba2bd70d3ed17512a0c">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sin_1a84960733192e56a4335215ba5ebb6a65">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sinh_1aa9674cc4b3452c469d0c1314e3c8bd5b">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1a91c2be7f869326606fba475ea557b409">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tan_1af3ffacb8a8af004785a01eb099d5c246">getImaginaryPart</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tanh_1a6079ee469f697fb680639537590ebd0f">getImaginaryPart</reimplementedby>
        <briefdescription>
<para><bold>Evaluates</bold> the <bold>imaginary part</bold> of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> and returns it. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The imaginary part of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="972" column="18" bodyfile="src/csl/abstract.cpp" bodystart="641" bodyend="644"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a859f792aec52ba1fe1181f81d1cc3451" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::Abstract::getComplexModulus</definition>
        <argsstring>() const</argsstring>
        <name>getComplexModulus</name>
        <qualifiedname>csl::Abstract::getComplexModulus</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractBuildingBlock_1a09e06ecdb4eb9c6f8434c19ede046fa1">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1ab8d3db6601adde22f9cfcaa5b046bcbe">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1a83aa54cdff8a16f0a305358d992096f1">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1ac1bea898b7169caabc409badff44c710">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a1c8b58da63fe78c40174e6f2f582cbf3">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACos_1a9363acfe89a647a562322a036fe68469">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASin_1a776b7c1794fe574114e1e3198d73fa18">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1BooleanOperator_1ae0c3f8e40eb89cd4e5b6c9ed8ee88ae1">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complex_1afc7177213e2612bddfe1e299847a0386">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complexified_1a05b65b2f6cdbc13a1d757a3f90ae7c0c">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cos_1a7f26952b1462ae3b1cd2ee13ce5dcaff">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cosh_1a1eead10ed28b194fd75399d748a63254">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1DiracDelta_1acb4f35b6aef57ce0426f581f65ad7d68">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1Exp_1a6fd77dde2c403a67d2020966a14b0033">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1Imaginary_1a6a4442943faf0d148692e6f3f70823b2">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1Log_1a130216294a13120423ff0d742321d4b1">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1af42fef880d91a3705f0a86065f53560d">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sin_1a34f3048a1f09a214bc240cb0030c2c11">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sinh_1a9c8562fa4fa0a8b9bfd299659b2948cf">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1a6a358933e479aa4dcb68c9fff7a4dcc3">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tan_1a34ccf0fdcfa2a43f5725e32e9c201aeb">getComplexModulus</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tanh_1ae5ecb5e85628afc42d25872291a718ed">getComplexModulus</reimplementedby>
        <briefdescription>
<para><bold>Evaluates</bold> the <bold>modulus in the complex plane</bold> of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> and returns it. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The modulus part of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="977" column="27" bodyfile="src/csl/abstract.cpp" bodystart="646" bodyend="649"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a9cc64c66894acafc1f069dc40072084b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::Abstract::getComplexArgument</definition>
        <argsstring>() const</argsstring>
        <name>getComplexArgument</name>
        <qualifiedname>csl::Abstract::getComplexArgument</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1a14a9ddd387b869c129c48dfaea5974ad">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1ae67e2d46dfb78e3278fc2134b7d039e4">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1a46c3300eb0f87234002c476d3c7c9a14">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractNumerical_1af911961cd47a4cec8c31cb9fafaf74d6">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1ACos_1a745db1e3e6c7e9afb433a89b0f10b0a0">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1ASin_1a390673a164b5daae797188ebebc2a4fc">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1BooleanOperator_1af1a8f3a0f97d62f6da78d016b15415dd">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complex_1a3cbe87d94da0eeca27369afc69f2fa4d">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complexified_1ab70d880a6d5eaf52b7d365c9d0c29f86">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cos_1aae93b65d1aa61e9c6a4422d5c168f617">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1Cosh_1a6efd3054c14922af72c0e057395869f2">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1DiracDelta_1a3dd7b9fb46af05be5d43baa83412ebac">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1Exp_1a9834c3827d1af36549c055f3a4f65c6d">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1Imaginary_1a4a8beac2eb84273afdfbb771918f04e3">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1Log_1a16aff9ed9a21cb6653deb96048f29225">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1aad33ce50bdda177231353749abb24b71">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sin_1a91951762c50bbf889d5d0aa1cfd7847f">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sinh_1a596d1ee28a2d06a4e4c0bf55d7f12041">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1adc1cd9a04f2299205aa8d896ba03482b">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tan_1a36c5713ba2b02de5da810bbdc1cf0cce">getComplexArgument</reimplementedby>
        <reimplementedby refid="classcsl_1_1Tanh_1a3c66791362233e86cf739e907303d697">getComplexArgument</reimplementedby>
        <briefdescription>
<para><bold>Evaluates</bold> the <bold>argument in the complex plane</bold> of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> and returns it. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The argument part of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="983" column="27" bodyfile="src/csl/abstract.cpp" bodystart="651" bodyend="654"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a03e8bdba20c6192a948892f212f09dbe" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::Abstract::getComplexConjugate</definition>
        <argsstring>() const</argsstring>
        <name>getComplexConjugate</name>
        <qualifiedname>csl::Abstract::getComplexConjugate</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1a04866fe8e757f391e79d6aaa18885221">getComplexConjugate</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1a3a466c8804d5c855dd2b906be2b1be5f">getComplexConjugate</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1abd84cb1aa54ef9875bae6f806ed1d753">getComplexConjugate</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a2a2c1314e65baf839542e6fb7845ad44">getComplexConjugate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complex_1ae87c5c2100541896a3b474d5908a6e3d">getComplexConjugate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complexified_1a9d3fec789b00de1625df53232da4cf30">getComplexConjugate</reimplementedby>
        <reimplementedby refid="classcsl_1_1ImaginaryPart_1adfe21172f295b803952c5541750b338e">getComplexConjugate</reimplementedby>
        <reimplementedby refid="classcsl_1_1RealPart_1a1f8b200d737183f15a2edb7d923d464d">getComplexConjugate</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1a1b6a2e64b07222e4d5d126d2281c4816">getComplexConjugate</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1a684ed9584f9bbe4ffc1e842b84a05ed0">getComplexConjugate</reimplementedby>
        <reimplementedby refid="classmty_1_1PolarizationField_1ae9b8986daf8008b813c91fec023287d0">getComplexConjugate</reimplementedby>
        <reimplementedby refid="classmty_1_1Propagator_1ab9ecfc58caf6e92e12beb50cdae7aea3">getComplexConjugate</reimplementedby>
        <reimplementedby refid="classmty_1_1QuantumField_1ae5c5bb4225bf70153eb194af7bbf1dc2">getComplexConjugate</reimplementedby>
        <briefdescription>
<para>Calculates and returns the complex conjugate of the expression. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>\bar{*this}. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="988" column="27" bodyfile="src/csl/abstract.cpp" bodystart="656" bodyend="659"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a6305ce90c795bfb416d8e958c62f905c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
        <definition>Expr &amp; csl::Abstract::applySelfStructureOn</definition>
        <argsstring>(Expr &amp;expr) const</argsstring>
        <name>applySelfStructureOn</name>
        <qualifiedname>csl::Abstract::applySelfStructureOn</qualifiedname>
        <reimplementedby refid="classcsl_1_1TensorElement_1afbfaf24db5ee68ab64a2378248fdf7e4">applySelfStructureOn</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="990" column="18" bodyfile="src/csl/abstract.cpp" bodystart="661" bodyend="666"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a404c5e89a3aad8a8dabcb56d4120c0fe" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::Abstract::getTransposed</definition>
        <argsstring>(const Space *space, bool applyProp=true) const</argsstring>
        <name>getTransposed</name>
        <qualifiedname>csl::Abstract::getTransposed</qualifiedname>
        <reimplementedby refid="classcsl_1_1IProd_1ac637d764dc5944b74427194fc885bbe7">getTransposed</reimplementedby>
        <reimplementedby refid="classcsl_1_1ISum_1a72f7f4668854eedf292b460a75d45dca">getTransposed</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1ae47bc7e79e284964b2a8447bf917f48f">getTransposed</reimplementedby>
        <param>
          <type>const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> *</type>
          <declname>space</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>applyProp</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="992" column="27" bodyfile="src/csl/abstract.cpp" bodystart="668" bodyend="671"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aca3debb143668fd3ab75a27a47dd0c13" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::Abstract::getTransposed</definition>
        <argsstring>(const std::vector&lt; const Space * &gt; &amp;spaces, bool applyProp=true) const</argsstring>
        <name>getTransposed</name>
        <qualifiedname>csl::Abstract::getTransposed</qualifiedname>
        <reimplementedby refid="classcsl_1_1IProd_1a4f00332faae45fd8f1e2226ec4600c2a">getTransposed</reimplementedby>
        <reimplementedby refid="classcsl_1_1ISum_1a4f716e1c57140443aa3733c5b485c668">getTransposed</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1a7cc7fb9e1f39bcebc90170e8dd526d43">getTransposed</reimplementedby>
        <param>
          <type>const std::vector&lt; const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> * &gt; &amp;</type>
          <declname>spaces</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>applyProp</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="996" column="5" bodyfile="src/csl/abstract.cpp" bodystart="673" bodyend="677"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aa5b707a5efdaef7c7945cbd921c3f526" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::Abstract::getHermitianConjugate</definition>
        <argsstring>(const Space *space) const</argsstring>
        <name>getHermitianConjugate</name>
        <qualifiedname>csl::Abstract::getHermitianConjugate</qualifiedname>
        <reimplementedby refid="classcsl_1_1ISum_1a244c1407abf12a33128711fd106cd930">getHermitianConjugate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1a71e5bf0f4ece0fec6e4aa0eb7a70f7be">getHermitianConjugate</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1ab38b54f3efd6b9950b6d3334a224caa1">getHermitianConjugate</reimplementedby>
        <reimplementedby refid="classmty_1_1FermionPropStruct_1aede26ba1117229a7d4d5422f184295c4">getHermitianConjugate</reimplementedby>
        <param>
          <type>const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> *</type>
          <declname>space</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1000" column="5" bodyfile="src/csl/abstract.cpp" bodystart="679" bodyend="682"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aff5cca2b2c8190e59f6e34cb1e383d36" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::Abstract::getHermitianConjugate</definition>
        <argsstring>(const std::vector&lt; const Space * &gt; &amp;spaces) const</argsstring>
        <name>getHermitianConjugate</name>
        <qualifiedname>csl::Abstract::getHermitianConjugate</qualifiedname>
        <reimplementedby refid="classcsl_1_1ISum_1ac4c25585bc6235cb3034c63a4e4ab300">getHermitianConjugate</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1a52f6516bb7bbea2ad5a4fe7754acc0a8">getHermitianConjugate</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1ac1596174400a2ccd49d56b736fa8114a">getHermitianConjugate</reimplementedby>
        <reimplementedby refid="classmty_1_1FermionPropStruct_1abebddb9f6c266218e9d766262026a9e9">getHermitianConjugate</reimplementedby>
        <param>
          <type>const std::vector&lt; const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> * &gt; &amp;</type>
          <declname>spaces</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1003" column="5" bodyfile="src/csl/abstract.cpp" bodystart="685" bodyend="688"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ade540a127da7304f2b7282f4dcaffc7f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::Abstract::getPolynomialTerm</definition>
        <argsstring>(Expr_info t_variable, int order) const</argsstring>
        <name>getPolynomialTerm</name>
        <qualifiedname>csl::Abstract::getPolynomialTerm</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractBuildingBlock_1a05d8a8cf5ba9ae9563c09b65bac10c2f">getPolynomialTerm</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractElement_1a028ecff66278c1e385280b761388b929">getPolynomialTerm</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1a295d149cfcfa20527b12f3bc57e95811">getPolynomialTerm</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1ab552c778033130c31c476b2e1939e84e">getPolynomialTerm</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>t_variable</declname>
        </param>
        <param>
          <type>int</type>
          <declname>order</declname>
        </param>
        <briefdescription>
<para>Calculates and returns the polynomial term corresponding to <bold>*this</bold> with the variable <bold>t_variable</bold> at order <bold>order</bold>. In particular, this function assumes that the checks have already been made with the function <ref refid="classcsl_1_1Abstract_1acae10d5685ccec295fbd9be7996073cb" kindref="member">isPolynomial()</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t_variable</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Variable" kindref="compound">Variable</ref> of the polynomial. \order Order of <bold>*this</bold> in <bold>t_variable</bold>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The same expression as (*this) with the term <bold>t_variable^order</bold> removed. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1012" column="27" bodyfile="src/csl/abstract.cpp" bodystart="913" bodyend="921"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a316956fea77627a716500a2bbfc1f3b7" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::applyOperator</definition>
        <argsstring>(const Expr &amp;operand, bool leaveEmpty=false) const</argsstring>
        <name>applyOperator</name>
        <qualifiedname>csl::Abstract::applyOperator</qualifiedname>
        <reimplementedby refid="classcsl_1_1Operator_1ae9da277be3e179944e647d54acf13eea">applyOperator</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1ae9da277be3e179944e647d54acf13eea">applyOperator</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1ae9da277be3e179944e647d54acf13eea">applyOperator</reimplementedby>
        <reimplementedby refid="classcsl_1_1Operator_1ae9da277be3e179944e647d54acf13eea">applyOperator</reimplementedby>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>operand</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>leaveEmpty</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Apply the operator on an <bold>operand</bold>, iif the expression is an operator. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>operand</parametername>
</parameternamelist>
<parameterdescription>
<para>Operand of the operator. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The operator filled with <bold>operand</bold>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1020" column="18" bodyfile="src/csl/abstract.cpp" bodystart="980" bodyend="985"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a101219973341a39cf15f07e5e1aa388f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::addition_own</definition>
        <argsstring>(const Expr &amp;expr) const</argsstring>
        <name>addition_own</name>
        <qualifiedname>csl::Abstract::addition_own</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a91561bc3d02d055e86b7f3e35a76e25c">addition_own</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complex_1a69a2af4ec8f4f12a56cc1fc41223bc78">addition_own</reimplementedby>
        <reimplementedby refid="classcsl_1_1Float_1ac269f085d5e4f9f43d4a5500751cfe33">addition_own</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integer_1ad00b35bd5e52a36445b6e99265f20240">addition_own</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFraction_1ac3d446b547d4c8b7d3b5359b87c756d5">addition_own</reimplementedby>
        <reimplementedby refid="classcsl_1_1Polynomial_1aa3ba91ac2475de7236ee8d48b85fc9fb">addition_own</reimplementedby>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Contains implementation of special addition for Numerical- and Vectorial-types. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Right operrand of the addition. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The sum of the two operands. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1038" column="18" bodyfile="src/csl/abstract.cpp" bodystart="842" bodyend="847"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a4f5ed458ba62f5b4cf61a9e1f8568af1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::multiplication_own</definition>
        <argsstring>(const Expr &amp;expr, bool side=1) const</argsstring>
        <name>multiplication_own</name>
        <qualifiedname>csl::Abstract::multiplication_own</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a81eebf482c8b342b75aaec063533790c">multiplication_own</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complex_1a79889fc60628f60564ed7a60b1fad1a3">multiplication_own</reimplementedby>
        <reimplementedby refid="classcsl_1_1Float_1a0acfdd639afdbbb6f904a2cd74aaac31">multiplication_own</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integer_1a69ec91334a0491aadfebc431d2174343">multiplication_own</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFraction_1a084df9668bd846370585d44ba07d75a0">multiplication_own</reimplementedby>
        <reimplementedby refid="classcsl_1_1Polynomial_1a83e31e00d46a46aaed0789dfc8170a11">multiplication_own</reimplementedby>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>side</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
<para>Contains implementation of special multiplication for Numerical- and Vectorial-types. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Right operrand of the product. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The product of the two operands. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1044" column="18" bodyfile="src/csl/abstract.cpp" bodystart="849" bodyend="854"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a1578c74aee1050b806a67e7a81a67f5c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::division_own</definition>
        <argsstring>(const Expr &amp;expr) const</argsstring>
        <name>division_own</name>
        <qualifiedname>csl::Abstract::division_own</qualifiedname>
        <reimplementedby refid="classcsl_1_1Complex_1a63e2aab7c637beb7fa67ccbc9b8b8c12">division_own</reimplementedby>
        <reimplementedby refid="classcsl_1_1Float_1a7a35025055eaba4cc64707ac79e2aabc">division_own</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integer_1a98edda5fd2b84eb6fb6a5c0000d4c4fe">division_own</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFraction_1a0dc80b9e319900617056e4ab3c233c06">division_own</reimplementedby>
        <reimplementedby refid="classcsl_1_1Polynomial_1ace27cf683f51c1a50f35e28b9250e5e6">division_own</reimplementedby>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Contains implementation of special division for Numerical- and Polynomial-types. For polynomial, the euclidean division of two polynomials is implemented. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Right operrand of the division. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The division of the two operands. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1051" column="18" bodyfile="src/csl/abstract.cpp" bodystart="856" bodyend="861"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aa2696a0feb43766ef54e1e3dd3d6d134" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::exponentiation_own</definition>
        <argsstring>(const Expr &amp;expr) const</argsstring>
        <name>exponentiation_own</name>
        <qualifiedname>csl::Abstract::exponentiation_own</qualifiedname>
        <reimplementedby refid="classcsl_1_1Complex_1a46dbf92ea6c22239857b6e41eb01b297">exponentiation_own</reimplementedby>
        <reimplementedby refid="classcsl_1_1Float_1a6a20dfce78e1b4a979d11731db030987">exponentiation_own</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integer_1a26e655bb92db0fad0c3970746c8e5c93">exponentiation_own</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFraction_1a2184e11c09413bea72653bad45e8f997">exponentiation_own</reimplementedby>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Contains implementation of special exponentiation for Numerical- and Vectorial-types. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>exponent. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The exponentiation of the two operands. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1057" column="18" bodyfile="src/csl/abstract.cpp" bodystart="863" bodyend="868"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a5b77f008f4b95030641224877004f06c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::getRegularExpression</definition>
        <argsstring>() const</argsstring>
        <name>getRegularExpression</name>
        <qualifiedname>csl::Abstract::getRegularExpression</qualifiedname>
        <reimplementedby refid="classcsl_1_1Polynomial_1a6bc25a8b8e8da0cebdead8cc869e2134">getRegularExpression</reimplementedby>
        <briefdescription>
<para>Returns a regular expression from the polynomial, that is a sum where the different powers of the variable appear explicitely. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>a <ref refid="classcsl_1_1Sum" kindref="compound">Sum</ref> expression equal to the polynomial. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1067" column="18" bodyfile="src/csl/abstract.cpp" bodystart="928" bodyend="933"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a7b83c6a13716688f45b02e6291d39aba" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::tensordot</definition>
        <argsstring>(const Expr &amp;expr) const</argsstring>
        <name>tensordot</name>
        <qualifiedname>csl::Abstract::tensordot</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a0e4336f06daf87990d127a4b755c121c">tensordot</reimplementedby>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Returns the tensordot of two <bold>Vectorial</bold> expressions. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>The right operand of the tensordot </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The tensor dot of <bold>*this</bold> and <bold>expr</bold>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1077" column="18" bodyfile="src/csl/abstract.cpp" bodystart="1025" bodyend="1030"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a4cc7a46deaa3eaa7593909d74e76d4af" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::dot</definition>
        <argsstring>(const Expr &amp;expr) const</argsstring>
        <name>dot</name>
        <qualifiedname>csl::Abstract::dot</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a0ed41f66d207d34ebafc90bc473109ca">dot</reimplementedby>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Returns the dot product of two <bold>Vectorial</bold> expressions. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>The right operand of the dot product. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>sum _k (*this)[i,j,...,k]*expr[k,l,m,...]. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1083" column="18" bodyfile="src/csl/abstract.cpp" bodystart="1032" bodyend="1037"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aeaf8154e39ff211b12e6382e675ccaad" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::getSum</definition>
        <argsstring>() const</argsstring>
        <name>getSum</name>
        <qualifiedname>csl::Abstract::getSum</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1aa9d43ea7296950633aa2ac848173cb51">getSum</reimplementedby>
        <briefdescription>
<para>Calculates and returns the sum of all elements in the <bold>Vectorial</bold> object. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The sum of all elements. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1088" column="18" bodyfile="src/csl/abstract.cpp" bodystart="1039" bodyend="1044"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a07489d0569bc983718796d21c73f34b3" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::getProduct</definition>
        <argsstring>() const</argsstring>
        <name>getProduct</name>
        <qualifiedname>csl::Abstract::getProduct</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a6f4f1f7c516ee3daceaf5044a40c04d1">getProduct</reimplementedby>
        <briefdescription>
<para>Calculates and returns the product of all elements in the <bold>Vectorial</bold> object. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The product of all elements. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1093" column="18" bodyfile="src/csl/abstract.cpp" bodystart="1046" bodyend="1051"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a0188b049736016c970a2513ed9f6931f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::getVectorialModulus</definition>
        <argsstring>() const</argsstring>
        <name>getVectorialModulus</name>
        <qualifiedname>csl::Abstract::getVectorialModulus</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a8f4326ec0f618785cf0e9d84b448cdd6">getVectorialModulus</reimplementedby>
        <briefdescription>
<para>Returns the Vectorial modulus of the <bold>Vectorial</bold> object, that is defined here as the squared root of the sum of element squared. Example: \sqrt{A_{11}^2+A_{12}^2+\ldot}. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The vectorial modulus of the expression. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1100" column="18" bodyfile="src/csl/abstract.cpp" bodystart="1053" bodyend="1058"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a7dcdc11b64c8c515933882168d0792ef" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::getSubVectorial</definition>
        <argsstring>(int iExcept) const</argsstring>
        <name>getSubVectorial</name>
        <qualifiedname>csl::Abstract::getSubVectorial</qualifiedname>
        <reimplementedby refid="classcsl_1_1Vector_1a8a948bfe3dad300352a8bde32679cb82">getSubVectorial</reimplementedby>
        <param>
          <type>int</type>
          <declname>iExcept</declname>
        </param>
        <briefdescription>
<para>Allows to pick a part of a Vectorial expression, excluding the iExcept^{th} element. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iExcept</parametername>
</parameternamelist>
<parameterdescription>
<para>Element to ignore. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The part of *this excluding iExcept. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1107" column="18" bodyfile="src/csl/abstract.cpp" bodystart="1060" bodyend="1065"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a413c50b2663f57d38c1d3ec3cfeaa3ce" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::getSubVectorial</definition>
        <argsstring>(int iExcept, int jExcept) const</argsstring>
        <name>getSubVectorial</name>
        <qualifiedname>csl::Abstract::getSubVectorial</qualifiedname>
        <reimplementedby refid="classcsl_1_1Matrix_1a1304350a5c07d93607309144d7a58b9f">getSubVectorial</reimplementedby>
        <param>
          <type>int</type>
          <declname>iExcept</declname>
        </param>
        <param>
          <type>int</type>
          <declname>jExcept</declname>
        </param>
        <briefdescription>
<para>Allows to pick a part of a Vectorial expression, excluding the [iExcept^{th},jExcept^{th}] element (useful for matrices). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iExcept</parametername>
</parameternamelist>
<parameterdescription>
<para>Element of the first axis to ignore. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jExcept</parametername>
</parameternamelist>
<parameterdescription>
<para>Element of the second axis to ignore. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The part of *this excluding iExcept. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1115" column="18" bodyfile="src/csl/abstract.cpp" bodystart="1067" bodyend="1072"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a26a0854bca4c47e84a1da36a3de8c49f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::getSubVectorial</definition>
        <argsstring>(const std::vector&lt; int &gt; &amp;exceptions) const</argsstring>
        <name>getSubVectorial</name>
        <qualifiedname>csl::Abstract::getSubVectorial</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a002b8834bc010144ab0666c6697a5d7b">getSubVectorial</reimplementedby>
        <reimplementedby refid="classcsl_1_1Matrix_1a002b8834bc010144ab0666c6697a5d7b">getSubVectorial</reimplementedby>
        <reimplementedby refid="classcsl_1_1Vector_1a002b8834bc010144ab0666c6697a5d7b">getSubVectorial</reimplementedby>
        <param>
          <type>const std::vector&lt; int &gt; &amp;</type>
          <declname>exceptions</declname>
        </param>
        <briefdescription>
<para>Allows to pick a part of a Vectorial expression, excluding the iExcept^{th} element. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iExcept</parametername>
</parameternamelist>
<parameterdescription>
<para>Element to ignore. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The part of *this excluding iExcept. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1122" column="18" bodyfile="src/csl/abstract.cpp" bodystart="1074" bodyend="1079"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a29261a946b3398b6129237620754a8b9" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::getSubVectorial</definition>
        <argsstring>(const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;keepIndices) const</argsstring>
        <name>getSubVectorial</name>
        <qualifiedname>csl::Abstract::getSubVectorial</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a9a15f8a9b14ee52361a104d2206c8bef">getSubVectorial</reimplementedby>
        <reimplementedby refid="classcsl_1_1Matrix_1a9a15f8a9b14ee52361a104d2206c8bef">getSubVectorial</reimplementedby>
        <reimplementedby refid="classcsl_1_1Vector_1a9a15f8a9b14ee52361a104d2206c8bef">getSubVectorial</reimplementedby>
        <param>
          <type>const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;</type>
          <declname>keepIndices</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1125" column="5" bodyfile="src/csl/abstract.cpp" bodystart="1081" bodyend="1088"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a8a067b70756c4eef758aa88076a95162" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::getSubVectorial</definition>
        <argsstring>(std::vector&lt; std::vector&lt; int &gt; &gt;::const_iterator begin, std::vector&lt; std::vector&lt; int &gt; &gt;::const_iterator end) const</argsstring>
        <name>getSubVectorial</name>
        <qualifiedname>csl::Abstract::getSubVectorial</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a8770e53fba4f253c41b7fa8015f62833">getSubVectorial</reimplementedby>
        <reimplementedby refid="classcsl_1_1Matrix_1a8770e53fba4f253c41b7fa8015f62833">getSubVectorial</reimplementedby>
        <reimplementedby refid="classcsl_1_1Vector_1a8770e53fba4f253c41b7fa8015f62833">getSubVectorial</reimplementedby>
        <param>
          <type>std::vector&lt; std::vector&lt; int &gt; &gt;::const_iterator</type>
          <declname>begin</declname>
        </param>
        <param>
          <type>std::vector&lt; std::vector&lt; int &gt; &gt;::const_iterator</type>
          <declname>end</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1128" column="5" bodyfile="src/csl/abstract.cpp" bodystart="1090" bodyend="1099"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aeb08811cf370616477a92075e4a218ee" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::determinant</definition>
        <argsstring>() const</argsstring>
        <name>determinant</name>
        <qualifiedname>csl::Abstract::determinant</qualifiedname>
        <reimplementedby refid="classcsl_1_1Matrix_1a8015bb0c18517f1fc9429f8c5b95da38">determinant</reimplementedby>
        <briefdescription>
<para>Returns the determinant of the object if it corresponds to a square matrix (or a scalar), 0 else. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>det(<bold>*this</bold>) if <bold>*this</bold> is a square matrix or scalar. </para>
</simplesect>
<simplesect kind="return"><para>0 else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1136" column="18" bodyfile="src/csl/abstract.cpp" bodystart="1101" bodyend="1106"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a9a86d21f5c5f65eb7e524a8f8002c0e7" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::trace</definition>
        <argsstring>() const</argsstring>
        <name>trace</name>
        <qualifiedname>csl::Abstract::trace</qualifiedname>
        <reimplementedby refid="classcsl_1_1Matrix_1a9b6a6fbd8faebb39f785654de2953bc1">trace</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>\sum <emphasis>i A</emphasis>{ii} for a square matrix A. </para>
</simplesect>
<simplesect kind="return"><para>A for a scalar A. </para>
</simplesect>
<simplesect kind="return"><para>0 else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1142" column="18" bodyfile="src/csl/abstract.cpp" bodystart="1108" bodyend="1113"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aacab43e551e9259a39a79378373ce49c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::trace</definition>
        <argsstring>(int axis1, int axis2) const</argsstring>
        <name>trace</name>
        <qualifiedname>csl::Abstract::trace</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a9a79c1dcc4d4ee22c8662ffcc11e5378">trace</reimplementedby>
        <reimplementedby refid="classcsl_1_1Matrix_1a9a79c1dcc4d4ee22c8662ffcc11e5378">trace</reimplementedby>
        <param>
          <type>int</type>
          <declname>axis1</declname>
        </param>
        <param>
          <type>int</type>
          <declname>axis2</declname>
        </param>
        <briefdescription>
<para>Calculates the trace over the axis <bold>axis1</bold> and <bold>axis2</bold> of a tensor. <bold>axis1</bold> and <bold>axis2</bold> can be the same, in which case the trace just corresponds to the sum over this particular axis. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>axis1</parametername>
</parameternamelist>
<parameterdescription>
<para>First axis to contract. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>axis2</parametername>
</parameternamelist>
<parameterdescription>
<para>Second axis to contract. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the trace over axis <bold>axis1</bold> and <bold>axis2</bold>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1151" column="18" bodyfile="src/csl/abstract.cpp" bodystart="1115" bodyend="1120"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a1e97712696e5c40b28bc1e35987fea94" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::transpose</definition>
        <argsstring>() const</argsstring>
        <name>transpose</name>
        <qualifiedname>csl::Abstract::transpose</qualifiedname>
        <reimplementedby refid="classcsl_1_1Matrix_1a5fe3058c93a9dfe149f742c9b601a9b4">transpose</reimplementedby>
        <briefdescription>
<para>Calculates and returns the transpose of a 2D matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A^T for a matrix (2D) A. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1156" column="18" bodyfile="src/csl/abstract.cpp" bodystart="1122" bodyend="1127"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a8c42723e8bc6334c99f00898cc1d59d7" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::hermitian</definition>
        <argsstring>() const</argsstring>
        <name>hermitian</name>
        <qualifiedname>csl::Abstract::hermitian</qualifiedname>
        <reimplementedby refid="classcsl_1_1Matrix_1a59220b3d4637e923b18c619c6e54fe43">hermitian</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1158" column="18" bodyfile="src/csl/abstract.cpp" bodystart="1129" bodyend="1134"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a4faf1ffd8cb3b6c721e128980c0303d8" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::symmetrise</definition>
        <argsstring>() const</argsstring>
        <name>symmetrise</name>
        <qualifiedname>csl::Abstract::symmetrise</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a690f2f1b0748bbd81213335c47535113">symmetrise</reimplementedby>
        <reimplementedby refid="classcsl_1_1Matrix_1ac6c4ce8256eff3054bba06339ddc8525">symmetrise</reimplementedby>
        <briefdescription>
<para>Calculates and returns the symmetrization of a 2D matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>1/2*(A + A^T) for a matrix (2D) A. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1163" column="18" bodyfile="src/csl/abstract.cpp" bodystart="1136" bodyend="1141"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1acd972aed8326d4c13534594e061ee6da" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::antisymmetrise</definition>
        <argsstring>() const</argsstring>
        <name>antisymmetrise</name>
        <qualifiedname>csl::Abstract::antisymmetrise</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a71a8d453b3d5c57f2d09b17e99302ef8">antisymmetrise</reimplementedby>
        <reimplementedby refid="classcsl_1_1Matrix_1a95c95848700fecd5d7041f5c28877946">antisymmetrise</reimplementedby>
        <briefdescription>
<para>Calculates and returns the anti-symmetrization of a 2D matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>1/2*(A - A^T) for a matrix (2D) A. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1168" column="18" bodyfile="src/csl/abstract.cpp" bodystart="1143" bodyend="1148"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a1b68943aa7ecf60a63af0f2f368eef8f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::inverseMatrix</definition>
        <argsstring>() const</argsstring>
        <name>inverseMatrix</name>
        <qualifiedname>csl::Abstract::inverseMatrix</qualifiedname>
        <reimplementedby refid="classcsl_1_1Matrix_1accd49f13248f58c2d65edda3bd6d626e">inverseMatrix</reimplementedby>
        <briefdescription>
<para>Calculates and returns the inverse of a 2D square matrix. The applied method is: A^{-1} = 1/det(A)*Com(A)^T. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A^{-1} for a matrix (2D) A if det(A) != 0. </para>
</simplesect>
<simplesect kind="return"><para>0 else </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1175" column="18" bodyfile="src/csl/abstract.cpp" bodystart="1150" bodyend="1155"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1afeb26e1382411448ce3c65d50fefd8bb" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::getCanonicalPermutation</definition>
        <argsstring>() const</argsstring>
        <name>getCanonicalPermutation</name>
        <qualifiedname>csl::Abstract::getCanonicalPermutation</qualifiedname>
        <reimplementedby refid="classcsl_1_1TensorElement_1ad6f8f7e5b89936e1fa39661b1975c3ce">getCanonicalPermutation</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1181" column="18" bodyfile="src/csl/abstract.cpp" bodystart="1157" bodyend="1162"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a61d3ab932182226f4670a62bbb22af4e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Abstract::applyDiracDelta</definition>
        <argsstring>(const Expr &amp;, const Expr &amp;) const</argsstring>
        <name>applyDiracDelta</name>
        <qualifiedname>csl::Abstract::applyDiracDelta</qualifiedname>
        <reimplementedby refid="classcsl_1_1DiracDelta_1af1b89eac245c8b6223824c1b9f121890">applyDiracDelta</reimplementedby>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1187" column="18" bodyfile="src/csl/abstract.cpp" bodystart="1190" bodyend="1195"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a59ff2950fc8ca319f87a730450f14545" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::Abstract::operator=</definition>
        <argsstring>(double t_value)</argsstring>
        <name>operator=</name>
        <qualifiedname>csl::Abstract::operator=</qualifiedname>
        <reimplementedby refid="classcsl_1_1Constant_1a6cef630b0f3804631f60b6ed22bd3ccc">operator=</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1abf8caba816e7baa5bcea4961187bd0c6">operator=</reimplementedby>
        <param>
          <type>double</type>
          <declname>t_value</declname>
        </param>
        <briefdescription>
<para>Equivalent to the <ref refid="classcsl_1_1Abstract_1aaf7f0692cb84ca861a5b3b641bea518b" kindref="member">setValue()</ref> function. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t_value</parametername>
</parameternamelist>
<parameterdescription>
<para>The new value of the expression. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1196" column="18" bodyfile="src/csl/abstract.cpp" bodystart="935" bodyend="939"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a8334e14cd5789168b037d3888ed60edd" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::operator==</definition>
        <argsstring>(int t_value) const</argsstring>
        <name>operator==</name>
        <qualifiedname>csl::Abstract::operator==</qualifiedname>
        <param>
          <type>int</type>
          <declname>t_value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><bold>True</bold> if the expression is valued and is equal to t_value. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1201" column="18" bodyfile="src/csl/abstract.cpp" bodystart="951" bodyend="954"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a12d929e34039e817e464abc560bd4a9d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::operator==</definition>
        <argsstring>(double t_value) const</argsstring>
        <name>operator==</name>
        <qualifiedname>csl::Abstract::operator==</qualifiedname>
        <param>
          <type>double</type>
          <declname>t_value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><bold>True</bold> if the expression is valued and is equal to t_value. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1205" column="18" bodyfile="src/csl/abstract.cpp" bodystart="956" bodyend="965"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1af5b62a6308638064c42da80e9cc2cb7e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::operator!=</definition>
        <argsstring>(int t_value) const</argsstring>
        <name>operator!=</name>
        <qualifiedname>csl::Abstract::operator!=</qualifiedname>
        <param>
          <type>int</type>
          <declname>t_value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><bold>False</bold> if the expression is valued and is equal to t_value. </para>
</simplesect>
<simplesect kind="return"><para><bold>True</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1209" column="18" bodyfile="src/csl/abstract.cpp" bodystart="941" bodyend="944"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1af4fd1b57df371dac7ccfd5a909620e49" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::operator!=</definition>
        <argsstring>(double t_value) const</argsstring>
        <name>operator!=</name>
        <qualifiedname>csl::Abstract::operator!=</qualifiedname>
        <param>
          <type>double</type>
          <declname>t_value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><bold>False</bold> if the expression is valued and is equal to t_value. </para>
</simplesect>
<simplesect kind="return"><para><bold>True</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1213" column="18" bodyfile="src/csl/abstract.cpp" bodystart="946" bodyend="949"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a3775f3088e784cc924cb7d26e118660e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="pure-virtual">
        <type>bool</type>
        <definition>virtual bool csl::Abstract::operator==</definition>
        <argsstring>(Expr_info expr) const =0</argsstring>
        <name>operator==</name>
        <qualifiedname>csl::Abstract::operator==</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1a7ccf43edff01ef8c6500b5117ac42213">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a45bc5fb9f24b918a685eef9742a4c046">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1Angle_1a92d43b635f0e38a6c1bc57875cf7341d">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1Arbitrary_1a3bd3172760cb664c0c49475d26079d06">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1BooleanOperator_1a508a61cfb27b1a6ce030e21470796b32">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1Commutator_1ab26b56f71268855477174401069842d1">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complex_1aa13ebbff936c3fac16bdf2fc9eea1547">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1Complexified_1a10b02cb2da960264c19926a76a859488">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1Constant_1a3a9305425d1eeb5c684f9c91b97865ac">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1Derivative_1a13a0500ee86e1ba0f316d6a4d5f4d1ae">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1DiracDelta_1aa66032c002b1c5d95bb4499093fa19cc">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1Float_1a76dda7f710c690c2a950d2279c6eae3e">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1Imaginary_1aa98d68b8591062b56a67452e4d84dd2b">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1ImaginaryPart_1a52a90d231dbb0518eebb65e5f21e24eb">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integer_1a000e1bcdac9556d30acbd0a3059308cd">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1Integral_1a4e94f3a5f8d5945d04bc23e3258bc413">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFactorial_1a0df76f746b29d7025b7917cae22179e7">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1IntFraction_1ad0e5efc8234d94656457b21ce95b6946">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1IProd_1af45bd102ad6a062167330ab8715daf78">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1ISum_1ad11402825b61d8997ce188a9abb30d6b">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1Polynomial_1a6ee9ab3e7acf085e35349942cb6c9fc2">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1Pow_1ab241ff256f05031465b1d7c959b4056f">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1Prod_1a1a2c0f67a8aa5798dd9226d721237a8a">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1RealPart_1adac617913cdfa2354a085002f443f123">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1ScalarIntegral_1a86a7f329d187d9abddb819dacf61d5e3">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1Sum_1ae8309f4d05302f47272a5e2ba0e6507c">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1a380f7ce153c1b608c232e86f79bdcbd0">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorElement_1a6ada509cc19d2040553f8f40621914db">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1af7cde5cfd23cb3b4ca4ddbdbcf717db9">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1Variable_1abb165be8425c313e0532831604e11d5f">operator==</reimplementedby>
        <reimplementedby refid="classcsl_1_1VectorIntegral_1a2e912283405785f512234ada336ca5dd">operator==</reimplementedby>
        <reimplementedby refid="classmty_1_1FermionPropStruct_1a4c74e731cad2a0b37f85b034fced264d">operator==</reimplementedby>
        <reimplementedby refid="classmty_1_1FeynmanIntegral_1a7377184c5287a49752d41cc618d5eb5e">operator==</reimplementedby>
        <reimplementedby refid="classmty_1_1Propagator_1a7c3d452c486999e32d030c4448922ec8">operator==</reimplementedby>
        <reimplementedby refid="classmty_1_1QuantumField_1a45e66c19f29f1b8e3e6e0a8244a13772">operator==</reimplementedby>
        <reimplementedby refid="classmty_1_1Wick_1ae82d659cd5fa09a1b3b4a7284e4c282a">operator==</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Compares</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> with another. </para>
        </briefdescription>
        <detaileddescription>
<para>Here if two Abstracts have the same name, the function will return <bold>true</bold> even if they are <bold>not</bold> <bold>mathematically</bold> <bold>equal</bold>. So beware not to name different things the same way. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> to compare. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if the two Abstracts are the same (or have the same name). </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1223" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aee4fa41a5e014f067395467542ee8831" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int csl::Abstract::testDummy</definition>
        <argsstring>(Expr_info expr) const</argsstring>
        <name>testDummy</name>
        <qualifiedname>csl::Abstract::testDummy</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1225" column="9" bodyfile="src/csl/abstract.cpp" bodystart="1197" bodyend="1203"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a1f78f0cce24c93def3050743bc5f2845" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::operator==</definition>
        <argsstring>(const Expr_c &amp;expr) const</argsstring>
        <name>operator==</name>
        <qualifiedname>csl::Abstract::operator==</qualifiedname>
        <param>
          <type>const <ref refid="classstd_1_1shared__ptr" kindref="compound">Expr_c</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1227" column="17" bodyfile="src/csl/abstract.h" bodystart="1626" bodyend="1629"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aed43debcac4a19e0da44986774c522bc" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::operator==</definition>
        <argsstring>(const Expr &amp;expr) const</argsstring>
        <name>operator==</name>
        <qualifiedname>csl::Abstract::operator==</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1228" column="17" bodyfile="src/csl/abstract.h" bodystart="1631" bodyend="1634"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a2376f08c0aa5ffe783090381d102d3ae" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::operator==</definition>
        <argsstring>(const Abstract &amp;other) const</argsstring>
        <name>operator==</name>
        <qualifiedname>csl::Abstract::operator==</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1229" column="17" bodyfile="src/csl/abstract.h" bodystart="1636" bodyend="1639"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a96de5935a58a96d4c5b1e47966488923" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::operator!=</definition>
        <argsstring>(Expr_info expr) const</argsstring>
        <name>operator!=</name>
        <qualifiedname>csl::Abstract::operator!=</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1230" column="17" bodyfile="src/csl/abstract.h" bodystart="1641" bodyend="1644"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ac99a619abde7e4c58f39e14d4d20fcf5" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::operator!=</definition>
        <argsstring>(const Expr_c &amp;expr) const</argsstring>
        <name>operator!=</name>
        <qualifiedname>csl::Abstract::operator!=</qualifiedname>
        <param>
          <type>const <ref refid="classstd_1_1shared__ptr" kindref="compound">Expr_c</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Compares</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> with another. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> to compare. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>False if the two Abstracts are the same (or have the same name). </para>
</simplesect>
<simplesect kind="return"><para>True else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1236" column="17" bodyfile="src/csl/abstract.h" bodystart="1651" bodyend="1654"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a45206de7c7773b3cb150451ee3eb379e" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::operator!=</definition>
        <argsstring>(const Expr &amp;expr) const</argsstring>
        <name>operator!=</name>
        <qualifiedname>csl::Abstract::operator!=</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1237" column="17" bodyfile="src/csl/abstract.h" bodystart="1656" bodyend="1659"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a0d3495220202bd417c1b58249c923f39" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::operator!=</definition>
        <argsstring>(const Abstract &amp;other) const</argsstring>
        <name>operator!=</name>
        <qualifiedname>csl::Abstract::operator!=</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1238" column="17" bodyfile="src/csl/abstract.h" bodystart="1661" bodyend="1664"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1aa8331053065d1be2da89e70c45d24863" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
        <definition>Expr const  &amp; csl::Abstract::operator[]</definition>
        <argsstring>(int iArg) const</argsstring>
        <name>operator[]</name>
        <qualifiedname>csl::Abstract::operator[]</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1aaa1bbff7462d592af2ad699c02296107">operator[]</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1af3afc58a715c978290e4860101fb3c27">operator[]</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1a26979a899fab4621102645d0f8366457">operator[]</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1a303d252e82b4e28ec9df8a5a971acf52">operator[]</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1a2e9000986cc55b7016cc56513f058f69">operator[]</reimplementedby>
        <param>
          <type>int</type>
          <declname>iArg</declname>
        </param>
        <briefdescription>
<para>Access operator for multi-argument expressions, equivalent to the function <ref refid="classcsl_1_1Abstract_1ac33a42309d629d47bfdbede4e152414e" kindref="member">getArgument()</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iArg</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> of the argument to get. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>argument</bold>[iArg]. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1244" column="24" bodyfile="src/csl/abstract.cpp" bodystart="967" bodyend="972"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a560aa9993d506551c54a8c02d1445814" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
        <definition>Expr &amp; csl::Abstract::operator[]</definition>
        <argsstring>(int iArg)</argsstring>
        <name>operator[]</name>
        <qualifiedname>csl::Abstract::operator[]</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1a485adbc87cb3b4739eb468cfd09e7b31">operator[]</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractFunc_1ab6a82539b4c61521f13b39bf1b230e68">operator[]</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1ae4922013ae4c2b23e6fab8bc9056ab42">operator[]</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractVectorial_1afd91a1187f15759c61d5a9460f88d3dc">operator[]</reimplementedby>
        <reimplementedby refid="classcsl_1_1TDerivativeElement_1aa2934b8a3734feac07dec2abc1e14e5a">operator[]</reimplementedby>
        <param>
          <type>int</type>
          <declname>iArg</declname>
        </param>
        <briefdescription>
<para>Access operator for multi-argument expressions, returns a reference so this function is not const. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iArg</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> of the argument to get. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A reference to <bold>argument</bold>[iArg]. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1251" column="18" bodyfile="src/csl/abstract.cpp" bodystart="973" bodyend="978"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a5c1ba8dce7fbc19eb98807bd15a279c9" prot="public" static="no" const="yes" explicit="no" inline="no" virt="pure-virtual">
        <type>bool</type>
        <definition>virtual bool csl::Abstract::operator&lt;</definition>
        <argsstring>(Expr_info expr) const =0</argsstring>
        <name>operator&lt;</name>
        <qualifiedname>csl::Abstract::operator&lt;</qualifiedname>
        <reimplementedby refid="classcsl_1_1AbstractDuoFunc_1a2d20154a943a0a723791d0a6223382fa">operator&lt;</reimplementedby>
        <reimplementedby refid="classcsl_1_1AbstractMultiFunc_1ad4be44fbde5ebd97065a575992d498c2">operator&lt;</reimplementedby>
        <reimplementedby refid="classmty_1_1FeynmanIntegral_1a4fd80eac66e3bd46cff23cb5b3e8b52a">operator&lt;</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Compares the simplicity of the expression to another. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para><bold>Expression</bold> to compare. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>False</bold> if <bold>expr</bold> is simpler or equivalent. </para>
</simplesect>
<simplesect kind="return"><para><bold>True</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1263" column="13"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a6e19587260a07dba65cf2a985e05516b" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::operator&lt;</definition>
        <argsstring>(const Expr_c &amp;expr) const</argsstring>
        <name>operator&lt;</name>
        <qualifiedname>csl::Abstract::operator&lt;</qualifiedname>
        <param>
          <type>const <ref refid="classstd_1_1shared__ptr" kindref="compound">Expr_c</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Compares the simplicity of the expression to another. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para><bold>Expression</bold> to compare. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>False</bold> if <bold>expr</bold> is simpler or equivalent. </para>
</simplesect>
<simplesect kind="return"><para><bold>True</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1270" column="12" bodyfile="src/csl/abstract.h" bodystart="1270" bodyend="1273"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a485c6f3e10db539a70416cd0766b117d" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::operator&gt;</definition>
        <argsstring>(Expr_info expr) const</argsstring>
        <name>operator&gt;</name>
        <qualifiedname>csl::Abstract::operator&gt;</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Compares the simplicity of the expression to another. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para><bold>Expression</bold> to compare. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if <bold>expr</bold> is simpler. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1280" column="17" bodyfile="src/csl/abstract.h" bodystart="1280" bodyend="1283"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1ab305bdf49212f03781e7f98024faeb66" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::operator&gt;</definition>
        <argsstring>(const Expr_c &amp;expr) const</argsstring>
        <name>operator&gt;</name>
        <qualifiedname>csl::Abstract::operator&gt;</qualifiedname>
        <param>
          <type>const <ref refid="classstd_1_1shared__ptr" kindref="compound">Expr_c</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1285" column="17" bodyfile="src/csl/abstract.h" bodystart="1285" bodyend="1288"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a2a1660498f2638f5e490d6e512eb32f4" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::operator&lt;=</definition>
        <argsstring>(Expr_info expr) const</argsstring>
        <name>operator&lt;=</name>
        <qualifiedname>csl::Abstract::operator&lt;=</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1290" column="12" bodyfile="src/csl/abstract.h" bodystart="1290" bodyend="1293"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a4c8883df19d7538b68fa96aadac9dfa9" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::operator&gt;=</definition>
        <argsstring>(Expr_info expr) const</argsstring>
        <name>operator&gt;=</name>
        <qualifiedname>csl::Abstract::operator&gt;=</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Compares the simplicity of the expression to another. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para><bold>Expression</bold> to compare. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if <bold>expr</bold> is simpler or equivalent. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1300" column="17" bodyfile="src/csl/abstract.h" bodystart="1300" bodyend="1303"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1afbcac6df2fd7ac11f336189cf215124b" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::operator&lt;=</definition>
        <argsstring>(const Expr_c &amp;expr) const</argsstring>
        <name>operator&lt;=</name>
        <qualifiedname>csl::Abstract::operator&lt;=</qualifiedname>
        <param>
          <type>const <ref refid="classstd_1_1shared__ptr" kindref="compound">Expr_c</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Compares the simplicity of the expression to another. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para><bold>Expression</bold> to compare. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>False</bold> if <bold>expr</bold> is simpler. </para>
</simplesect>
<simplesect kind="return"><para><bold>True</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1310" column="12" bodyfile="src/csl/abstract.h" bodystart="1310" bodyend="1313"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a6b931f7b159d57bad26ca9c9ea729aa1" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::Abstract::operator&gt;=</definition>
        <argsstring>(const Expr_c &amp;expr) const</argsstring>
        <name>operator&gt;=</name>
        <qualifiedname>csl::Abstract::operator&gt;=</qualifiedname>
        <param>
          <type>const <ref refid="classstd_1_1shared__ptr" kindref="compound">Expr_c</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1315" column="17" bodyfile="src/csl/abstract.h" bodystart="1315" bodyend="1318"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classcsl_1_1Abstract_1aba5ef083016b2f3d9e6271f864b9b063" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string csl::Abstract::regularName</definition>
        <argsstring>(std::string const &amp;name)</argsstring>
        <name>regularName</name>
        <qualifiedname>csl::Abstract::regularName</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>name</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="114" column="24" bodyfile="src/csl/abstract.cpp" bodystart="92" bodyend="95"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a1a8421d402d5ba82257188b545e8d668" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string csl::Abstract::regularName</definition>
        <argsstring>(std::string_view name)</argsstring>
        <name>regularName</name>
        <qualifiedname>csl::Abstract::regularName</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="115" column="24" bodyfile="src/csl/abstract.cpp" bodystart="97" bodyend="123"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a8aab87c41acafaf1b1837b922495560d" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string csl::Abstract::regularLiteral</definition>
        <argsstring>(std::string const &amp;name)</argsstring>
        <name>regularLiteral</name>
        <qualifiedname>csl::Abstract::regularLiteral</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>name</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="116" column="24" bodyfile="src/csl/abstract.cpp" bodystart="125" bodyend="128"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1Abstract_1a2fe749450d2e610199801b189dc3d0f8" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string csl::Abstract::regularLiteral</definition>
        <argsstring>(std::string_view name)</argsstring>
        <name>regularLiteral</name>
        <qualifiedname>csl::Abstract::regularLiteral</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="117" column="24" bodyfile="src/csl/abstract.cpp" bodystart="130" bodyend="139"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para><bold>Root</bold> class of the inheritance tree of abstracts. </para>
    </briefdescription>
    <detaileddescription>
<para>Contains all functions that derived class needs. In particular all documented functions of the class <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> are <bold>specialized</bold> in all the <bold>derived</bold> <bold>classes</bold>. <simplesect kind="note"><para>Some functions are not documented here because not every derived class use them. </para>
</simplesect>
</para>
    </detaileddescription>
    <inheritancegraph>
      <node id="40">
        <label>csl::ACos</label>
        <link refid="classcsl_1_1ACos"/>
        <childnode refid="31" relation="public-inheritance">
        </childnode>
      </node>
      <node id="41">
        <label>csl::ACosh</label>
        <link refid="classcsl_1_1ACosh"/>
        <childnode refid="31" relation="public-inheritance">
        </childnode>
      </node>
      <node id="42">
        <label>csl::ASin</label>
        <link refid="classcsl_1_1ASin"/>
        <childnode refid="31" relation="public-inheritance">
        </childnode>
      </node>
      <node id="43">
        <label>csl::ASinh</label>
        <link refid="classcsl_1_1ASinh"/>
        <childnode refid="31" relation="public-inheritance">
        </childnode>
      </node>
      <node id="44">
        <label>csl::ATan</label>
        <link refid="classcsl_1_1ATan"/>
        <childnode refid="31" relation="public-inheritance">
        </childnode>
      </node>
      <node id="45">
        <label>csl::ATanh</label>
        <link refid="classcsl_1_1ATanh"/>
        <childnode refid="31" relation="public-inheritance">
        </childnode>
      </node>
      <node id="46">
        <label>csl::Abs</label>
        <link refid="classcsl_1_1Abs"/>
        <childnode refid="31" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1">
        <label>csl::Abstract</label>
        <link refid="classcsl_1_1Abstract"/>
      </node>
      <node id="2">
        <label>csl::AbstractBuildingBlock</label>
        <link refid="classcsl_1_1AbstractBuildingBlock"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="23">
        <label>csl::AbstractDuoFunc</label>
        <link refid="classcsl_1_1AbstractDuoFunc"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="9">
        <label>csl::AbstractElement</label>
        <link refid="classcsl_1_1AbstractElement"/>
        <childnode refid="8" relation="public-inheritance">
        </childnode>
      </node>
      <node id="31">
        <label>csl::AbstractFunc</label>
        <link refid="classcsl_1_1AbstractFunc"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="33">
        <label>csl::AbstractIntegral</label>
        <link refid="classcsl_1_1AbstractIntegral"/>
        <childnode refid="32" relation="public-inheritance">
        </childnode>
      </node>
      <node id="17">
        <label>csl::AbstractLiteral</label>
        <link refid="classcsl_1_1AbstractLiteral"/>
        <childnode refid="8" relation="public-inheritance">
        </childnode>
      </node>
      <node id="57">
        <label>csl::AbstractMultiFunc</label>
        <link refid="classcsl_1_1AbstractMultiFunc"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="3">
        <label>csl::AbstractNumerical</label>
        <link refid="classcsl_1_1AbstractNumerical"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="66">
        <label>csl::AbstractVectorial</label>
        <link refid="classcsl_1_1AbstractVectorial"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="27">
        <label>csl::Angle</label>
        <link refid="classcsl_1_1Angle"/>
        <childnode refid="23" relation="public-inheritance">
        </childnode>
      </node>
      <node id="18">
        <label>csl::Arbitrary</label>
        <link refid="classcsl_1_1Arbitrary"/>
        <childnode refid="17" relation="public-inheritance">
        </childnode>
      </node>
      <node id="58">
        <label>csl::BooleanOperator</label>
        <link refid="classcsl_1_1BooleanOperator"/>
        <childnode refid="57" relation="public-inheritance">
        </childnode>
      </node>
      <node id="28">
        <label>csl::Commutator</label>
        <link refid="classcsl_1_1Commutator"/>
        <childnode refid="23" relation="public-inheritance">
        </childnode>
      </node>
      <node id="4">
        <label>csl::Complex</label>
        <link refid="classcsl_1_1Complex"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
      <node id="8">
        <label>csl::Complexified</label>
        <link refid="classcsl_1_1Complexified"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="19">
        <label>csl::Constant</label>
        <link refid="classcsl_1_1Constant"/>
        <childnode refid="17" relation="public-inheritance">
        </childnode>
      </node>
      <node id="47">
        <label>csl::Cos</label>
        <link refid="classcsl_1_1Cos"/>
        <childnode refid="31" relation="public-inheritance">
        </childnode>
      </node>
      <node id="48">
        <label>csl::Cosh</label>
        <link refid="classcsl_1_1Cosh"/>
        <childnode refid="31" relation="public-inheritance">
        </childnode>
      </node>
      <node id="25">
        <label>csl::Derivative</label>
        <link refid="classcsl_1_1Derivative"/>
        <childnode refid="24" relation="public-inheritance">
        </childnode>
      </node>
      <node id="49">
        <label>csl::DiracDelta</label>
        <link refid="classcsl_1_1DiracDelta"/>
        <childnode refid="31" relation="public-inheritance">
        </childnode>
      </node>
      <node id="50">
        <label>csl::Exp</label>
        <link refid="classcsl_1_1Exp"/>
        <childnode refid="31" relation="public-inheritance">
        </childnode>
      </node>
      <node id="51">
        <label>csl::Factorial</label>
        <link refid="classcsl_1_1Factorial"/>
        <childnode refid="31" relation="public-inheritance">
        </childnode>
      </node>
      <node id="5">
        <label>csl::Float</label>
        <link refid="classcsl_1_1Float"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
      <node id="67">
        <label>csl::HighDTensor</label>
        <link refid="classcsl_1_1HighDTensor"/>
        <childnode refid="66" relation="public-inheritance">
        </childnode>
      </node>
      <node id="61">
        <label>csl::IProd</label>
        <link refid="classcsl_1_1IProd"/>
        <childnode refid="60" relation="public-inheritance">
        </childnode>
      </node>
      <node id="63">
        <label>csl::ISum</label>
        <link refid="classcsl_1_1ISum"/>
        <childnode refid="62" relation="public-inheritance">
        </childnode>
      </node>
      <node id="20">
        <label>csl::Imaginary</label>
        <link refid="classcsl_1_1Imaginary"/>
        <childnode refid="17" relation="public-inheritance">
        </childnode>
      </node>
      <node id="36">
        <label>csl::ImaginaryPart</label>
        <link refid="classcsl_1_1ImaginaryPart"/>
        <childnode refid="32" relation="public-inheritance">
        </childnode>
      </node>
      <node id="21">
        <label>csl::IntFactorial</label>
        <link refid="classcsl_1_1IntFactorial"/>
        <childnode refid="17" relation="public-inheritance">
        </childnode>
      </node>
      <node id="6">
        <label>csl::IntFraction</label>
        <link refid="classcsl_1_1IntFraction"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
      <node id="7">
        <label>csl::Integer</label>
        <link refid="classcsl_1_1Integer"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
      <node id="26">
        <label>csl::Integral</label>
        <link refid="classcsl_1_1Integral"/>
        <childnode refid="24" relation="public-inheritance">
        </childnode>
      </node>
      <node id="52">
        <label>csl::Log</label>
        <link refid="classcsl_1_1Log"/>
        <childnode refid="31" relation="public-inheritance">
        </childnode>
      </node>
      <node id="68">
        <label>csl::Matrix</label>
        <link refid="classcsl_1_1Matrix"/>
        <childnode refid="66" relation="public-inheritance">
        </childnode>
      </node>
      <node id="24">
        <label>csl::Operator&lt; AbstractDuoFunc &gt;</label>
        <link refid="classcsl_1_1Operator"/>
        <childnode refid="23" relation="public-inheritance">
        </childnode>
      </node>
      <node id="32">
        <label>csl::Operator&lt; AbstractFunc &gt;</label>
        <link refid="classcsl_1_1Operator"/>
        <childnode refid="31" relation="public-inheritance">
        </childnode>
      </node>
      <node id="12">
        <label>csl::Operator&lt; TensorFieldElement &gt;</label>
        <link refid="classcsl_1_1Operator"/>
        <childnode refid="11" relation="public-inheritance">
        </childnode>
      </node>
      <node id="38">
        <label>csl::Operator&lt; csl::AbstractFunc &gt;</label>
        <link refid="classcsl_1_1Operator"/>
        <childnode refid="31" relation="public-inheritance">
        </childnode>
      </node>
      <node id="59">
        <label>csl::Polynomial</label>
        <link refid="classcsl_1_1Polynomial"/>
        <childnode refid="57" relation="public-inheritance">
        </childnode>
      </node>
      <node id="29">
        <label>csl::Pow</label>
        <link refid="classcsl_1_1Pow"/>
        <childnode refid="23" relation="public-inheritance">
        </childnode>
      </node>
      <node id="60">
        <label>csl::Prod</label>
        <link refid="classcsl_1_1Prod"/>
        <childnode refid="57" relation="public-inheritance">
        </childnode>
      </node>
      <node id="37">
        <label>csl::RealPart</label>
        <link refid="classcsl_1_1RealPart"/>
        <childnode refid="32" relation="public-inheritance">
        </childnode>
      </node>
      <node id="34">
        <label>csl::ScalarIntegral</label>
        <link refid="classcsl_1_1ScalarIntegral"/>
        <childnode refid="33" relation="public-inheritance">
        </childnode>
      </node>
      <node id="53">
        <label>csl::Sin</label>
        <link refid="classcsl_1_1Sin"/>
        <childnode refid="31" relation="public-inheritance">
        </childnode>
      </node>
      <node id="54">
        <label>csl::Sinh</label>
        <link refid="classcsl_1_1Sinh"/>
        <childnode refid="31" relation="public-inheritance">
        </childnode>
      </node>
      <node id="62">
        <label>csl::Sum</label>
        <link refid="classcsl_1_1Sum"/>
        <childnode refid="57" relation="public-inheritance">
        </childnode>
      </node>
      <node id="13">
        <label>csl::TDerivativeElement</label>
        <link refid="classcsl_1_1TDerivativeElement"/>
        <childnode refid="12" relation="public-inheritance">
        </childnode>
      </node>
      <node id="55">
        <label>csl::Tan</label>
        <link refid="classcsl_1_1Tan"/>
        <childnode refid="31" relation="public-inheritance">
        </childnode>
      </node>
      <node id="56">
        <label>csl::Tanh</label>
        <link refid="classcsl_1_1Tanh"/>
        <childnode refid="31" relation="public-inheritance">
        </childnode>
      </node>
      <node id="10">
        <label>csl::TensorElement</label>
        <link refid="classcsl_1_1TensorElement"/>
        <childnode refid="9" relation="public-inheritance">
        </childnode>
      </node>
      <node id="11">
        <label>csl::TensorFieldElement</label>
        <link refid="classcsl_1_1TensorFieldElement"/>
        <childnode refid="10" relation="public-inheritance">
        </childnode>
      </node>
      <node id="22">
        <label>csl::Variable</label>
        <link refid="classcsl_1_1Variable"/>
        <childnode refid="17" relation="public-inheritance">
        </childnode>
      </node>
      <node id="69">
        <label>csl::Vector</label>
        <link refid="classcsl_1_1Vector"/>
        <childnode refid="66" relation="public-inheritance">
        </childnode>
      </node>
      <node id="35">
        <label>csl::VectorIntegral</label>
        <link refid="classcsl_1_1VectorIntegral"/>
        <childnode refid="33" relation="public-inheritance">
        </childnode>
      </node>
      <node id="30">
        <label>mty::FermionPropStruct</label>
        <link refid="classmty_1_1FermionPropStruct"/>
        <childnode refid="23" relation="public-inheritance">
        </childnode>
      </node>
      <node id="64">
        <label>mty::FeynmanIntegral</label>
        <link refid="classmty_1_1FeynmanIntegral"/>
        <childnode refid="57" relation="public-inheritance">
        </childnode>
      </node>
      <node id="16">
        <label>mty::GeneratorElement</label>
        <link refid="classmty_1_1GeneratorElement"/>
        <childnode refid="10" relation="public-inheritance">
        </childnode>
      </node>
      <node id="15">
        <label>mty::PolarizationField</label>
        <link refid="classmty_1_1PolarizationField"/>
        <childnode refid="14" relation="public-inheritance">
        </childnode>
      </node>
      <node id="65">
        <label>mty::Propagator</label>
        <link refid="classmty_1_1Propagator"/>
        <childnode refid="57" relation="public-inheritance">
        </childnode>
      </node>
      <node id="14">
        <label>mty::QuantumField</label>
        <link refid="classmty_1_1QuantumField"/>
        <childnode refid="11" relation="public-inheritance">
        </childnode>
      </node>
      <node id="39">
        <label>mty::Wick</label>
        <link refid="classmty_1_1Wick"/>
        <childnode refid="38" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <location file="src/csl/abstract.h" line="75" column="1" bodyfile="src/csl/abstract.h" bodystart="75" bodyend="1319"/>
    <listofallmembers>
      <member refid="classcsl_1_1Abstract_1ad5fee68c1f3dcbda0e936926fed17616" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>Abstract</name></member>
      <member refid="classcsl_1_1Abstract_1a5549ac0c186b3c6febf332245a25a82c" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>addAntiSymmetry</name></member>
      <member refid="classcsl_1_1Abstract_1abbab11282e5c6ac46b018642ff129f47" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>addDependency</name></member>
      <member refid="classcsl_1_1Abstract_1a101219973341a39cf15f07e5e1aa388f" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>addition_own</name></member>
      <member refid="classcsl_1_1Abstract_1ad431770faa4291116a50175193a11a88" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>addSymmetry</name></member>
      <member refid="classcsl_1_1Abstract_1acd972aed8326d4c13534594e061ee6da" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>antisymmetrise</name></member>
      <member refid="classcsl_1_1Abstract_1a61d3ab932182226f4670a62bbb22af4e" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>applyDiracDelta</name></member>
      <member refid="classcsl_1_1Abstract_1a316956fea77627a716500a2bbfc1f3b7" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>applyOperator</name></member>
      <member refid="classcsl_1_1Abstract_1a6305ce90c795bfb416d8e958c62f905c" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>applySelfStructureOn</name></member>
      <member refid="classcsl_1_1Abstract_1a27ad666bf7d533607da9675b0c645ee9" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>askTerm</name></member>
      <member refid="classcsl_1_1Abstract_1aad54ed41b2ce9bad3364fe30ad1a0d71" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>begin</name></member>
      <member refid="classcsl_1_1Abstract_1adff373df9477d4e38581d09cc6d2fee4" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>begin</name></member>
      <member refid="classcsl_1_1Abstract_1aa4cba37520821432f37e212fefbc2534" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>breakSpace</name></member>
      <member refid="classcsl_1_1Abstract_1af0f40b77914e45f56bf87839d00211d7" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>breakSpace</name></member>
      <member refid="classcsl_1_1Abstract_1afd9d0336808e8adf4ccdccb51587ed8c" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>checkIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1a1ebd84082bb93418408cc0babe2dffe2" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>checkIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1ab3746f1d3667846824ea51b8a2e00d31" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>collect</name></member>
      <member refid="classcsl_1_1Abstract_1a3f68d0cd93dfe2ac02d6d4afc80fb41a" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>commutesWith</name></member>
      <member refid="classcsl_1_1Abstract_1a7caee12abb451168149779a668dfc59e" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>compareWithDummy</name></member>
      <member refid="classcsl_1_1Abstract_1a0f16fda9fe72a89c61ece36101a11d95" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>compareWithDummy</name></member>
      <member refid="classcsl_1_1Abstract_1aed79d20a0821205e6430c80a474117d3" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>contractIndex</name></member>
      <member refid="classcsl_1_1Abstract_1ad874fc858295a737e6ce884530f1109b" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>contraction</name></member>
      <member refid="classcsl_1_1Abstract_1abd35096982e92b669ea55d960c5f44be" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>contraction</name></member>
      <member refid="classcsl_1_1Abstract_1af29c2898c5d3ba96de8018a0838c402c" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>copy</name></member>
      <member refid="classcsl_1_1Abstract_1aaa996819710adc3b7529c74a628be623" prot="public" virt="pure-virtual"><scope>csl::Abstract</scope><name>copy_unique</name></member>
      <member refid="classcsl_1_1Abstract_1a09648782dcf2e81abb5b864f476cc410" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>deepCopy</name></member>
      <member refid="classcsl_1_1Abstract_1a10358c33402ed520dc5888b25bb26af3" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>deepRefresh</name></member>
      <member refid="classcsl_1_1Abstract_1ac3c9887977249e4d71ea36c6377b3581" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>dependsExplicitlyOn</name></member>
      <member refid="classcsl_1_1Abstract_1a0b26ad7a44e497af296318287bac539a" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>dependsExplicitlyOn</name></member>
      <member refid="classcsl_1_1Abstract_1a40fe2ccf376dadd21b2d7a0f134d86c6" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>dependsOn</name></member>
      <member refid="classcsl_1_1Abstract_1a9d7d8586a0df66ba8da33528d6400e66" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>dependsOn</name></member>
      <member refid="classcsl_1_1Abstract_1aecab8c872023a2d0771e7e4f83bb05f8" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>derive</name></member>
      <member refid="classcsl_1_1Abstract_1aeb08811cf370616477a92075e4a218ee" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>determinant</name></member>
      <member refid="classcsl_1_1Abstract_1a1578c74aee1050b806a67e7a81a67f5c" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>division_own</name></member>
      <member refid="classcsl_1_1Abstract_1a4cc7a46deaa3eaa7593909d74e76d4af" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>dot</name></member>
      <member refid="classcsl_1_1Abstract_1a0c3c3fe5010f24e8a8765ea06415c003" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>empty</name></member>
      <member refid="classcsl_1_1Abstract_1a61e4e80d998a888a1a74d9ea3e10c0f1" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>end</name></member>
      <member refid="classcsl_1_1Abstract_1ae2761d54f13310e13f5076d565edd7ef" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>end</name></member>
      <member refid="classcsl_1_1Abstract_1aa3a4cb7f30e2a422fe27a513e03d6600" prot="public" virt="pure-virtual"><scope>csl::Abstract</scope><name>evaluate</name></member>
      <member refid="classcsl_1_1Abstract_1a543d5a4f0432e166b492ad28a860a65f" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>evaluateScalar</name></member>
      <member refid="classcsl_1_1Abstract_1a3a87ab082152fea4fc2444659028b840" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>expand</name></member>
      <member refid="classcsl_1_1Abstract_1aeb48aaaa856582b6359037fe94d2419b" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>expand_if</name></member>
      <member refid="classcsl_1_1Abstract_1aa2696a0feb43766ef54e1e3dd3d6d134" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>exponentiation_own</name></member>
      <member refid="classcsl_1_1Abstract_1a0bc0de9c4ce5f77fc716af0f502d13d3" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>factor</name></member>
      <member refid="classcsl_1_1Abstract_1a8fb3d657c65606d520688db6401fe650" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>factor</name></member>
      <member refid="classcsl_1_1Abstract_1a299b1fd6c2b9d80ad90a08c7acef28d2" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>findSubExpression</name></member>
      <member refid="classcsl_1_1Abstract_1a021946e84d8c1a019908cac578b16fe8" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getAllDependencies</name></member>
      <member refid="classcsl_1_1Abstract_1ac33a42309d629d47bfdbede4e152414e" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a06f542034e95744148f4fce5a4893e63" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a898d6cf2a7f348feacab189447bee1eb" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getArgument</name></member>
      <member refid="classcsl_1_1Abstract_1aa689fb64eecb86edbde6c745d1ce756b" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getArgument</name></member>
      <member refid="classcsl_1_1Abstract_1afeb26e1382411448ce3c65d50fefd8bb" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getCanonicalPermutation</name></member>
      <member refid="classcsl_1_1Abstract_1a2263731ca94825f35281e69fb258cf87" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getCommutable</name></member>
      <member refid="classcsl_1_1Abstract_1a9cc64c66894acafc1f069dc40072084b" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getComplexArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a03e8bdba20c6192a948892f212f09dbe" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getComplexConjugate</name></member>
      <member refid="classcsl_1_1Abstract_1a859f792aec52ba1fe1181f81d1cc3451" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getComplexModulus</name></member>
      <member refid="classcsl_1_1Abstract_1a470d9f1267fba4a82e13af4a39470f81" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getComplexProperty</name></member>
      <member refid="classcsl_1_1Abstract_1af04c0e4426f0bf9df365afe0148d59df" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getContractedPair</name></member>
      <member refid="classcsl_1_1Abstract_1aec707d949f0f98e08ab4642c93dd9eb5" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getContractionProperties</name></member>
      <member refid="classcsl_1_1Abstract_1aa22f0e4c9c91f43b5cd61cbb873869eb" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getDeltaMinus</name></member>
      <member refid="classcsl_1_1Abstract_1a69a657baf1c35ed581e9db2c47a71c99" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getDeltaPlus</name></member>
      <member refid="classcsl_1_1Abstract_1a9531d78d67c82e288c0130da5b1ba80b" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getDenom</name></member>
      <member refid="classcsl_1_1Abstract_1a5856c3d55a6d1406970f3656e61efe8e" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getDim</name></member>
      <member refid="classcsl_1_1Abstract_1a77e067fc57c0c2e70d141079455fdbd7" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getElementary</name></member>
      <member refid="classcsl_1_1Abstract_1ac513c930caa9939c2b9557f36a34ee69" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getExponents</name></member>
      <member refid="classcsl_1_1Abstract_1ac34c9c6f05e692faeed2f030514787ad" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getFactors</name></member>
      <member refid="classcsl_1_1Abstract_1aa4136dc23f1fba4bf897b54c8592ccfc" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getFreeIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1aa5b707a5efdaef7c7945cbd921c3f526" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getHermitianConjugate</name></member>
      <member refid="classcsl_1_1Abstract_1aff5cca2b2c8190e59f6e34cb1e383d36" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getHermitianConjugate</name></member>
      <member refid="classcsl_1_1Abstract_1a43f44bbb3685fc9f4a0402223b2e1004" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getImaginaryPart</name></member>
      <member refid="classcsl_1_1Abstract_1a3234ce243f6a2e11950be42f10100943" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getIndex</name></member>
      <member refid="classcsl_1_1Abstract_1ae125a32b6f3d0368b6055d4e58c1ff3f" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1ae6a9a9ef3efd6bb83b62c0a353742d25" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>getIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1addb848bf4cdea207484a71e9b1006ead" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getIndexStructureView</name></member>
      <member refid="classcsl_1_1Abstract_1a632e28530a68539fadacd7ab7ffc8be1" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getIndexStructureView</name></member>
      <member refid="classcsl_1_1Abstract_1a3d6b1e294cf24dea17c3c4361226138b" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getInfBoundary</name></member>
      <member refid="classcsl_1_1Abstract_1a9c4a302d1a3cbf4dd9394f5e5880d343" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getLatexName</name></member>
      <member refid="classcsl_1_1Abstract_1a652101e34b2efa43114150e9af3c79d5" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getLibDependency</name></member>
      <member refid="classcsl_1_1Abstract_1af7f5e7466e754984a2c4394a112464f7" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getName</name></member>
      <member refid="classcsl_1_1Abstract_1aa034448201c9e7998bbbb5e409636b30" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getNArgs</name></member>
      <member refid="classcsl_1_1Abstract_1a42125e9765a771c47819548d342b0b28" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getNContractedPairs</name></member>
      <member refid="classcsl_1_1Abstract_1a204dbd37b63432cb08932b995f49d3f4" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getNFactor</name></member>
      <member refid="classcsl_1_1Abstract_1add364193f7a78ac28f7001c7f4036453" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getNIndices</name></member>
      <member refid="classcsl_1_1Abstract_1a6aa6bcc7cb8ee1574f29dc6ab6c6f0ed" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getNum</name></member>
      <member refid="classcsl_1_1Abstract_1aad25c117c8dfc4d9718ba41e8d3f33a6" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getNumericalFactor</name></member>
      <member refid="classcsl_1_1Abstract_1a9c3ec3dfe1fbd8ead5c8d9aca421a863" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getOperand</name></member>
      <member refid="classcsl_1_1Abstract_1a9500a21d75d03c695ec0c76493600b38" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getOrder</name></member>
      <member refid="classcsl_1_1Abstract_1ae89eb7b1a9e0259a60154563f3315907" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getOrderOf</name></member>
      <member refid="classcsl_1_1Abstract_1ab150130c9f67daaf6aba52b9f6b90941" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getParent</name></member>
      <member refid="classcsl_1_1Abstract_1a15f775b5add9af8727ead2cfaab78ba2" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getParent_info</name></member>
      <member refid="classcsl_1_1Abstract_1aea8459b3206eb3a2297eeea7688e9520" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getParity</name></member>
      <member refid="classcsl_1_1Abstract_1a946d175d946da102c5f4cc91840703cb" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getPermutations</name></member>
      <member refid="classcsl_1_1Abstract_1a06b32036fea6a2583f506a6ef9508d74" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getPoint</name></member>
      <member refid="classcsl_1_1Abstract_1ade540a127da7304f2b7282f4dcaffc7f" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getPolynomialTerm</name></member>
      <member refid="classcsl_1_1Abstract_1a8ab79682cdff4c7d7b52c2e70ac23d85" prot="public" virt="pure-virtual"><scope>csl::Abstract</scope><name>getPrimaryType</name></member>
      <member refid="classcsl_1_1Abstract_1a07489d0569bc983718796d21c73f34b3" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getProduct</name></member>
      <member refid="classcsl_1_1Abstract_1a415f64fdddaae445014d5e052956f889" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getRealPart</name></member>
      <member refid="classcsl_1_1Abstract_1a5b77f008f4b95030641224877004f06c" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getRegularExpression</name></member>
      <member refid="classcsl_1_1Abstract_1a625efe55a17b97a1c0f085bdbf3a962a" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getShape</name></member>
      <member refid="classcsl_1_1Abstract_1aa83df1d9dc202457113e5b38bd694fae" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getSign</name></member>
      <member refid="classcsl_1_1Abstract_1a4e69280b624b0e0c932f1cfa7417b55f" prot="public" virt="pure-virtual"><scope>csl::Abstract</scope><name>getSubSymbols</name></member>
      <member refid="classcsl_1_1Abstract_1a7dcdc11b64c8c515933882168d0792ef" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1a413c50b2663f57d38c1d3ec3cfeaa3ce" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1a26a0854bca4c47e84a1da36a3de8c49f" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1a29261a946b3398b6129237620754a8b9" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1a8a067b70756c4eef758aa88076a95162" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1aeaf8154e39ff211b12e6382e675ccaad" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getSum</name></member>
      <member refid="classcsl_1_1Abstract_1a2fcc223dbf5d880e923c07df142df5c8" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getSupBoundary</name></member>
      <member refid="classcsl_1_1Abstract_1a1d36e7a5acc50766d5cd3f6d59df978d" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getTerm</name></member>
      <member refid="classcsl_1_1Abstract_1a404c5e89a3aad8a8dabcb56d4120c0fe" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getTransposed</name></member>
      <member refid="classcsl_1_1Abstract_1aca3debb143668fd3ab75a27a47dd0c13" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getTransposed</name></member>
      <member refid="classcsl_1_1Abstract_1aa781456c3f801b37ce169c83514c51c1" prot="public" virt="pure-virtual"><scope>csl::Abstract</scope><name>getType</name></member>
      <member refid="classcsl_1_1Abstract_1a78f98ba06476e464e3fd2fce0d1f8243" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getValue</name></member>
      <member refid="classcsl_1_1Abstract_1a628563238145f3a9acc331f1a89ce32f" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getValued</name></member>
      <member refid="classcsl_1_1Abstract_1ae85f810bbadbc792210c958e8f1b2ffb" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getVariable</name></member>
      <member refid="classcsl_1_1Abstract_1ac83c44ae1e5315a38083bdb7acd8f3fa" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getVectorArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a0188b049736016c970a2513ed9f6931f" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>getVectorialModulus</name></member>
      <member refid="classcsl_1_1Abstract_1a94bf1455397fdd2df8dbbc3b41c2f3f4" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>hasChainContractionProperty</name></member>
      <member refid="classcsl_1_1Abstract_1aa31e08c251d96b8ea8ec8d385895c1ff" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>hasContractionProperty</name></member>
      <member refid="classcsl_1_1Abstract_1a8c42723e8bc6334c99f00898cc1d59d7" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>hermitian</name></member>
      <member refid="classcsl_1_1Abstract_1a5437e7f685edf8549e6d3b34572343f8" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>insert</name></member>
      <member refid="classcsl_1_1Abstract_1a1b68943aa7ecf60a63af0f2f368eef8f" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>inverseMatrix</name></member>
      <member refid="classcsl_1_1Abstract_1a9347e75b0cd0b75e0f0a38db93b29d83" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>isAnOperator</name></member>
      <member refid="classcsl_1_1Abstract_1ac09992d147b39388c8936b3bff648930" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>isArbitrary</name></member>
      <member refid="classcsl_1_1Abstract_1ad74c068f1da78856321932b6b6ae17dc" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>isBuildingBlock</name></member>
      <member refid="classcsl_1_1Abstract_1a22a594845a29429c9b4f19c92bd18cad" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>isComplexConjugate</name></member>
      <member refid="classcsl_1_1Abstract_1a464f4f0613db9b4b0a4efe26a3a03d60" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>isEmpty</name></member>
      <member refid="classcsl_1_1Abstract_1af2ce38838e35c5785f92373a1d830668" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>isHermitianConjugate</name></member>
      <member refid="classcsl_1_1Abstract_1a216b7bd3930fbf047e5bf8f69e9b964c" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>isIndexed</name></member>
      <member refid="classcsl_1_1Abstract_1a9a014bfd266b5f8471f23580e271979b" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>isInteger</name></member>
      <member refid="classcsl_1_1Abstract_1acae10d5685ccec295fbd9be7996073cb" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>isPolynomial</name></member>
      <member refid="classcsl_1_1Abstract_1acb67e8e96735b8f116d0e7ab33d7be77" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>isPurelyImaginary</name></member>
      <member refid="classcsl_1_1Abstract_1ac73aba0c48a4b5740f7bfa09e438ca99" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>isReal</name></member>
      <member refid="classcsl_1_1Abstract_1ab79c1d8df9e6b1a3eca66958f7dc489d" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>matchShape</name></member>
      <member refid="classcsl_1_1Abstract_1ac3978c71035bf1cda50f5b9031d631af" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>memoryOverhead</name></member>
      <member refid="classcsl_1_1Abstract_1a4f5ed458ba62f5b4cf61a9e1f8568af1" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>multiplication_own</name></member>
      <member refid="classcsl_1_1Abstract_1af5b62a6308638064c42da80e9cc2cb7e" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1af4fd1b57df371dac7ccfd5a909620e49" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1a96de5935a58a96d4c5b1e47966488923" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1ac99a619abde7e4c58f39e14d4d20fcf5" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1a45206de7c7773b3cb150451ee3eb379e" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1a0d3495220202bd417c1b58249c923f39" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1a5c1ba8dce7fbc19eb98807bd15a279c9" prot="public" virt="pure-virtual"><scope>csl::Abstract</scope><name>operator&lt;</name></member>
      <member refid="classcsl_1_1Abstract_1a6e19587260a07dba65cf2a985e05516b" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>operator&lt;</name></member>
      <member refid="classcsl_1_1Abstract_1a2a1660498f2638f5e490d6e512eb32f4" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>operator&lt;=</name></member>
      <member refid="classcsl_1_1Abstract_1afbcac6df2fd7ac11f336189cf215124b" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>operator&lt;=</name></member>
      <member refid="classcsl_1_1Abstract_1a59ff2950fc8ca319f87a730450f14545" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>operator=</name></member>
      <member refid="classcsl_1_1Abstract_1a8334e14cd5789168b037d3888ed60edd" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a12d929e34039e817e464abc560bd4a9d" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a3775f3088e784cc924cb7d26e118660e" prot="public" virt="pure-virtual"><scope>csl::Abstract</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a1f78f0cce24c93def3050743bc5f2845" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1aed43debcac4a19e0da44986774c522bc" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a2376f08c0aa5ffe783090381d102d3ae" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a485c6f3e10db539a70416cd0766b117d" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>operator&gt;</name></member>
      <member refid="classcsl_1_1Abstract_1ab305bdf49212f03781e7f98024faeb66" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>operator&gt;</name></member>
      <member refid="classcsl_1_1Abstract_1a4c8883df19d7538b68fa96aadac9dfa9" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>operator&gt;=</name></member>
      <member refid="classcsl_1_1Abstract_1a6b931f7b159d57bad26ca9c9ea729aa1" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>operator&gt;=</name></member>
      <member refid="classcsl_1_1Abstract_1aa8331053065d1be2da89e70c45d24863" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>operator[]</name></member>
      <member refid="classcsl_1_1Abstract_1a560aa9993d506551c54a8c02d1445814" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>operator[]</name></member>
      <member refid="classcsl_1_1Abstract_1a75d9abfa88d9d09a89d3a4becd9e6429" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>operatorAppliesOn</name></member>
      <member refid="classcsl_1_1Abstract_1abe9aceabbc0a99642e84c9025dbdc767" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>permut</name></member>
      <member refid="classcsl_1_1Abstract_1aed56cb85894209a9bbc9b8bdada5e6ab" prot="public" virt="pure-virtual"><scope>csl::Abstract</scope><name>print</name></member>
      <member refid="classcsl_1_1Abstract_1a2910dd30d90915c11d48c01cab618dda" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>printCode</name></member>
      <member refid="classcsl_1_1Abstract_1a89e45ffc7b65f92e77e592f76f70934c" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>printExplicit</name></member>
      <member refid="classcsl_1_1Abstract_1aa067d4a97135bfe2052a7e21c28f75be" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>printLaTeX</name></member>
      <member refid="classcsl_1_1Abstract_1a0645745feacf93470963b55f93cae1c0" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>printProp</name></member>
      <member refid="classcsl_1_1Abstract_1aaeab3809e91989adbdf29c3f56d905b6" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>refresh</name></member>
      <member refid="classcsl_1_1Abstract_1a8aab87c41acafaf1b1837b922495560d" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>regularLiteral</name></member>
      <member refid="classcsl_1_1Abstract_1a2fe749450d2e610199801b189dc3d0f8" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>regularLiteral</name></member>
      <member refid="classcsl_1_1Abstract_1aba5ef083016b2f3d9e6271f864b9b063" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>regularName</name></member>
      <member refid="classcsl_1_1Abstract_1a1a8421d402d5ba82257188b545e8d668" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>regularName</name></member>
      <member refid="classcsl_1_1Abstract_1a0e778c682b6cb02642b90e8ec8765441" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>removeDependency</name></member>
      <member refid="classcsl_1_1Abstract_1acc0eb077e25c9a67d15269cf8d5f0511" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>replaceIndex</name></member>
      <member refid="classcsl_1_1Abstract_1a9372ddd521fa661c5d3371e0d8d4dfc3" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>replaceIndexInPlace</name></member>
      <member refid="classcsl_1_1Abstract_1ac9e54a236015d14af42b0bcde41953f3" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>replaceIndices</name></member>
      <member refid="classcsl_1_1Abstract_1af0d95f3edc0562b1d75d60b670119842" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>resetIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1a5c796713828ebfb74a7d8787d7802a76" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>self</name></member>
      <member refid="classcsl_1_1Abstract_1aa6a40ceb6eb1aa79711ca126d5bdda02" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>setAllDependencies</name></member>
      <member refid="classcsl_1_1Abstract_1aab2d2ac186b56d17d2cc0a105e145b11" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>setArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a45c3adb7ba4e2b8442247246a3792b44" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>setArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a7bb29d316b8f64652cef472a6c23f001" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>setCommutable</name></member>
      <member refid="classcsl_1_1Abstract_1ae35385480a1be08f5e7433535b58ac0b" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>setComplexProperty</name></member>
      <member refid="classcsl_1_1Abstract_1a37ebc247831d6629d44117a490fca120" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>setConjugated</name></member>
      <member refid="classcsl_1_1Abstract_1aa6a04bb56578e7da143b3cd8d8fb7b26" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>setElementary</name></member>
      <member refid="classcsl_1_1Abstract_1afa50c743b8e7e76e637e98f165ad4e5d" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>setEmpty</name></member>
      <member refid="classcsl_1_1Abstract_1ac318016372d14b795893fe7e59199084" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>setFullyAntiSymmetric</name></member>
      <member refid="classcsl_1_1Abstract_1a4f90ebb7cf7c26782bd36bc2a67fc5d4" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>setFullySymmetric</name></member>
      <member refid="classcsl_1_1Abstract_1a70f946f9c59df045ef7416320ade89c7" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>setIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1a5ecdb6ce7a2d9643da2f6161a06dfbbf" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>setInfBoundary</name></member>
      <member refid="classcsl_1_1Abstract_1a867135c96776248add60018f4aa7a578" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>setName</name></member>
      <member refid="classcsl_1_1Abstract_1a70df7be4486affa8dc891e3f25bf499f" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>setOperand</name></member>
      <member refid="classcsl_1_1Abstract_1ae7b8a14fc746ed72e4d5abd63373c5ba" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>setOperandPrivate</name></member>
      <member refid="classcsl_1_1Abstract_1a3003698af4978e774eeb2e62038f7432" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>setParent</name></member>
      <member refid="classcsl_1_1Abstract_1a3c175411df619e7504feb6d888fc82f1" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>setPoint</name></member>
      <member refid="classcsl_1_1Abstract_1aad7104a5b8855272a92a47c58f29e958" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>setSupBoundary</name></member>
      <member refid="classcsl_1_1Abstract_1aaf7f0692cb84ca861a5b3b641bea518b" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>setValue</name></member>
      <member refid="classcsl_1_1Abstract_1aa49c51bd285830e724f103e9fb61c464" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>setValue</name></member>
      <member refid="classcsl_1_1Abstract_1aa47ddab3aa047e86be34c70358d53548" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>setVariable</name></member>
      <member refid="classcsl_1_1Abstract_1a83fee8ed28079bcac107455d58be9d5d" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>setVectorArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a3794843945b8a39e2c1be073c9bacdf5" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>size</name></member>
      <member refid="classcsl_1_1Abstract_1a4eeedaeaa39e75facf1060dce7c57a8f" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>suppressExponent</name></member>
      <member refid="classcsl_1_1Abstract_1a43520e1d6d5fdad9b50f77c6e027f928" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>suppressTerm</name></member>
      <member refid="classcsl_1_1Abstract_1a4faf1ffd8cb3b6c721e128980c0303d8" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>symmetrise</name></member>
      <member refid="classcsl_1_1Abstract_1a7b83c6a13716688f45b02e6291d39aba" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>tensordot</name></member>
      <member refid="classcsl_1_1Abstract_1aee4fa41a5e014f067395467542ee8831" prot="public" virt="non-virtual"><scope>csl::Abstract</scope><name>testDummy</name></member>
      <member refid="classcsl_1_1Abstract_1a9a86d21f5c5f65eb7e524a8f8002c0e7" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>trace</name></member>
      <member refid="classcsl_1_1Abstract_1aacab43e551e9259a39a79378373ce49c" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>trace</name></member>
      <member refid="classcsl_1_1Abstract_1a1e97712696e5c40b28bc1e35987fea94" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>transpose</name></member>
      <member refid="classcsl_1_1Abstract_1a40bdc4c76fdbbf3cbac3af4dce8286ed" prot="public" virt="virtual"><scope>csl::Abstract</scope><name>~Abstract</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
