<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.12.0" xml:lang="en-US">
  <compounddef id="namespacecsl" kind="namespace" language="C++">
    <compoundname>csl</compoundname>
    <innerclass refid="classcsl_1_1Abbrev" prot="public">csl::Abbrev</innerclass>
    <innerclass refid="classcsl_1_1Abbreviation" prot="public">csl::Abbreviation</innerclass>
    <innerclass refid="classcsl_1_1Abs" prot="public">csl::Abs</innerclass>
    <innerclass refid="classcsl_1_1Abstract" prot="public">csl::Abstract</innerclass>
    <innerclass refid="classcsl_1_1AbstractBuildingBlock" prot="public">csl::AbstractBuildingBlock</innerclass>
    <innerclass refid="classcsl_1_1AbstractDuoFunc" prot="public">csl::AbstractDuoFunc</innerclass>
    <innerclass refid="classcsl_1_1AbstractElement" prot="public">csl::AbstractElement</innerclass>
    <innerclass refid="classcsl_1_1AbstractFunc" prot="public">csl::AbstractFunc</innerclass>
    <innerclass refid="classcsl_1_1AbstractIntegral" prot="public">csl::AbstractIntegral</innerclass>
    <innerclass refid="classcsl_1_1AbstractLiteral" prot="public">csl::AbstractLiteral</innerclass>
    <innerclass refid="classcsl_1_1AbstractMultiFunc" prot="public">csl::AbstractMultiFunc</innerclass>
    <innerclass refid="classcsl_1_1AbstractNumerical" prot="public">csl::AbstractNumerical</innerclass>
    <innerclass refid="classcsl_1_1AbstractParent" prot="public">csl::AbstractParent</innerclass>
    <innerclass refid="classcsl_1_1AbstractVectorial" prot="public">csl::AbstractVectorial</innerclass>
    <innerclass refid="classcsl_1_1ACos" prot="public">csl::ACos</innerclass>
    <innerclass refid="classcsl_1_1ACosh" prot="public">csl::ACosh</innerclass>
    <innerclass refid="classcsl_1_1Angle" prot="public">csl::Angle</innerclass>
    <innerclass refid="classcsl_1_1Arbitrary" prot="public">csl::Arbitrary</innerclass>
    <innerclass refid="classcsl_1_1ASin" prot="public">csl::ASin</innerclass>
    <innerclass refid="classcsl_1_1ASinh" prot="public">csl::ASinh</innerclass>
    <innerclass refid="classcsl_1_1ATan" prot="public">csl::ATan</innerclass>
    <innerclass refid="classcsl_1_1ATanh" prot="public">csl::ATanh</innerclass>
    <innerclass refid="classcsl_1_1BooleanOperator" prot="public">csl::BooleanOperator</innerclass>
    <innerclass refid="structcsl_1_1canDecay" prot="public">csl::canDecay</innerclass>
    <innerclass refid="classcsl_1_1Commutator" prot="public">csl::Commutator</innerclass>
    <innerclass refid="classcsl_1_1Comparator" prot="public">csl::Comparator</innerclass>
    <innerclass refid="classcsl_1_1Complex" prot="public">csl::Complex</innerclass>
    <innerclass refid="classcsl_1_1Complexified" prot="public">csl::Complexified</innerclass>
    <innerclass refid="classcsl_1_1Constant" prot="public">csl::Constant</innerclass>
    <innerclass refid="classcsl_1_1ConstantParent" prot="public">csl::ConstantParent</innerclass>
    <innerclass refid="classcsl_1_1ContractionChain" prot="public">csl::ContractionChain</innerclass>
    <innerclass refid="classcsl_1_1Cos" prot="public">csl::Cos</innerclass>
    <innerclass refid="classcsl_1_1Cosh" prot="public">csl::Cosh</innerclass>
    <innerclass refid="classcsl_1_1DeltaParent" prot="public">csl::DeltaParent</innerclass>
    <innerclass refid="classcsl_1_1Derivative" prot="public">csl::Derivative</innerclass>
    <innerclass refid="classcsl_1_1Diagonalizer" prot="public">csl::Diagonalizer</innerclass>
    <innerclass refid="classcsl_1_1DiracDelta" prot="public">csl::DiracDelta</innerclass>
    <innerclass refid="classcsl_1_1EpsilonParent" prot="public">csl::EpsilonParent</innerclass>
    <innerclass refid="classcsl_1_1Exp" prot="public">csl::Exp</innerclass>
    <innerclass refid="structcsl_1_1ExpansionChain" prot="public">csl::ExpansionChain</innerclass>
    <innerclass refid="classcsl_1_1Expr" prot="public">csl::Expr</innerclass>
    <innerclass refid="classcsl_1_1Factorial" prot="public">csl::Factorial</innerclass>
    <innerclass refid="classcsl_1_1Float" prot="public">csl::Float</innerclass>
    <innerclass refid="classcsl_1_1Functional" prot="public">csl::Functional</innerclass>
    <innerclass refid="classcsl_1_1HighDTensor" prot="public">csl::HighDTensor</innerclass>
    <innerclass refid="classcsl_1_1Imaginary" prot="public">csl::Imaginary</innerclass>
    <innerclass refid="classcsl_1_1ImaginaryPart" prot="public">csl::ImaginaryPart</innerclass>
    <innerclass refid="classcsl_1_1Index" prot="public">csl::Index</innerclass>
    <innerclass refid="classcsl_1_1IndexedSymmetry" prot="public">csl::IndexedSymmetry</innerclass>
    <innerclass refid="classcsl_1_1IndexStructure" prot="public">csl::IndexStructure</innerclass>
    <innerclass refid="classcsl_1_1IndexStructure__new" prot="public">csl::IndexStructure_new</innerclass>
    <innerclass refid="classcsl_1_1IndexStructureView" prot="public">csl::IndexStructureView</innerclass>
    <innerclass refid="classcsl_1_1InitSanitizer" prot="public">csl::InitSanitizer</innerclass>
    <innerclass refid="classcsl_1_1Integer" prot="public">csl::Integer</innerclass>
    <innerclass refid="classcsl_1_1Integral" prot="public">csl::Integral</innerclass>
    <innerclass refid="classcsl_1_1IntFactorial" prot="public">csl::IntFactorial</innerclass>
    <innerclass refid="classcsl_1_1IntFraction" prot="public">csl::IntFraction</innerclass>
    <innerclass refid="classcsl_1_1IProd" prot="public">csl::IProd</innerclass>
    <innerclass refid="classcsl_1_1ISum" prot="public">csl::ISum</innerclass>
    <innerclass refid="classcsl_1_1LibDependency" prot="public">csl::LibDependency</innerclass>
    <innerclass refid="classcsl_1_1LibEval" prot="public">csl::LibEval</innerclass>
    <innerclass refid="classcsl_1_1LibEvalSession" prot="public">csl::LibEvalSession</innerclass>
    <innerclass refid="classcsl_1_1LibFunction" prot="public">csl::LibFunction</innerclass>
    <innerclass refid="structcsl_1_1LibParameter" prot="public">csl::LibParameter</innerclass>
    <innerclass refid="classcsl_1_1LibraryGenerator" prot="public">csl::LibraryGenerator</innerclass>
    <innerclass refid="classcsl_1_1LibraryGroup" prot="public">csl::LibraryGroup</innerclass>
    <innerclass refid="classcsl_1_1linear__map" prot="public">csl::linear_map</innerclass>
    <innerclass refid="classcsl_1_1LiteralParent" prot="public">csl::LiteralParent</innerclass>
    <innerclass refid="classcsl_1_1Lock" prot="public">csl::Lock</innerclass>
    <innerclass refid="classcsl_1_1Log" prot="public">csl::Log</innerclass>
    <innerclass refid="classcsl_1_1Matrix" prot="public">csl::Matrix</innerclass>
    <innerclass refid="classcsl_1_1MetricParent" prot="public">csl::MetricParent</innerclass>
    <innerclass refid="classcsl_1_1MultiPermutation" prot="public">csl::MultiPermutation</innerclass>
    <innerclass refid="classcsl_1_1ObjectPermutation" prot="public">csl::ObjectPermutation</innerclass>
    <innerclass refid="classcsl_1_1ObjectSymmetry" prot="public">csl::ObjectSymmetry</innerclass>
    <innerclass refid="classcsl_1_1Operator" prot="public">csl::Operator</innerclass>
    <innerclass refid="classcsl_1_1OptionalCondition" prot="public">csl::OptionalCondition</innerclass>
    <innerclass refid="classcsl_1_1Parent" prot="public">csl::Parent</innerclass>
    <innerclass refid="classcsl_1_1Permutation" prot="public">csl::Permutation</innerclass>
    <innerclass refid="classcsl_1_1Polynomial" prot="public">csl::Polynomial</innerclass>
    <innerclass refid="classcsl_1_1Pow" prot="public">csl::Pow</innerclass>
    <innerclass refid="classcsl_1_1Prod" prot="public">csl::Prod</innerclass>
    <innerclass refid="classcsl_1_1ProgressBar" prot="public">csl::ProgressBar</innerclass>
    <innerclass refid="classcsl_1_1PseudoIntegral" prot="public">csl::PseudoIntegral</innerclass>
    <innerclass refid="classcsl_1_1RealPart" prot="public">csl::RealPart</innerclass>
    <innerclass refid="classcsl_1_1ScalarIntegral" prot="public">csl::ScalarIntegral</innerclass>
    <innerclass refid="classcsl_1_1ScopedProperty" prot="public">csl::ScopedProperty</innerclass>
    <innerclass refid="classcsl_1_1SelfContraction" prot="public">csl::SelfContraction</innerclass>
    <innerclass refid="classcsl_1_1Sin" prot="public">csl::Sin</innerclass>
    <innerclass refid="classcsl_1_1Sinh" prot="public">csl::Sinh</innerclass>
    <innerclass refid="classcsl_1_1Space" prot="public">csl::Space</innerclass>
    <innerclass refid="classcsl_1_1Sum" prot="public">csl::Sum</innerclass>
    <innerclass refid="classcsl_1_1Symmetry" prot="public">csl::Symmetry</innerclass>
    <innerclass refid="classcsl_1_1Tan" prot="public">csl::Tan</innerclass>
    <innerclass refid="classcsl_1_1Tanh" prot="public">csl::Tanh</innerclass>
    <innerclass refid="classcsl_1_1TDerivative" prot="public">csl::TDerivative</innerclass>
    <innerclass refid="classcsl_1_1TDerivativeElement" prot="public">csl::TDerivativeElement</innerclass>
    <innerclass refid="classcsl_1_1TDerivativeParent" prot="public">csl::TDerivativeParent</innerclass>
    <innerclass refid="classcsl_1_1Tensor" prot="public">csl::Tensor</innerclass>
    <innerclass refid="classcsl_1_1TensorElement" prot="public">csl::TensorElement</innerclass>
    <innerclass refid="classcsl_1_1TensorField" prot="public">csl::TensorField</innerclass>
    <innerclass refid="classcsl_1_1TensorFieldElement" prot="public">csl::TensorFieldElement</innerclass>
    <innerclass refid="classcsl_1_1TensorFieldParent" prot="public">csl::TensorFieldParent</innerclass>
    <innerclass refid="classcsl_1_1TensorParent" prot="public">csl::TensorParent</innerclass>
    <innerclass refid="classcsl_1_1TimeMonitor" prot="public">csl::TimeMonitor</innerclass>
    <innerclass refid="classcsl_1_1Timer" prot="public">csl::Timer</innerclass>
    <innerclass refid="classcsl_1_1Variable" prot="public">csl::Variable</innerclass>
    <innerclass refid="classcsl_1_1VariableParent" prot="public">csl::VariableParent</innerclass>
    <innerclass refid="classcsl_1_1Vector" prot="public">csl::Vector</innerclass>
    <innerclass refid="classcsl_1_1VectorIntegral" prot="public">csl::VectorIntegral</innerclass>
    <innernamespace refid="namespacecsl_1_1eval">csl::eval</innernamespace>
    <innernamespace refid="namespacecsl_1_1matcher">csl::matcher</innernamespace>
    <innernamespace refid="namespacecsl_1_1option">csl::option</innernamespace>
    <sectiondef kind="enum">
      <memberdef kind="enum" id="namespacecsl_1a70046459ec0082db8cb97005c13c9a54" prot="public" static="no" strong="yes">
        <type></type>
        <name>PrimaryType</name>
        <qualifiedname>csl::PrimaryType</qualifiedname>
        <enumvalue id="namespacecsl_1a70046459ec0082db8cb97005c13c9a54a3c1fc46575f79b15fc8990642387d07f" prot="public">
          <name>Arbitrary</name>
          <initializer>=-1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1a70046459ec0082db8cb97005c13c9a54a5225763efc97aebd39e5a303fceb57ac" prot="public">
          <name>Numerical</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>= 0. Concerns Number and <ref refid="classcsl_1_1IntFraction" kindref="compound">IntFraction</ref>. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1a70046459ec0082db8cb97005c13c9a54ad7da1b76e5799f53a399b7a96ba67437" prot="public">
          <name>Literal</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>= 1. Concerns <ref refid="classcsl_1_1Variable" kindref="compound">Variable</ref>, <ref refid="classcsl_1_1IntFactorial" kindref="compound">IntFactorial</ref> and <ref refid="classcsl_1_1Imaginary" kindref="compound">Imaginary</ref>. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1a70046459ec0082db8cb97005c13c9a54a78216444cbb3388cc8c2f64cc44c7cd5" prot="public">
          <name>MultiFunction</name>
          <initializer>=10</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>= 10. Concerns all scalar multi-variate functions (<ref refid="classcsl_1_1Sum" kindref="compound">Sum</ref>, <ref refid="classcsl_1_1Prod" kindref="compound">Prod</ref>, <ref refid="classcsl_1_1Pow" kindref="compound">Pow</ref>, etc). </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1a70046459ec0082db8cb97005c13c9a54a8870e734b769add08821a829f6951853" prot="public">
          <name>ScalarFunction</name>
          <initializer>=20</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>= 20. Concerns all scalar uni-variate functions (<ref refid="classcsl_1_1Exp" kindref="compound">Exp</ref>, <ref refid="classcsl_1_1Log" kindref="compound">Log</ref>, <ref refid="classcsl_1_1Cos" kindref="compound">Cos</ref>, etc). </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1a70046459ec0082db8cb97005c13c9a54a97a447e7de95e9e2940291e17bcc4e3a" prot="public">
          <name>Vectorial</name>
          <initializer>=50</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>= 50. Concerns <ref refid="classcsl_1_1Vector" kindref="compound">Vector</ref>, <ref refid="classcsl_1_1Matrix" kindref="compound">Matrix</ref> and <ref refid="classcsl_1_1HighDTensor" kindref="compound">HighDTensor</ref>. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1a70046459ec0082db8cb97005c13c9a54a25e27f9899952c474587a6bee3ab9978" prot="public">
          <name>Indicial</name>
          <initializer>=60</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>= 60. Concerns all indicial exprs. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1a70046459ec0082db8cb97005c13c9a54a6f16a5f8ff5d75ab84c018adacdfcbb7" prot="public">
          <name>Field</name>
          <initializer>=70</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>= 70. Concerns all Fields exprs. </para>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Stores enumerations of types for <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> objects. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/enum.h" line="31" column="5" bodyfile="src/csl/enum.h" bodystart="31" bodyend="43"/>
      </memberdef>
      <memberdef kind="enum" id="namespacecsl_1ace591865c69b6315c533a1a325777312" prot="public" static="no" strong="yes">
        <type></type>
        <name>Type</name>
        <qualifiedname>csl::Type</qualifiedname>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a892b1f4fc1fcdaaf7dfed08ced04a389" prot="public">
          <name>InheritanceType</name>
          <initializer>=-2</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a9080fd7a5f0af44b585bb21b62d8b283" prot="public">
          <name>NoType</name>
          <initializer>=-1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Arbitrary" kindref="compound">Arbitrary</ref> <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> in comparisons </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312aa0faef0851b4294c06f2b94bb1cb2044" prot="public">
          <name>Integer</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Integer" kindref="compound">Integer</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a22ae0e2b89e5e3d477f988cc36d3272b" prot="public">
          <name>Float</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Float" kindref="compound">Float</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312aa9e4acf6d1d381d6875f480a5737b8b4" prot="public">
          <name>IntFraction</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1IntFraction" kindref="compound">IntFraction</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312aa79046cb7e9f609ba07c4ec22f14a862" prot="public">
          <name>IntFactorial</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1IntFactorial" kindref="compound">IntFactorial</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a10b4eb76294b70d7fd6df997ff06edb1" prot="public">
          <name>Complex</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><orderedlist>
<listitem><para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Complex" kindref="compound">Complex</ref> </para>
</listitem></orderedlist>
</para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312ab87c58a6946efb3fd56cc53586d2fb78" prot="public">
          <name>NumericalEval</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in NumericalEval </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312af19f497d4c860d252cc1e055d0362ccc" prot="public">
          <name>Imaginary</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Imaginary" kindref="compound">Imaginary</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312acb17869fe51048b5a5c4c6106551a255" prot="public">
          <name>Constant</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Constant" kindref="compound">Constant</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a47c14840d8e15331fa420b9b2f757cd9" prot="public">
          <name>Variable</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Variable" kindref="compound">Variable</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312acad39a154bffb61175f674d6eefaf6d0" prot="public">
          <name>Exp</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Exp" kindref="compound">Exp</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312ace0be71e33226e4c1db2bcea5959f16b" prot="public">
          <name>Log</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Log" kindref="compound">Log</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a29524358ad4c2579d7b08a21c990ce5e" prot="public">
          <name>DiracDelta</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in Dirac Delta </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a1e34af023adeb7d5f484f8eb4b9826b6" prot="public">
          <name>Abs</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Abs" kindref="compound">Abs</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312affca562be079b9e4e41ea9d6a86c582b" prot="public">
          <name>Cos</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Cos" kindref="compound">Cos</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a0986d137604183312e6d3599578bc6cd" prot="public">
          <name>Sin</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Sin" kindref="compound">Sin</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a1266b4e6f81e60733ec6c717e0181f60" prot="public">
          <name>Tan</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Tan" kindref="compound">Tan</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a4371c3565b771b40c187487cc0190392" prot="public">
          <name>Cosh</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Cosh" kindref="compound">Cosh</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a98ed804abf4edd1f3be3fa894fa8cc3d" prot="public">
          <name>Sinh</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Sinh" kindref="compound">Sinh</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312acc132a41cab5676334f353a22a0aa5c5" prot="public">
          <name>Tanh</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Tanh" kindref="compound">Tanh</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a1c3ca8e525c0e6a47cc8489cb3155365" prot="public">
          <name>ACos</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1ACos" kindref="compound">ACos</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a118d7e2878ba8789c8f86eee41c470b3" prot="public">
          <name>ASin</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1ASin" kindref="compound">ASin</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312af9be9640e98f6072e8e0eaf2b418efe2" prot="public">
          <name>ATan</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1ATan" kindref="compound">ATan</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a27cebb75cb5855484f7df7070b4cab73" prot="public">
          <name>ACosh</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1ACosh" kindref="compound">ACosh</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a6964cd88a53b2e4c358bcad0d9feac55" prot="public">
          <name>ASinh</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1ASinh" kindref="compound">ASinh</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a2286f4e717c6213c895da49a51aa5de7" prot="public">
          <name>ATanh</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1ATanh" kindref="compound">ATanh</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312af60357a8d17e45793298323f1b372a74" prot="public">
          <name>Scalar</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in Scalar. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312ac74cc04b1519df2caf5026e94c3e8bab" prot="public">
          <name>RealPart</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in real part. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312ac49d71b3e882559a62d9d17009728907" prot="public">
          <name>ImaginaryPart</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in imaginary part. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a84f9e7bc59dd338537142e95bbd5521a" prot="public">
          <name>BooleanOperator</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in Boolean operator. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a2ed2c32254f39662881b6eed72021250" prot="public">
          <name>TensorElement</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1TensorElement" kindref="compound">TensorElement</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a02e48a623b58c0b63bd2ad0e891c944e" prot="public">
          <name>ScalarField</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in ScalarField. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a5a44d898396f28619971f227d438ef40" prot="public">
          <name>TensorFieldElement</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1TensorFieldElement" kindref="compound">TensorFieldElement</ref>. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a9134ead1dfb798c5efccfaf181501eeb" prot="public">
          <name>TDerivativeElement</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312af575ff69fb3dc1eeb3341d4a419cada2" prot="public">
          <name>StandardDuo</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in StandardDuo </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a607547b66dcd8e516cde5cc78739ae80" prot="public">
          <name>StandardMult</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in StandardDuo </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a8be6d3e955290ee50c00a4bc92aa7749" prot="public">
          <name>Pow</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Pow" kindref="compound">Pow</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a362a33c23b08e4a32a4ec53fbb82cccd" prot="public">
          <name>Prod</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Prod" kindref="compound">Prod</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312aa0ec87054b5e5b7847d0d8780a01a3d5" prot="public">
          <name>Sum</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Sum" kindref="compound">Sum</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a24ecfbe376a82f09ad48bffc6b8d6a87" prot="public">
          <name>Polynomial</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Polynomial" kindref="compound">Polynomial</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a70ae6e285cc14c8486e3cf5bec39d1fd" prot="public">
          <name>Derivative</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Derivative" kindref="compound">Derivative</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312acc1e31375d9c49eb15a3302b96acc061" prot="public">
          <name>Commutator</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Commutator" kindref="compound">Commutator</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a45f4ce6c3306644b1efe333f4f8d6929" prot="public">
          <name>Angle</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Angle" kindref="compound">Angle</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a012b11265b94945f7a1390a07776e625" prot="public">
          <name>Factorial</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Factorial" kindref="compound">Factorial</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a4ea94552a2bec56a29592359a1b6069e" prot="public">
          <name>Integral</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Integral" kindref="compound">Integral</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312ad4d8fc83b4874f82d0b698683c6b9e22" prot="public">
          <name>ScalarIntegral</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1ScalarIntegral" kindref="compound">ScalarIntegral</ref>. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a7a5b7a2e7ef67739db0cf0cc4d3e5d60" prot="public">
          <name>VectorIntegral</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1VectorIntegral" kindref="compound">VectorIntegral</ref>. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a57dea6f5039281b7fee517fc43bf3110" prot="public">
          <name>Vector</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Vector" kindref="compound">Vector</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312af53df0293e169f562bc1d9a20e1d2589" prot="public">
          <name>Matrix</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1Matrix" kindref="compound">Matrix</ref> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ace591865c69b6315c533a1a325777312a93ff2aa452bc6cbb7c3fe56cc7d196c5" prot="public">
          <name>HighDTensor</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> specialized in <ref refid="classcsl_1_1HighDTensor" kindref="compound">HighDTensor</ref> </para>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enum of the different types of <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> (i.e. list of all possible specializations). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/enum.h" line="47" column="5" bodyfile="src/csl/enum.h" bodystart="47" bodyend="107"/>
      </memberdef>
      <memberdef kind="enum" id="namespacecsl_1a83f7f019995e7a2aa1c4287048964256" prot="public" static="no" strong="yes">
        <type></type>
        <name>LibraryMode</name>
        <qualifiedname>csl::LibraryMode</qualifiedname>
        <enumvalue id="namespacecsl_1a83f7f019995e7a2aa1c4287048964256aaf6f4c5fd935baebe2bfc53f446d70e2" prot="public">
          <name>NoLib</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1a83f7f019995e7a2aa1c4287048964256af6a6a006f10ca39b75d97a27e7242815" prot="public">
          <name>CLib</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1a83f7f019995e7a2aa1c4287048964256ac2adcbb73ccd657896d8b5db1c030cf8" prot="public">
          <name>CppLib</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/enum.h" line="109" column="5" bodyfile="src/csl/enum.h" bodystart="109" bodyend="113"/>
      </memberdef>
      <memberdef kind="enum" id="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0e" prot="public" static="no" strong="yes">
        <type></type>
        <name>ComplexProperty</name>
        <qualifiedname>csl::ComplexProperty</qualifiedname>
        <enumvalue id="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0ea10b4eb76294b70d7fd6df997ff06edb1" prot="public">
          <name>Complex</name>
          <briefdescription>
<para>complex object, <formula id="30">$ z^* \neq z. $</formula> </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0ea7f80fcc452c2f1ed2bb51b39d0864df1" prot="public">
          <name>Real</name>
          <briefdescription>
<para>real object, <formula id="31">$ z^* = z. $</formula> </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0eaf19f497d4c860d252cc1e055d0362ccc" prot="public">
          <name>Imaginary</name>
          <briefdescription>
<para>imaginary object, <formula id="32">$ z^* = -z. $</formula> </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Contains all possible complex properties of objects. Real, purely imaginary, or complex. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/enum.h" line="134" column="1" bodyfile="src/csl/enum.h" bodystart="134" bodyend="148"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespacecsl_1ab837ea28108ebbfcf82c6648cdfb2a77" prot="public" static="no">
        <type>std::pair&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref>, std::vector&lt; size_t &gt; &gt;</type>
        <definition>using csl::FactorType =  std::pair&lt;csl::Expr, std::vector&lt;size_t&gt;&gt;</definition>
        <argsstring></argsstring>
        <name>FactorType</name>
        <qualifiedname>csl::FactorType</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/hardFactor.cpp" line="98" column="1" bodyfile="src/csl/hardFactor.cpp" bodystart="98" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacecsl_1a4cd4d9bece6908d0035d251608340b3e" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::allocator&lt; T &gt;</type>
        <definition>using csl::allocator =  std::allocator&lt;T&gt;</definition>
        <argsstring></argsstring>
        <name>allocator</name>
        <qualifiedname>csl::allocator</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/memory_pool.h" line="30" column="1" bodyfile="src/csl/memory_pool.h" bodystart="30" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacecsl_1aa7e7c364fce74b233395d3380ada6d7c" prot="public" static="no">
        <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;)&gt;</type>
        <definition>using csl::ExpanderEmitter =  std::function&lt;bool(csl::Expr const &amp;)&gt;</definition>
        <argsstring></argsstring>
        <name>ExpanderEmitter</name>
        <qualifiedname>csl::ExpanderEmitter</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.h" line="25" column="1" bodyfile="src/csl/partialExpand.h" bodystart="25" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacecsl_1aa5d5f79a8f1796fdeaa5fca59b3de2d6" prot="public" static="no">
        <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;, <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;)&gt;</type>
        <definition>using csl::ExpanderReceiver =  std::function&lt;bool(csl::Expr const &amp;, csl::Expr const &amp;)&gt;</definition>
        <argsstring></argsstring>
        <name>ExpanderReceiver</name>
        <qualifiedname>csl::ExpanderReceiver</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.h" line="26" column="1" bodyfile="src/csl/partialExpand.h" bodystart="26" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacecsl_1a236c3928ac0b1760b8738490dcf82706" prot="public" static="no">
        <type>std::function&lt; std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt;(<ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;, bool)&gt;</type>
        <definition>using csl::replacementRule =  std::function&lt;std::optional&lt;csl::Expr&gt;(csl::Expr const &amp;, bool)&gt;</definition>
        <argsstring></argsstring>
        <name>replacementRule</name>
        <qualifiedname>csl::replacementRule</qualifiedname>
        <briefdescription>
<para>Replacement rule prototype. </para>
        </briefdescription>
        <detaileddescription>
<para>The function takes a constant expression as parameter and a boolean. If true, this boolean specifies that the rule is used only as a predicate for the moment i.e. that no calculation must be done in the return value (the optional will be used as a bool to know if a replacement must take place). If false, this function must return the result of the replacement in the std::optional&lt;csl::Expr&gt;. If no replacement is possible, return std::nullopt. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.h" line="144" column="1" bodyfile="src/csl/replace.h" bodystart="144" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacecsl_1ab7f057fadac516af9ba914d6f28dc2f5" prot="public" static="no">
        <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;::iterator</type>
        <definition>using csl::iterator =  std::vector&lt;Expr&gt;::iterator</definition>
        <argsstring></argsstring>
        <name>iterator</name>
        <qualifiedname>csl::iterator</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/sort.cpp" line="20" column="1" bodyfile="src/csl/sort.cpp" bodystart="20" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacecsl_1ac38970f7ca3e3f1b55a4f45bec29d2df" prot="public" static="no">
        <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">csl::Abstract</ref> *</type>
        <definition>typedef const csl::Abstract* csl::Expr_info</definition>
        <argsstring></argsstring>
        <name>Expr_info</name>
        <qualifiedname>csl::Expr_info</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/typedef.h" line="38" column="29" bodyfile="src/csl/typedef.h" bodystart="38" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacecsl_1aacdb3e4e41be0151231def8d5c952951" prot="public" static="no">
        <type><ref refid="classstd_1_1shared__ptr" kindref="compound">std::shared_ptr</ref>&lt; const <ref refid="classcsl_1_1Abstract" kindref="compound">csl::Abstract</ref> &gt;</type>
        <definition>typedef std::shared_ptr&lt;const csl::Abstract&gt; csl::Expr_c</definition>
        <argsstring></argsstring>
        <name>Expr_c</name>
        <qualifiedname>csl::Expr_c</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/typedef.h" line="41" column="25" bodyfile="src/csl/typedef.h" bodystart="41" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacecsl_1a440b1a9dde4e51a3c3e7a33d96df369c" prot="public" static="no">
        <type>std::unique_ptr&lt; <ref refid="classcsl_1_1Abstract" kindref="compound">csl::Abstract</ref> &gt;</type>
        <definition>typedef std::unique_ptr&lt;csl::Abstract&gt; csl::unique_Expr</definition>
        <argsstring></argsstring>
        <name>unique_Expr</name>
        <qualifiedname>csl::unique_Expr</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/typedef.h" line="43" column="31" bodyfile="src/csl/typedef.h" bodystart="43" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacecsl_1a49336789149088ae6010c23e67c53f95" prot="public" static="no">
        <type>std::unique_ptr&lt; const <ref refid="classcsl_1_1Abstract" kindref="compound">csl::Abstract</ref> &gt;</type>
        <definition>typedef std::unique_ptr&lt;const csl::Abstract&gt; csl::unique_Expr_c</definition>
        <argsstring></argsstring>
        <name>unique_Expr_c</name>
        <qualifiedname>csl::unique_Expr_c</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/typedef.h" line="44" column="25" bodyfile="src/csl/typedef.h" bodystart="44" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacecsl_1a926bc4385ff492af398884ab534923b6" prot="public" static="no">
        <type>std::weak_ptr&lt; <ref refid="classcsl_1_1Abstract" kindref="compound">csl::Abstract</ref> &gt;</type>
        <definition>typedef std::weak_ptr&lt;csl::Abstract&gt; csl::weak_Expr</definition>
        <argsstring></argsstring>
        <name>weak_Expr</name>
        <qualifiedname>csl::weak_Expr</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/typedef.h" line="46" column="29" bodyfile="src/csl/typedef.h" bodystart="46" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacecsl_1aaaff380aa34cc67e6e7ae404aa14905c" prot="public" static="no">
        <type>std::weak_ptr&lt; const <ref refid="classcsl_1_1Abstract" kindref="compound">csl::Abstract</ref> &gt;</type>
        <definition>typedef std::weak_ptr&lt;const csl::Abstract&gt; csl::weak_Expr_c</definition>
        <argsstring></argsstring>
        <name>weak_Expr_c</name>
        <qualifiedname>csl::weak_Expr_c</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/typedef.h" line="47" column="23" bodyfile="src/csl/typedef.h" bodystart="47" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacecsl_1a88ffcbfc49457813a3e4fdb2d7ffb165" prot="public" static="no">
        <type>const <ref refid="classcsl_1_1AbstractParent" kindref="compound">csl::AbstractParent</ref> *</type>
        <definition>typedef const csl::AbstractParent* csl::Parent_info</definition>
        <argsstring></argsstring>
        <name>Parent_info</name>
        <qualifiedname>csl::Parent_info</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/typedef.h" line="49" column="35" bodyfile="src/csl/typedef.h" bodystart="49" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacecsl_1a067a17a493aeffd986aa5ea8ae85d575" prot="public" static="no">
        <type>const <ref refid="classcsl_1_1TensorParent" kindref="compound">csl::TensorParent</ref> *</type>
        <definition>typedef const csl::TensorParent* csl::IParent_info</definition>
        <argsstring></argsstring>
        <name>IParent_info</name>
        <qualifiedname>csl::IParent_info</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/typedef.h" line="51" column="33" bodyfile="src/csl/typedef.h" bodystart="51" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacecsl_1ae9339cd89c3a13487979c807ca0481ee" prot="public" static="no">
        <type>std::allocator&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>using csl::Vector_alloc =  std::allocator&lt;Expr&gt;</definition>
        <argsstring></argsstring>
        <name>Vector_alloc</name>
        <qualifiedname>csl::Vector_alloc</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/typedef.h" line="54" column="1" bodyfile="src/csl/typedef.h" bodystart="54" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacecsl_1a6f192ac4ae9790cbd54443162d02cd53" prot="public" static="no">
        <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>using csl::vector_expr =  std::vector&lt;Expr&gt;</definition>
        <argsstring></argsstring>
        <name>vector_expr</name>
        <qualifiedname>csl::vector_expr</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/typedef.h" line="56" column="1" bodyfile="src/csl/typedef.h" bodystart="56" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="var">
      <memberdef kind="variable" id="namespacecsl_1ac392035713c4a9d74cb4857e69362499" prot="public" static="no" mutable="no">
        <type>std::map&lt; std::string, std::vector&lt; <ref refid="classcsl_1_1AbstractParent" kindref="compound">AbstractParent</ref> * &gt; &gt;</type>
        <definition>std::map&lt;std::string, std::vector&lt;AbstractParent *&gt; &gt; csl::abbreviationData</definition>
        <argsstring></argsstring>
        <name>abbreviationData</name>
        <qualifiedname>csl::abbreviationData</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abreviation.h" line="40" column="17" bodyfile="src/csl/abreviation.h" bodystart="40" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1ad5aff4f893f599393d0d9d43d25859e3" prot="public" static="yes" mutable="no">
        <type>string</type>
        <definition>string csl::emptyString</definition>
        <argsstring></argsstring>
        <name>emptyString</name>
        <qualifiedname>csl::emptyString</qualifiedname>
        <initializer>= &quot;&quot;</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.cpp" line="35" column="15" bodyfile="src/csl/abstract.cpp" bodystart="35" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1ad80a7a580e19054274c7ccc1ac47e0b1" prot="public" static="yes" mutable="no">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::undef</definition>
        <argsstring></argsstring>
        <name>undef</name>
        <qualifiedname>csl::undef</qualifiedname>
        <initializer>= <ref refid="literal_8h_1a65960e7645699e5eeed663bab0d2309b" kindref="member">CSL_UNDEF</ref></initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.cpp" line="465" column="13" bodyfile="src/csl/abstract.cpp" bodystart="465" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1ae2c85a9b160583b0827abdb1bdfc37aa" prot="public" static="no" mutable="no">
        <type>csl::allocator&lt; <ref refid="classcsl_1_1TensorElement" kindref="compound">TensorElement</ref> &gt;</type>
        <definition>csl::allocator&lt;TensorElement&gt; csl::alloc_itensor</definition>
        <argsstring></argsstring>
        <name>alloc_itensor</name>
        <qualifiedname>csl::alloc_itensor</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="931" column="23" bodyfile="src/csl/indicial.h" bodystart="931" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1a927babc16317fc8f1f142ad3cf037a83" prot="public" static="no" mutable="no">
        <type>csl::allocator&lt; <ref refid="classcsl_1_1ISum" kindref="compound">ISum</ref> &gt;</type>
        <definition>csl::allocator&lt;ISum&gt; csl::alloc_isum</definition>
        <argsstring></argsstring>
        <name>alloc_isum</name>
        <qualifiedname>csl::alloc_isum</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="932" column="32" bodyfile="src/csl/indicial.h" bodystart="932" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1a2c5b80ac91ac0b40444b95b42392704e" prot="public" static="no" mutable="no">
        <type>csl::allocator&lt; <ref refid="classcsl_1_1IProd" kindref="compound">IProd</ref> &gt;</type>
        <definition>csl::allocator&lt;IProd&gt; csl::alloc_iprod</definition>
        <argsstring></argsstring>
        <name>alloc_iprod</name>
        <qualifiedname>csl::alloc_iprod</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="933" column="31" bodyfile="src/csl/indicial.h" bodystart="933" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1a0a8becef8429ef6949caee5d83e9c0fe" prot="public" static="no" mutable="no">
        <type>csl::allocator&lt; <ref refid="classcsl_1_1Constant" kindref="compound">Constant</ref> &gt;</type>
        <definition>csl::allocator&lt;Constant&gt; csl::alloc_constant</definition>
        <argsstring></argsstring>
        <name>alloc_constant</name>
        <qualifiedname>csl::alloc_constant</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/literal.h" line="541" column="23" bodyfile="src/csl/literal.h" bodystart="541" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1ae97f7287c060eeb8b6590d9bc91fba40" prot="public" static="no" mutable="no">
        <type>csl::allocator&lt; <ref refid="classcsl_1_1Variable" kindref="compound">Variable</ref> &gt;</type>
        <definition>csl::allocator&lt;Variable&gt; csl::alloc_variable</definition>
        <argsstring></argsstring>
        <name>alloc_variable</name>
        <qualifiedname>csl::alloc_variable</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/literal.h" line="542" column="23" bodyfile="src/csl/literal.h" bodystart="542" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1a7b4d94ed5c06c7c985be6c377159f315" prot="public" static="no" mutable="no">
        <type>csl::allocator&lt; <ref refid="classcsl_1_1Integer" kindref="compound">Integer</ref> &gt;</type>
        <definition>csl::allocator&lt;Integer&gt; csl::alloc_integer</definition>
        <argsstring></argsstring>
        <name>alloc_integer</name>
        <qualifiedname>csl::alloc_integer</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/numerical.h" line="478" column="27" bodyfile="src/csl/numerical.h" bodystart="478" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1ac39c09a316ab6fd4a2b318d191a45e09" prot="public" static="no" mutable="no">
        <type>csl::allocator&lt; <ref refid="classcsl_1_1Float" kindref="compound">Float</ref> &gt;</type>
        <definition>csl::allocator&lt;Float&gt; csl::alloc_float</definition>
        <argsstring></argsstring>
        <name>alloc_float</name>
        <qualifiedname>csl::alloc_float</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/numerical.h" line="479" column="29" bodyfile="src/csl/numerical.h" bodystart="479" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1addc7e5dcba4ee20e35d80b76b651f8aa" prot="public" static="no" mutable="no">
        <type>csl::allocator&lt; <ref refid="classcsl_1_1IntFraction" kindref="compound">IntFraction</ref> &gt;</type>
        <definition>csl::allocator&lt;IntFraction&gt; csl::alloc_intfraction</definition>
        <argsstring></argsstring>
        <name>alloc_intfraction</name>
        <qualifiedname>csl::alloc_intfraction</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/numerical.h" line="480" column="23" bodyfile="src/csl/numerical.h" bodystart="480" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1a140db7361d9738dc2e6877399eb6265f" prot="public" static="no" mutable="no">
        <type>csl::allocator&lt; <ref refid="classcsl_1_1Complex" kindref="compound">Complex</ref> &gt;</type>
        <definition>csl::allocator&lt;Complex&gt; csl::alloc_complex</definition>
        <argsstring></argsstring>
        <name>alloc_complex</name>
        <qualifiedname>csl::alloc_complex</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/numerical.h" line="481" column="27" bodyfile="src/csl/numerical.h" bodystart="481" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1aa3a0e553cbdf619370d82a654e75b802" prot="public" static="no" mutable="no">
        <type>csl::allocator&lt; <ref refid="classcsl_1_1Sum" kindref="compound">Sum</ref> &gt;</type>
        <definition>csl::allocator&lt;Sum&gt; csl::alloc_sum</definition>
        <argsstring></argsstring>
        <name>alloc_sum</name>
        <qualifiedname>csl::alloc_sum</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.h" line="942" column="24" bodyfile="src/csl/operations.h" bodystart="942" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1a36ddd2dc372a534000938ec64e8ad494" prot="public" static="no" mutable="no">
        <type>csl::allocator&lt; <ref refid="classcsl_1_1Prod" kindref="compound">Prod</ref> &gt;</type>
        <definition>csl::allocator&lt;Prod&gt; csl::alloc_prod</definition>
        <argsstring></argsstring>
        <name>alloc_prod</name>
        <qualifiedname>csl::alloc_prod</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.h" line="943" column="23" bodyfile="src/csl/operations.h" bodystart="943" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1af9da82d4a5b2f1ad748abd7c04cbdf63" prot="public" static="no" mutable="no">
        <type>csl::allocator&lt; <ref refid="classcsl_1_1Pow" kindref="compound">Pow</ref> &gt;</type>
        <definition>csl::allocator&lt;Pow&gt; csl::alloc_pow</definition>
        <argsstring></argsstring>
        <name>alloc_pow</name>
        <qualifiedname>csl::alloc_pow</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.h" line="944" column="24" bodyfile="src/csl/operations.h" bodystart="944" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1af2f015417e484717960b517cc3ce3602" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
          <param>
            <type>class Type</type>
          </param>
          <param>
            <type>class Type2</type>
            <defval>Type</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool csl::canDecay_v</definition>
        <argsstring></argsstring>
        <name>canDecay_v</name>
        <qualifiedname>csl::canDecay_v</qualifiedname>
        <initializer>= <ref refid="structcsl_1_1canDecay" kindref="compound">canDecay</ref>&lt;T, U, <ref refid="namespacecsl_1ace591865c69b6315c533a1a325777312" kindref="member">Type</ref>, Type2&gt;::value</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.h" line="59" column="23" bodyfile="src/csl/replace.h" bodystart="59" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1ac47cb411c52614e2aca81edc2c6f97ef" prot="public" static="no" extern="yes" mutable="no">
        <type>bool</type>
        <definition>bool csl::RANDOM_SEED</definition>
        <argsstring></argsstring>
        <name>RANDOM_SEED</name>
        <qualifiedname>csl::RANDOM_SEED</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.h" line="29" column="13" declfile="src/csl/simplification.h" declline="29" declcolumn="13"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1aca17911173cc383d829dce28a06c00f4" prot="public" static="no" extern="yes" mutable="no">
        <type>const int</type>
        <definition>const int csl::NUMBER_OF_MUTATIONS</definition>
        <argsstring></argsstring>
        <name>NUMBER_OF_MUTATIONS</name>
        <qualifiedname>csl::NUMBER_OF_MUTATIONS</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.h" line="31" column="18" declfile="src/csl/simplification.h" declline="31" declcolumn="18"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1a737a418e19c3b62659f21070ca025b3a" prot="public" static="no" extern="yes" mutable="no">
        <type>const int</type>
        <definition>const int csl::NATURAL_SELECTION</definition>
        <argsstring></argsstring>
        <name>NATURAL_SELECTION</name>
        <qualifiedname>csl::NATURAL_SELECTION</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.h" line="33" column="18" declfile="src/csl/simplification.h" declline="33" declcolumn="18"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1abb4687acdfa532adaabedd31fe2d3cf2" prot="public" static="no" extern="yes" mutable="no">
        <type>const int</type>
        <definition>const int csl::NUMBER_OF_GENERATION</definition>
        <argsstring></argsstring>
        <name>NUMBER_OF_GENERATION</name>
        <qualifiedname>csl::NUMBER_OF_GENERATION</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.h" line="35" column="18" declfile="src/csl/simplification.h" declline="35" declcolumn="18"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1ace4491c5ff0e5ef74c12369ddecec5cf" prot="public" static="no" extern="yes" mutable="no">
        <type>const int</type>
        <definition>const int csl::GENERATION_BEFORE_SELECTION</definition>
        <argsstring></argsstring>
        <name>GENERATION_BEFORE_SELECTION</name>
        <qualifiedname>csl::GENERATION_BEFORE_SELECTION</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.h" line="37" column="18" declfile="src/csl/simplification.h" declline="37" declcolumn="18"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1a7fbda9d9e75931fb6ec26bdfb14e6bb1" prot="public" static="no" extern="yes" mutable="no">
        <type>const int</type>
        <definition>const int csl::SIMPLIFICATION_METHOD</definition>
        <argsstring></argsstring>
        <name>SIMPLIFICATION_METHOD</name>
        <qualifiedname>csl::SIMPLIFICATION_METHOD</qualifiedname>
        <briefdescription>
<para>Determines which simplification method is applied. Ther used to be 2, now there is only one method. It may be useful in the future. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.h" line="43" column="18" declfile="src/csl/simplification.h" declline="43" declcolumn="18"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1a66c6baccc5af4c180975610469660a24" prot="public" static="no" extern="yes" mutable="no">
        <type>const int</type>
        <definition>const int csl::MAX_ALTERNATE_FORMS</definition>
        <argsstring></argsstring>
        <name>MAX_ALTERNATE_FORMS</name>
        <qualifiedname>csl::MAX_ALTERNATE_FORMS</qualifiedname>
        <briefdescription>
<para>Maximum number of alternate forms given by <ref refid="namespacecsl_1a46d59a363192eb0486d9c16523f18fe4" kindref="member">getRecursiveAlternateForms()</ref>. When getting alternate forms of an expression, we keep only the MAX_ALTERNATE_FORMS simpler. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.h" line="50" column="18" declfile="src/csl/simplification.h" declline="50" declcolumn="18"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1a5c5e88ebf69cefa7cd3417b7a1360721" prot="public" static="no" extern="yes" mutable="no">
        <type>const int</type>
        <definition>const int csl::MAX_RECURSION_ALTERNATE</definition>
        <argsstring></argsstring>
        <name>MAX_RECURSION_ALTERNATE</name>
        <qualifiedname>csl::MAX_RECURSION_ALTERNATE</qualifiedname>
        <briefdescription>
<para>When getting alternateForms, we iterate MAX_RECURSION_ALTERNATE times (getting alternate forms of the alternate forms) in order to allow alternates that need several steps of Transformation. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.h" line="57" column="18" declfile="src/csl/simplification.h" declline="57" declcolumn="18"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1ab3885c426f3cbbc274fe4ce33aae739b" prot="public" static="no" mutable="no">
        <type>size_t</type>
        <definition>size_t csl::minMergeSize</definition>
        <argsstring></argsstring>
        <name>minMergeSize</name>
        <qualifiedname>csl::minMergeSize</qualifiedname>
        <initializer>= 10</initializer>
        <briefdescription>
<para>Minimum size for a container to be sorted with mergeSort(). </para>
        </briefdescription>
        <detaileddescription>
<para>For smaller containers, selectionSort() is called instead, even trying to use specifically mergeSort(). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/sort.h" line="46" column="15" bodyfile="src/csl/sort.h" bodystart="46" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1a1be06bfad88957d4bfd2f8b9a966a418" prot="public" static="no" mutable="no">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::DMinko</definition>
        <argsstring></argsstring>
        <name>DMinko</name>
        <qualifiedname>csl::DMinko</qualifiedname>
        <initializer>= csl::constant_s(&quot;D&quot;, csl::int_s(4))</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/space.h" line="404" column="13" bodyfile="src/csl/space.h" bodystart="404" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1aef525ce7226ae5fa0fc9b9f2aa4ccc5d" prot="public" static="no" mutable="no">
        <type>const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> &amp;</type>
        <definition>const Space&amp; csl::Minkowski</definition>
        <argsstring></argsstring>
        <name>Minkowski</name>
        <qualifiedname>csl::Minkowski</qualifiedname>
        <initializer>= buildMinkowski()</initializer>
        <briefdescription>
<para><ref refid="classcsl_1_1Space" kindref="compound">Space</ref> <formula id="45">$ R^{1,3} $</formula> with a metric g = diag(-1,1,1,1). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/space.h" line="445" column="20" bodyfile="src/csl/space.h" bodystart="445" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacecsl_1ad6a5177394069a44d1e6b4a1a05e9f73" prot="public" static="no" mutable="no">
        <type>Vector_alloc</type>
        <definition>Vector_alloc csl::alloc_expr</definition>
        <argsstring></argsstring>
        <name>alloc_expr</name>
        <qualifiedname>csl::alloc_expr</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/typedef.h" line="58" column="21" bodyfile="src/csl/typedef.h" bodystart="58" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="func">
      <memberdef kind="function" id="namespacecsl_1a5ac8166422b67dcd7c666146df992916" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::compareString</definition>
        <argsstring>(std::string_view a, std::string_view b)</argsstring>
        <name>compareString</name>
        <qualifiedname>csl::compareString</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>a</declname>
        </param>
        <param>
          <type>std::string_view</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abreviation.cpp" line="33" column="6" bodyfile="src/csl/abreviation.cpp" bodystart="33" bodyend="42"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae3e6020bb11c2bca3af557d55457ab00" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t csl::dichoFinder</definition>
        <argsstring>(csl::Expr const &amp;expr, std::vector&lt; AbstractParent * &gt; const &amp;v)</argsstring>
        <name>dichoFinder</name>
        <qualifiedname>csl::dichoFinder</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1AbstractParent" kindref="compound">AbstractParent</ref> * &gt; const &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abreviation.cpp" line="44" column="8" bodyfile="src/csl/abreviation.cpp" bodystart="44" bodyend="77"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ac450778c481e6e7e87742817f1e48eb8" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt;</type>
        <definition>static std::vector&lt; csl::Expr &gt; csl::commonFactors</definition>
        <argsstring>(csl::Expr const &amp;prod1, csl::Expr const &amp;prod2)</argsstring>
        <name>commonFactors</name>
        <qualifiedname>csl::commonFactors</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>prod1</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>prod2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abreviation.cpp" line="199" column="20" bodyfile="src/csl/abreviation.cpp" bodystart="199" bodyend="224"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a6134d2c9b324d2f47e5f7c563b5feea6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::termWithoutExponent</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>termWithoutExponent</name>
        <qualifiedname>csl::termWithoutExponent</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abreviation.cpp" line="463" column="6" bodyfile="src/csl/abreviation.cpp" bodystart="463" bodyend="473"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a102a325a2f82091b8289d13e0b493d6b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; csl::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;fout, const Expr &amp;obj)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>csl::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>fout</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>obj</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.cpp" line="1234" column="1" bodyfile="src/csl/abstract.cpp" bodystart="1234" bodyend="1238" declfile="src/csl/abstract.h" declline="1578" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a4214d96bf84e933c268cf30c85ef5065" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::operator+</definition>
        <argsstring>(const Expr &amp;a, const Expr &amp;b)</argsstring>
        <name>operator+</name>
        <qualifiedname>csl::operator+</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Shortcut function that allows to use arithmetic operator + with <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> (== shared_ptr&lt;Abstract&gt;). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref>&amp; . </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref>&amp;. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The expression result of a+b. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.cpp" line="1262" column="6" bodyfile="src/csl/abstract.cpp" bodystart="1262" bodyend="1265" declfile="src/csl/abstract.h" declline="1462" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aeb03955fdcbb03fa6eee98de4da8d355" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::operator-</definition>
        <argsstring>(const Expr &amp;a)</argsstring>
        <name>operator-</name>
        <qualifiedname>csl::operator-</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.cpp" line="1267" column="6" bodyfile="src/csl/abstract.cpp" bodystart="1267" bodyend="1276" declfile="src/csl/abstract.h" declline="1464" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a8c85cf9cc27a2f9ea69c28fed0243a66" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::operator-</definition>
        <argsstring>(const Expr &amp;a, const Expr &amp;b)</argsstring>
        <name>operator-</name>
        <qualifiedname>csl::operator-</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Shortcut function that allows to use arithmetic operator - with <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> (== shared_ptr&lt;Abstract&gt;). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref>&amp;. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref>&amp;. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The expression result of a-b. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.cpp" line="1294" column="6" bodyfile="src/csl/abstract.cpp" bodystart="1294" bodyend="1297" declfile="src/csl/abstract.h" declline="1473" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a51da3cbce74c766bb1aff63488113698" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::operator*</definition>
        <argsstring>(const Expr &amp;a, const Expr &amp;b)</argsstring>
        <name>operator*</name>
        <qualifiedname>csl::operator*</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Shortcut function that allows to use arithmetic operator * with <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> (== shared_ptr&lt;Abstract&gt;). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref>&amp;. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref>&amp;. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The expression result of a*b. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.cpp" line="1315" column="6" bodyfile="src/csl/abstract.cpp" bodystart="1315" bodyend="1318" declfile="src/csl/abstract.h" declline="1482" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a75e84d94b9caf4662aa30a5c6aa36a63" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::operator/</definition>
        <argsstring>(const Expr &amp;a, const Expr &amp;b)</argsstring>
        <name>operator/</name>
        <qualifiedname>csl::operator/</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Shortcut function that allows to use arithmetic operator / with <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> (== shared_ptr&lt;Abstract&gt;). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref>&amp;. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref>&amp;. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The expression result of a/b. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.cpp" line="1336" column="6" bodyfile="src/csl/abstract.cpp" bodystart="1336" bodyend="1339" declfile="src/csl/abstract.h" declline="1491" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ac52343b89158d08dc27aa4851ba1662c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::operator==</definition>
        <argsstring>(const Expr &amp;a, const Expr &amp;b)</argsstring>
        <name>operator==</name>
        <qualifiedname>csl::operator==</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>see <ref refid="classcsl_1_1Abstract_1a8334e14cd5789168b037d3888ed60edd" kindref="member">Abstract::operator==()</ref> </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.cpp" line="1341" column="6" bodyfile="src/csl/abstract.cpp" bodystart="1341" bodyend="1344" declfile="src/csl/abstract.h" declline="1591" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a167623dea77c307c7f2c2d15f374c53b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::operator==</definition>
        <argsstring>(const Expr &amp;a, int b)</argsstring>
        <name>operator==</name>
        <qualifiedname>csl::operator==</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>int</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.cpp" line="1345" column="6" bodyfile="src/csl/abstract.cpp" bodystart="1345" bodyend="1348"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a73fc26b671ec2e0fa84ba12983ed9866" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::operator!=</definition>
        <argsstring>(const Expr &amp;a, const Expr &amp;b)</argsstring>
        <name>operator!=</name>
        <qualifiedname>csl::operator!=</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>see <ref refid="classcsl_1_1Abstract_1af5b62a6308638064c42da80e9cc2cb7e" kindref="member">Abstract::operator!=()</ref> </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.cpp" line="1349" column="6" bodyfile="src/csl/abstract.cpp" bodystart="1349" bodyend="1352" declfile="src/csl/abstract.h" declline="1595" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a919633543ba11b9ac77a3432c5c3d2a9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::operator!=</definition>
        <argsstring>(const Expr &amp;a, int b)</argsstring>
        <name>operator!=</name>
        <qualifiedname>csl::operator!=</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>int</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.cpp" line="1353" column="6" bodyfile="src/csl/abstract.cpp" bodystart="1353" bodyend="1356"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a372075ddeceed8352f66900e22151e71" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::operator!=</definition>
        <argsstring>(const Expr &amp;a, double b)</argsstring>
        <name>operator!=</name>
        <qualifiedname>csl::operator!=</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>double</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.cpp" line="1357" column="6" bodyfile="src/csl/abstract.cpp" bodystart="1357" bodyend="1360"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a64388fa8d8a566d1b1b565f888acfaa5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::operator&gt;=</definition>
        <argsstring>(const Expr &amp;a, const Expr &amp;b)</argsstring>
        <name>operator&gt;=</name>
        <qualifiedname>csl::operator&gt;=</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>see <ref refid="classcsl_1_1Abstract_1a4c8883df19d7538b68fa96aadac9dfa9" kindref="member">Abstract::operator&gt;=()</ref> </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.cpp" line="1361" column="6" bodyfile="src/csl/abstract.cpp" bodystart="1361" bodyend="1364" declfile="src/csl/abstract.h" declline="1599" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a612503ed45700a00e76eccfd796bfec1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::operator&lt;=</definition>
        <argsstring>(const Expr &amp;a, const Expr &amp;b)</argsstring>
        <name>operator&lt;=</name>
        <qualifiedname>csl::operator&lt;=</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>see Abstract::operator&lt;=() </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.cpp" line="1365" column="1" bodyfile="src/csl/abstract.cpp" bodystart="1365" bodyend="1368" declfile="src/csl/abstract.h" declline="1603" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1abdcf5895808d59f7113b9c9dc28133ca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::operator&gt;</definition>
        <argsstring>(const Expr &amp;a, const Expr &amp;b)</argsstring>
        <name>operator&gt;</name>
        <qualifiedname>csl::operator&gt;</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>see <ref refid="classcsl_1_1Abstract_1a485c6f3e10db539a70416cd0766b117d" kindref="member">Abstract::operator&gt;()</ref> </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.cpp" line="1369" column="6" bodyfile="src/csl/abstract.cpp" bodystart="1369" bodyend="1372" declfile="src/csl/abstract.h" declline="1607" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a6dbe8e8ea5d3a9880c2d95741728f8d1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::operator&lt;</definition>
        <argsstring>(const Expr &amp;a, const Expr &amp;b)</argsstring>
        <name>operator&lt;</name>
        <qualifiedname>csl::operator&lt;</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>see <ref refid="classcsl_1_1Abstract_1a5c1ba8dce7fbc19eb98807bd15a279c9" kindref="member">Abstract::operator&lt;()</ref> </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.cpp" line="1374" column="1" bodyfile="src/csl/abstract.cpp" bodystart="1374" bodyend="1385" declfile="src/csl/abstract.h" declline="1611" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1abd7b3dc67eefe314f598720f5b4b276e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::sum_s</definition>
        <argsstring>(const Expr &amp;leftOperand, const Expr &amp;rightOperand, bool explicitSum=false)</argsstring>
        <name>sum_s</name>
        <qualifiedname>csl::sum_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>leftOperand</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>rightOperand</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>explicitSum</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.cpp" line="944" column="6" bodyfile="src/csl/operations.cpp" bodystart="944" bodyend="992" declfile="src/csl/abstract.h" declline="1335" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae31a673dcb1a5958b4592cf0ee498836" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::sum_s</definition>
        <argsstring>(const csl::vector_expr &amp;operands, bool explicitSum=false)</argsstring>
        <name>sum_s</name>
        <qualifiedname>csl::sum_s</qualifiedname>
        <param>
          <type>const csl::vector_expr &amp;</type>
          <declname>operands</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>explicitSum</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.cpp" line="994" column="6" bodyfile="src/csl/operations.cpp" bodystart="994" bodyend="1019" declfile="src/csl/abstract.h" declline="1347" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa1186b8efe45b2ea34ffcf8e0de69238" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::minus_</definition>
        <argsstring>(const Expr &amp;leftOperand, const Expr &amp;rightOperand)</argsstring>
        <name>minus_</name>
        <qualifiedname>csl::minus_</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>leftOperand</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>rightOperand</declname>
        </param>
        <briefdescription>
<para>Returns the <bold>sum</bold> of the two operands (with a minus sign), applying basic simplifications. </para>
        </briefdescription>
        <detaileddescription>
<para>This function possibly returns an object different from a <ref refid="classcsl_1_1Sum" kindref="compound">Sum</ref> object if the simplification requires so. For example 0+x -&gt; x that is a <ref refid="classcsl_1_1Variable" kindref="compound">Variable</ref>. The Minus object does not exists, this function applies leftOperand + (-1*rightOperand). <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>leftOperand</parametername>
</parameternamelist>
<parameterdescription>
<para>Left operand. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rightOperand</parametername>
</parameternamelist>
<parameterdescription>
<para>Right operand. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The sum of <bold>leftOperand</bold> and <bold>rightOperand</bold>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.cpp" line="1021" column="6" bodyfile="src/csl/operations.cpp" bodystart="1021" bodyend="1027" declfile="src/csl/abstract.h" declline="1360" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae8a7809aa1495de26d449b25c5676215" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::prod_s</definition>
        <argsstring>(const Expr &amp;leftOperand, const Expr &amp;rightOperand, bool explicitProd=0)</argsstring>
        <name>prod_s</name>
        <qualifiedname>csl::prod_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>leftOperand</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>rightOperand</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>explicitProd</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Returns the <bold>product</bold> of the two operands, applying basic simplifications. </para>
        </briefdescription>
        <detaileddescription>
<para>This function possibly returns an object different from a <ref refid="classcsl_1_1Prod" kindref="compound">Prod</ref> object if the simplification requires so. For example 1*x -&gt; x that is a <ref refid="classcsl_1_1Variable" kindref="compound">Variable</ref>. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>leftOperand</parametername>
</parameternamelist>
<parameterdescription>
<para>Left operand. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rightOperand</parametername>
</parameternamelist>
<parameterdescription>
<para>Right operand. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>explicitProd</parametername>
</parameternamelist>
<parameterdescription>
<para>If <bold>true</bold> <ref refid="classcsl_1_1Prod_1a6fd5885a37a7e6492ec7777121e23944" kindref="member">Prod::mergeTerms()</ref> is not called and no simplification is done concerning the reordering/merging of terms. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The product of <bold>leftOperand</bold> and <bold>rightOperand</bold>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.cpp" line="2271" column="6" bodyfile="src/csl/operations.cpp" bodystart="2271" bodyend="2374" declfile="src/csl/abstract.h" declline="1375" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a3d9a2c8d0bab2f2157d4e10bad4b7e1a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::prod_s</definition>
        <argsstring>(const csl::vector_expr &amp;operands, bool explicitProd=false)</argsstring>
        <name>prod_s</name>
        <qualifiedname>csl::prod_s</qualifiedname>
        <param>
          <type>const csl::vector_expr &amp;</type>
          <declname>operands</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>explicitProd</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.cpp" line="2376" column="6" bodyfile="src/csl/operations.cpp" bodystart="2376" bodyend="2424" declfile="src/csl/abstract.h" declline="1387" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1adb8fb620d09d80258c0c3d0c2a72340a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::fraction_s</definition>
        <argsstring>(const Expr &amp;leftOperand, const Expr &amp;rightOperand)</argsstring>
        <name>fraction_s</name>
        <qualifiedname>csl::fraction_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>leftOperand</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>rightOperand</declname>
        </param>
        <briefdescription>
<para>Returns the <bold>fraction</bold> of the two operands, applying basic simplifications. </para>
        </briefdescription>
        <detaileddescription>
<para>This function possibly returns an object different from a Fraction object if the simplification requires so. For example 1/(x^(-1)) -&gt; x that is a <ref refid="classcsl_1_1Variable" kindref="compound">Variable</ref>.<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>leftOperand</parametername>
</parameternamelist>
<parameterdescription>
<para>Left operand.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rightOperand</parametername>
</parameternamelist>
<parameterdescription>
<para>Right operand. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The fraction of <bold>leftOperand</bold> and <bold>rightOperand</bold>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.cpp" line="2426" column="6" bodyfile="src/csl/operations.cpp" bodystart="2426" bodyend="2467" declfile="src/csl/abstract.h" declline="1397" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a39a4d5d0b5daeb571db05ae3bb2d36e4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::pow_s</definition>
        <argsstring>(const Expr &amp;leftOperand, const Expr &amp;rightOperand)</argsstring>
        <name>pow_s</name>
        <qualifiedname>csl::pow_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>leftOperand</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>rightOperand</declname>
        </param>
        <briefdescription>
<para>Returns the <bold>exponentiation</bold> of the two operands, applying basic simplifications. </para>
        </briefdescription>
        <detaileddescription>
<para>This function possibly returns an object different from a <ref refid="classcsl_1_1Pow" kindref="compound">Pow</ref> object if the simplification requires so. For example x^1 -&gt; x that is a <ref refid="classcsl_1_1Variable" kindref="compound">Variable</ref>.<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>leftOperand</parametername>
</parameternamelist>
<parameterdescription>
<para>Left operand.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rightOperand</parametername>
</parameternamelist>
<parameterdescription>
<para>Right operand. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The exponentiation of <bold>leftOperand</bold> and <bold>rightOperand</bold>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.cpp" line="3009" column="6" bodyfile="src/csl/operations.cpp" bodystart="3009" bodyend="3094" declfile="src/csl/abstract.h" declline="1407" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae48410b0af6a4bd2dad87736d44686b6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::sqrt_s</definition>
        <argsstring>(const Expr &amp;operand)</argsstring>
        <name>sqrt_s</name>
        <qualifiedname>csl::sqrt_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>operand</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.cpp" line="3096" column="6" bodyfile="src/csl/operations.cpp" bodystart="3096" bodyend="3099" declfile="src/csl/abstract.h" declline="1409" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae875bd5d5e88ada247048fcae0038e28" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::sqrt_s</definition>
        <argsstring>(int number)</argsstring>
        <name>sqrt_s</name>
        <qualifiedname>csl::sqrt_s</qualifiedname>
        <param>
          <type>int</type>
          <declname>number</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.cpp" line="3101" column="6" bodyfile="src/csl/operations.cpp" bodystart="3101" bodyend="3104" declfile="src/csl/abstract.h" declline="1411" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a34118703c2961443732bb747369f30ac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::derivative_s</definition>
        <argsstring>(const Expr &amp;leftOperand, const Expr &amp;rightOperand, int order=1)</argsstring>
        <name>derivative_s</name>
        <qualifiedname>csl::derivative_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>leftOperand</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>rightOperand</declname>
        </param>
        <param>
          <type>int</type>
          <declname>order</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
<para>Returns the <bold>derivative</bold> of <bold>leftOperand</bold> wrt <emphasis>rightOperand</emphasis>, applying basic simplifications. </para>
        </briefdescription>
        <detaileddescription>
<para>This function possibly returns an object different from a <ref refid="classcsl_1_1Derivative" kindref="compound">Derivative</ref> object if the simplification requires so. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>leftOperand</parametername>
</parameternamelist>
<parameterdescription>
<para>Left operand. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rightOperand</parametername>
</parameternamelist>
<parameterdescription>
<para>Right operand. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>order</parametername>
</parameternamelist>
<parameterdescription>
<para>Order of derivation. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The derivative of <bold>leftOperand</bold> wrt <bold>rightOperand</bold> at the order <bold>order</bold>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.cpp" line="3776" column="6" bodyfile="src/csl/operations.cpp" bodystart="3776" bodyend="3779" declfile="src/csl/abstract.h" declline="1426" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a16c2161a4b96c7320f872848dbbc45de" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::derivative_s</definition>
        <argsstring>(const Expr &amp;leftOperand, const Expr &amp;rightOperand, int order, bool empty)</argsstring>
        <name>derivative_s</name>
        <qualifiedname>csl::derivative_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>leftOperand</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>rightOperand</declname>
        </param>
        <param>
          <type>int</type>
          <declname>order</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>empty</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.cpp" line="3781" column="6" bodyfile="src/csl/operations.cpp" bodystart="3781" bodyend="3833" declfile="src/csl/abstract.h" declline="1429" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1accc24b8fdbab7510461f966c8e402ace" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::derivative_s</definition>
        <argsstring>(const Expr &amp;variable, int order=1)</argsstring>
        <name>derivative_s</name>
        <qualifiedname>csl::derivative_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>variable</declname>
        </param>
        <param>
          <type>int</type>
          <declname>order</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.cpp" line="3835" column="6" bodyfile="src/csl/operations.cpp" bodystart="3835" bodyend="3841" declfile="src/csl/abstract.h" declline="1434" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a59a24294df46f79dd1f36fc077da8290" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::integral_s</definition>
        <argsstring>(const Expr &amp;leftOperand, const Expr &amp;rightOperand)</argsstring>
        <name>integral_s</name>
        <qualifiedname>csl::integral_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>leftOperand</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>rightOperand</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.cpp" line="4164" column="6" bodyfile="src/csl/operations.cpp" bodystart="4164" bodyend="4174" declfile="src/csl/abstract.h" declline="1436" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a72374e371b9d4880ddbf0b2fa5e0f962" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::integral_s</definition>
        <argsstring>(const Expr &amp;leftOperand, const Expr &amp;rightOperand, bool empty)</argsstring>
        <name>integral_s</name>
        <qualifiedname>csl::integral_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>leftOperand</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>rightOperand</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>empty</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.cpp" line="4176" column="6" bodyfile="src/csl/operations.cpp" bodystart="4176" bodyend="4206" declfile="src/csl/abstract.h" declline="1437" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1acc352ce4f38d82849fd9fed8b92aa7e4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::integral_s</definition>
        <argsstring>(const Expr &amp;leftOperand, const Expr &amp;rightOperand, bool empty, const Expr &amp;t_inf, const Expr &amp;t_sup)</argsstring>
        <name>integral_s</name>
        <qualifiedname>csl::integral_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>leftOperand</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>rightOperand</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>empty</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>t_inf</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>t_sup</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.cpp" line="4208" column="6" bodyfile="src/csl/operations.cpp" bodystart="4208" bodyend="4235" declfile="src/csl/abstract.h" declline="1438" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1adf2fdc50f210a980e17772cf6686ab60" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::integral_s</definition>
        <argsstring>(const Expr &amp;variable)</argsstring>
        <name>integral_s</name>
        <qualifiedname>csl::integral_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>variable</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.cpp" line="4237" column="6" bodyfile="src/csl/operations.cpp" bodystart="4237" bodyend="4240" declfile="src/csl/abstract.h" declline="1443" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a30ed905708cee81a49d3bf327b7b5294" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::polynomial_s</definition>
        <argsstring>(const Expr &amp;expr, const Expr &amp;t_variable)</argsstring>
        <name>polynomial_s</name>
        <qualifiedname>csl::polynomial_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>t_variable</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.cpp" line="3577" column="6" bodyfile="src/csl/operations.cpp" bodystart="3577" bodyend="3589" declfile="src/csl/abstract.h" declline="1445" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a756632091cff18581c956afa8b070a6d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::polynomial_s</definition>
        <argsstring>(const csl::vector_expr &amp;operands, const Expr &amp;t_variable)</argsstring>
        <name>polynomial_s</name>
        <qualifiedname>csl::polynomial_s</qualifiedname>
        <param>
          <type>const csl::vector_expr &amp;</type>
          <declname>operands</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>t_variable</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.cpp" line="3591" column="6" bodyfile="src/csl/operations.cpp" bodystart="3591" bodyend="3595" declfile="src/csl/abstract.h" declline="1447" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a187485362620c294cc6cf77f797d07a7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::operator|=</definition>
        <argsstring>(const Expr &amp;a, const Expr &amp;b)</argsstring>
        <name>operator|=</name>
        <qualifiedname>csl::operator|=</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>see Abstract::operator|=() </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1615" column="6" declfile="src/csl/abstract.h" declline="1615" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae5f3a8cb78aea12f4d966effd040681b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::operator&amp;=</definition>
        <argsstring>(const Expr &amp;a, const Expr &amp;b)</argsstring>
        <name>operator&amp;=</name>
        <qualifiedname>csl::operator&amp;=</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>see Abstract::operator&amp;=() </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/abstract.h" line="1619" column="6" declfile="src/csl/abstract.h" declline="1619" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae25492ddb894bb646ca12868bbd5e54d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::FindLeaf</definition>
        <argsstring>(Expr const &amp;init, Expr const &amp;value, size_t depth=-1)</argsstring>
        <name>FindLeaf</name>
        <qualifiedname>csl::FindLeaf</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>value</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>depth</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Searches and returns an expression in another. </para>
        </briefdescription>
        <detaileddescription>
<para>If one of the leafs of <bold>init</bold> compares to <bold>value</bold> successfully the function returns it. Else it returns nullptr. Beware that in this case the result is invalid. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression in which the function searches. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>Sub-expression to find. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>depth</parametername>
</parameternamelist>
<parameterdescription>
<para>Depth of recursion in the search (default = -1, full recursion). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The first leaf to compare to <bold>value</bold> if found. </para>
</simplesect>
<simplesect kind="return"><para>nullptr else. </para>
</simplesect>
<simplesect kind="see"><para><ref refid="namespacecsl_1a16030249dd9a145214dad11c6c698c75" kindref="member">FindNode()</ref>, <ref refid="namespacecsl_1a27562270e1babd293920469862804ddf" kindref="member">FindIfLeaf()</ref>, <ref refid="namespacecsl_1af08b277cdb6f9d098af7640035563e5d" kindref="member">FindIfNode()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="22" column="6" bodyfile="src/csl/algo.cpp" bodystart="22" bodyend="36" declfile="src/csl/algo.h" declline="110" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a16030249dd9a145214dad11c6c698c75" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::FindNode</definition>
        <argsstring>(Expr const &amp;init, Expr const &amp;node, size_t depth=-1)</argsstring>
        <name>FindNode</name>
        <qualifiedname>csl::FindNode</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>node</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>depth</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Searches and returns an expression in another. </para>
        </briefdescription>
        <detaileddescription>
<para>If one of the nodes of <bold>init</bold> compares to <bold>value</bold> successfully the function returns it. Else it returns nullptr. Beware that in this case the result is invalid. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression in which the function searches. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>Sub-expression to find. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>depth</parametername>
</parameternamelist>
<parameterdescription>
<para>Depth of recursion in the search (default = -1, full recursion). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The first node to compare to <bold>value</bold> if found. </para>
</simplesect>
<simplesect kind="return"><para>nullptr else. </para>
</simplesect>
<simplesect kind="see"><para><ref refid="namespacecsl_1ae25492ddb894bb646ca12868bbd5e54d" kindref="member">FindLeaf()</ref>, <ref refid="namespacecsl_1af08b277cdb6f9d098af7640035563e5d" kindref="member">FindIfNode()</ref>, <ref refid="namespacecsl_1a27562270e1babd293920469862804ddf" kindref="member">FindIfLeaf()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="38" column="6" bodyfile="src/csl/algo.cpp" bodystart="38" bodyend="49" declfile="src/csl/algo.h" declline="125" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a27562270e1babd293920469862804ddf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::FindIfLeaf</definition>
        <argsstring>(Expr const &amp;init, std::function&lt; bool(Expr const &amp;)&gt; const &amp;f, size_t depth=-1)</argsstring>
        <name>FindIfLeaf</name>
        <qualifiedname>csl::FindIfLeaf</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>depth</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Searches and returns an expression in another. </para>
        </briefdescription>
        <detaileddescription>
<para>If one of the leafs of <bold>init</bold> compares to <bold>value</bold> successfully using the condition <bold>f</bold> given by the user the function returns it. Else it returns nullptr. Beware that in this case the result is invalid. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression in which the function searches. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>std::function (can be a c++ lambda expression) taking an <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> as parameter and returning a boolean. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>depth</parametername>
</parameternamelist>
<parameterdescription>
<para>Depth of recursion in the search (default = -1, full recursion). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The first leaf to respect the condition if found. </para>
</simplesect>
<simplesect kind="return"><para>nullptr else. </para>
</simplesect>
<simplesect kind="see"><para><ref refid="namespacecsl_1a16030249dd9a145214dad11c6c698c75" kindref="member">FindNode()</ref>, <ref refid="namespacecsl_1ae25492ddb894bb646ca12868bbd5e54d" kindref="member">FindLeaf()</ref>, <ref refid="namespacecsl_1af08b277cdb6f9d098af7640035563e5d" kindref="member">FindIfNode()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="51" column="6" bodyfile="src/csl/algo.cpp" bodystart="51" bodyend="67" declfile="src/csl/algo.h" declline="141" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af08b277cdb6f9d098af7640035563e5d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::FindIfNode</definition>
        <argsstring>(Expr const &amp;init, std::function&lt; bool(Expr const &amp;)&gt; const &amp;f, size_t depth=-1)</argsstring>
        <name>FindIfNode</name>
        <qualifiedname>csl::FindIfNode</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>depth</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Searches and returns an expression in another. </para>
        </briefdescription>
        <detaileddescription>
<para>If one of the nodes of <bold>init</bold> compares to <bold>value</bold> successfully using the condition <bold>f</bold> given by the user the function returns it. Else it returns nullptr. Beware that in this case the result is invalid. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression in which the function searches. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>std::function (can be a c++ lambda expression) taking an <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> as parameter and returning a boolean. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>depth</parametername>
</parameternamelist>
<parameterdescription>
<para>Depth of recursion in the search (default = -1, full recursion). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The first node to respect the condition if found. </para>
</simplesect>
<simplesect kind="return"><para>nullptr else. </para>
</simplesect>
<simplesect kind="see"><para><ref refid="namespacecsl_1a16030249dd9a145214dad11c6c698c75" kindref="member">FindNode()</ref>, <ref refid="namespacecsl_1ae25492ddb894bb646ca12868bbd5e54d" kindref="member">FindLeaf()</ref>, <ref refid="namespacecsl_1a27562270e1babd293920469862804ddf" kindref="member">FindIfLeaf()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="69" column="6" bodyfile="src/csl/algo.cpp" bodystart="69" bodyend="82" declfile="src/csl/algo.h" declline="159" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aaf13cdcb51d600be084f62a095edd5f1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::AnyOfLeafs</definition>
        <argsstring>(Expr_info init, std::function&lt; bool(Expr_info)&gt; const &amp;f, int depth)</argsstring>
        <name>AnyOfLeafs</name>
        <qualifiedname>csl::AnyOfLeafs</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref>)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="84" column="6" bodyfile="src/csl/algo.cpp" bodystart="84" bodyend="96" declfile="src/csl/algo.h" declline="181" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a0c725982c603dc7243b94238c7399f17" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::AnyOfLeafs</definition>
        <argsstring>(Expr const &amp;init, std::function&lt; bool(Expr const &amp;)&gt; const &amp;f, int depth=-1)</argsstring>
        <name>AnyOfLeafs</name>
        <qualifiedname>csl::AnyOfLeafs</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Tells if any of the leafs of an expression respect a certain condition given by the user. </para>
        </briefdescription>
        <detaileddescription>
<para>If one of the leafs of <bold>init</bold> respects the condition <bold>f</bold> given by the user the function returns <bold>true</bold>. Else it returns false. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression in which the function searches recursively. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>std::function (can be a c++ lambda expression) taking an <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const&amp; as parameter and returning a boolean. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>depth</parametername>
</parameternamelist>
<parameterdescription>
<para>Depth of recursion in the search (default = -1, full recursion). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if any of the leafs of <bold>init</bold> respects the condition <bold>f</bold>. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
<simplesect kind="see"><para>AllOfLeafs(), AnyOfNodes(), <ref refid="namespacecsl_1a2a09c25d95caf5531f593f5e8a92cc99" kindref="member">AllOfNodes()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="98" column="6" bodyfile="src/csl/algo.cpp" bodystart="98" bodyend="110" declfile="src/csl/algo.h" declline="178" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a55b235cd1c778b9c42c2ebca821a72a5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::AllOfLeafs</definition>
        <argsstring>(Expr_info init, std::function&lt; bool(Expr_info)&gt; const &amp;f, int depth)</argsstring>
        <name>AllOfLeafs</name>
        <qualifiedname>csl::AllOfLeafs</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref>)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="112" column="6" bodyfile="src/csl/algo.cpp" bodystart="112" bodyend="124" declfile="src/csl/algo.h" declline="203" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ab34e46d9db1bf2c52a11e16edb96aac9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::AllOfLeafs</definition>
        <argsstring>(Expr const &amp;init, std::function&lt; bool(Expr const &amp;)&gt; const &amp;f, int depth=-1)</argsstring>
        <name>AllOfLeafs</name>
        <qualifiedname>csl::AllOfLeafs</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Tells if all of the leafs of an expression respect a certain condition given by the user. </para>
        </briefdescription>
        <detaileddescription>
<para>If one of the leafs of <bold>init</bold> respects the condition <bold>f</bold> given by the user the function returns <bold>true</bold>. Else it returns false. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression in which the function searches recursively. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>std::function (can be a c++ lambda expression) taking an <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const&amp; as parameter and returning a boolean. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>depth</parametername>
</parameternamelist>
<parameterdescription>
<para>Depth of recursion in the search (default = -1, full recursion). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if all of the leafs of <bold>init</bold> respects the condition <bold>f</bold>. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
<simplesect kind="see"><para>AllOfLeafs(), AnyOfNodes(), <ref refid="namespacecsl_1a2a09c25d95caf5531f593f5e8a92cc99" kindref="member">AllOfNodes()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="126" column="6" bodyfile="src/csl/algo.cpp" bodystart="126" bodyend="138" declfile="src/csl/algo.h" declline="200" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1abb2cb3f543fae6574040a43db13496dd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::AnyOfNodes</definition>
        <argsstring>(Expr_info init, std::function&lt; bool(Expr_info)&gt; const &amp;f, int depth)</argsstring>
        <name>AnyOfNodes</name>
        <qualifiedname>csl::AnyOfNodes</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref>)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="140" column="6" bodyfile="src/csl/algo.cpp" bodystart="140" bodyend="152" declfile="src/csl/algo.h" declline="225" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aee4fb7f5bf59e525f167e3e5e1bea6ed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::AnyOfNodes</definition>
        <argsstring>(Expr const &amp;init, std::function&lt; bool(Expr const &amp;)&gt; const &amp;f, int depth=-1)</argsstring>
        <name>AnyOfNodes</name>
        <qualifiedname>csl::AnyOfNodes</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Tells if any of the nodes of an expression respect a certain condition given by the user. </para>
        </briefdescription>
        <detaileddescription>
<para>If one of the nodes of <bold>init</bold> respects the condition <bold>f</bold> given by the user the function returns <bold>true</bold>. Else it returns false. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression in which the function searches recursively. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>std::function (can be a c++ lambda expression) taking an <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const&amp; as parameter and returning a boolean. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>depth</parametername>
</parameternamelist>
<parameterdescription>
<para>Depth of recursion in the search (default = -1, full recursion). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if any of the nodes of <bold>init</bold> respects the condition <bold>f</bold>. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
<simplesect kind="see"><para>AllOfLeafs(), AnyOfLeafs(), <ref refid="namespacecsl_1a2a09c25d95caf5531f593f5e8a92cc99" kindref="member">AllOfNodes()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="154" column="6" bodyfile="src/csl/algo.cpp" bodystart="154" bodyend="166" declfile="src/csl/algo.h" declline="222" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2a09c25d95caf5531f593f5e8a92cc99" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::AllOfNodes</definition>
        <argsstring>(Expr const &amp;init, std::function&lt; bool(Expr const &amp;)&gt; const &amp;f, int depth=-1)</argsstring>
        <name>AllOfNodes</name>
        <qualifiedname>csl::AllOfNodes</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Tells if all of the nodes of an expression respect a certain condition given by the user. </para>
        </briefdescription>
        <detaileddescription>
<para>If one of the nodes of <bold>init</bold> respects the condition <bold>f</bold> given by the user the function returns <bold>true</bold>. Else it returns false. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression in which the function searches recursively. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>std::function (can be a c++ lambda expression) taking an <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const&amp; as parameter and returning a boolean. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>depth</parametername>
</parameternamelist>
<parameterdescription>
<para>Depth of recursion in the search (default = -1, full recursion). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if all of the nodes of <bold>init</bold> respects the condition <bold>f</bold>. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
<simplesect kind="see"><para>AllOfLeafs(), AnyOfNodes(), <ref refid="namespacecsl_1a2a09c25d95caf5531f593f5e8a92cc99" kindref="member">AllOfNodes()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="168" column="6" bodyfile="src/csl/algo.cpp" bodystart="168" bodyend="180" declfile="src/csl/algo.h" declline="244" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2c37153e6699f1ebab65c82250923470" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::AllOfNodes</definition>
        <argsstring>(Expr_info init, std::function&lt; bool(Expr_info)&gt; const &amp;f, int depth)</argsstring>
        <name>AllOfNodes</name>
        <qualifiedname>csl::AllOfNodes</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref>)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="182" column="6" bodyfile="src/csl/algo.cpp" bodystart="182" bodyend="194" declfile="src/csl/algo.h" declline="247" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ab32d8a121c108b533a4e746a10d737ba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::VisitEachNode</definition>
        <argsstring>(Expr const &amp;init, std::function&lt; void(Expr const &amp;)&gt; const &amp;f, int depth=-1)</argsstring>
        <name>VisitEachNode</name>
        <qualifiedname>csl::VisitEachNode</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; void(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Visits all nodes of an expression, applying a function on it without modifying it. </para>
        </briefdescription>
        <detaileddescription>
<para>This algorithm browses the whole expression applying <bold>f</bold> to each node. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to browse. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>std::function (can be a c++ lambda expression) taking an <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const&amp; as parameter and returning nothing. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>depth</parametername>
</parameternamelist>
<parameterdescription>
<para>Depth of recursion in the search (default = -1, full recursion). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="namespacecsl_1a795b923fd042a73265a04f5fa551362b" kindref="member">VisitEachLeaf()</ref>, <ref refid="namespacecsl_1abfb7fdd6c18bd8a98bfa3674e4bebefb" kindref="member">VisitEachNodeCut()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="196" column="6" bodyfile="src/csl/algo.cpp" bodystart="196" bodyend="205" declfile="src/csl/algo.h" declline="263" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a9387dec61549cd485817f99c60eb6785" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::VisitEachNodeReversed</definition>
        <argsstring>(Expr const &amp;init, std::function&lt; void(Expr const &amp;)&gt; const &amp;f, int depth)</argsstring>
        <name>VisitEachNodeReversed</name>
        <qualifiedname>csl::VisitEachNodeReversed</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; void(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="206" column="6" bodyfile="src/csl/algo.cpp" bodystart="206" bodyend="215" declfile="src/csl/algo.h" declline="266" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa4a4e6c1e35fc2325fe531f1d7f2d7c4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::VisitEachNode</definition>
        <argsstring>(Expr_info init, std::function&lt; void(Expr_info)&gt; const &amp;f, int depth)</argsstring>
        <name>VisitEachNode</name>
        <qualifiedname>csl::VisitEachNode</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; void(<ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref>)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="217" column="6" bodyfile="src/csl/algo.cpp" bodystart="217" bodyend="226" declfile="src/csl/algo.h" declline="269" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a795b923fd042a73265a04f5fa551362b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::VisitEachLeaf</definition>
        <argsstring>(Expr const &amp;init, std::function&lt; void(Expr const &amp;)&gt; const &amp;f, int depth=-1)</argsstring>
        <name>VisitEachLeaf</name>
        <qualifiedname>csl::VisitEachLeaf</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; void(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Visits all leafs of an expression, applying a function on it without modifying it. </para>
        </briefdescription>
        <detaileddescription>
<para>This algorithm browses all the leafs of <bold>init</bold> applying <bold>f</bold> each time. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to browse. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>std::function (can be a c++ lambda expression) taking an <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const&amp; as parameter and returning nothing. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>depth</parametername>
</parameternamelist>
<parameterdescription>
<para>Depth of recursion in the search (default = -1, full recursion). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="namespacecsl_1ab32d8a121c108b533a4e746a10d737ba" kindref="member">VisitEachNode()</ref>, <ref refid="namespacecsl_1abfb7fdd6c18bd8a98bfa3674e4bebefb" kindref="member">VisitEachNodeCut()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="228" column="6" bodyfile="src/csl/algo.cpp" bodystart="228" bodyend="238" declfile="src/csl/algo.h" declline="285" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a91cd0c53059c53927983b63fc172a44e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::VisitEachLeaf</definition>
        <argsstring>(Expr_info init, std::function&lt; void(Expr_info)&gt; const &amp;f, int depth)</argsstring>
        <name>VisitEachLeaf</name>
        <qualifiedname>csl::VisitEachLeaf</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; void(<ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref>)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="240" column="6" bodyfile="src/csl/algo.cpp" bodystart="240" bodyend="249" declfile="src/csl/algo.h" declline="288" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1abfb7fdd6c18bd8a98bfa3674e4bebefb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::VisitEachNodeCut</definition>
        <argsstring>(Expr const &amp;init, std::function&lt; bool(Expr const &amp;)&gt; const &amp;f, int depth=-1)</argsstring>
        <name>VisitEachNodeCut</name>
        <qualifiedname>csl::VisitEachNodeCut</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Visits all nodes of an expression, applying a function on it without modifying it. When the user function returns true on one node, the underlying branch (if there is) is not explored. </para>
        </briefdescription>
        <detaileddescription>
<para>This algorithm browses the whole expression applying <bold>f</bold> to each node. The user function must return a boolean. If true, the algorithm stops on the node (other branches are still explored). <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to browse. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>std::function (can be a c++ lambda expression) taking an <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const&amp; as parameter and returning a boolean telling if the algorithm must stop on that branch. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>depth</parametername>
</parameternamelist>
<parameterdescription>
<para>Depth of recursion in the search (default = -1, full recursion). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="namespacecsl_1a795b923fd042a73265a04f5fa551362b" kindref="member">VisitEachLeaf()</ref>, <ref refid="namespacecsl_1ab32d8a121c108b533a4e746a10d737ba" kindref="member">VisitEachNode()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="251" column="6" bodyfile="src/csl/algo.cpp" bodystart="251" bodyend="261" declfile="src/csl/algo.h" declline="307" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a38f44fa14ec2655e68f00564d363b3f4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::VisitEachNodeCut</definition>
        <argsstring>(Expr_info init, std::function&lt; bool(Expr_info)&gt; const &amp;f, int depth)</argsstring>
        <name>VisitEachNodeCut</name>
        <qualifiedname>csl::VisitEachNodeCut</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref>)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="263" column="6" bodyfile="src/csl/algo.cpp" bodystart="263" bodyend="273" declfile="src/csl/algo.h" declline="310" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2ab79a115fe13684aa9e8a242d694c2e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::isUnique</definition>
        <argsstring>(csl::Expr const &amp;expr)</argsstring>
        <name>isUnique</name>
        <qualifiedname>csl::isUnique</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="275" column="6" bodyfile="src/csl/algo.cpp" bodystart="275" bodyend="279" declfile="src/csl/algo.h" declline="314" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a43b43fd79b22d4b6f70c7d3cdfbdfa72" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t csl::Count</definition>
        <argsstring>(csl::Expr const &amp;expr, csl::Expr const &amp;search)</argsstring>
        <name>Count</name>
        <qualifiedname>csl::Count</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>search</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="281" column="8" bodyfile="src/csl/algo.cpp" bodystart="281" bodyend="289" declfile="src/csl/algo.h" declline="316" declcolumn="8"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a098cbe648edc96f8f3ea4a51e2523355" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t csl::CountIf</definition>
        <argsstring>(csl::Expr const &amp;expr, std::function&lt; bool(csl::Expr const &amp;)&gt; const &amp;f)</argsstring>
        <name>CountIf</name>
        <qualifiedname>csl::CountIf</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="291" column="8" bodyfile="src/csl/algo.cpp" bodystart="291" bodyend="300" declfile="src/csl/algo.h" declline="317" declcolumn="8"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2fdfd4deca9af45148ef80e0131fde7c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t csl::CountNodes</definition>
        <argsstring>(Expr const &amp;init)</argsstring>
        <name>CountNodes</name>
        <qualifiedname>csl::CountNodes</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="302" column="8" bodyfile="src/csl/algo.cpp" bodystart="302" bodyend="308" declfile="src/csl/algo.h" declline="320" declcolumn="8"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a48fbbfa111563d02abbe3b451e61d5d7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t csl::CountLeafs</definition>
        <argsstring>(Expr const &amp;init)</argsstring>
        <name>CountLeafs</name>
        <qualifiedname>csl::CountLeafs</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="309" column="8" bodyfile="src/csl/algo.cpp" bodystart="309" bodyend="315" declfile="src/csl/algo.h" declline="321" declcolumn="8"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a8bbe21d8979e1d4fa2e9242a34c397be" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::ForEachNode</definition>
        <argsstring>(Expr &amp;init, std::function&lt; void(Expr &amp;)&gt; const &amp;f, int depth=-1)</argsstring>
        <name>ForEachNode</name>
        <qualifiedname>csl::ForEachNode</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; void(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Applies a user function on each node of an expression. The expression may be modified. </para>
        </briefdescription>
        <detaileddescription>
<para>This algorithm browses the whole expression applying <bold>f</bold> to each node. If the user function <bold>f</bold> does not modify the nodes, consider using <ref refid="namespacecsl_1ab32d8a121c108b533a4e746a10d737ba" kindref="member">VisitEachNode()</ref> instead. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to browse. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>std::function (can be a c++ lambda expression) taking an <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref>&amp; (may or may not modify it) as parameter. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>depth</parametername>
</parameternamelist>
<parameterdescription>
<para>Depth of recursion in the search (default = -1, full recursion). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="namespacecsl_1af74bfbc9faa2de7d49f5d37403795b73" kindref="member">ForEachLeaf()</ref>, <ref refid="namespacecsl_1af1844d0ef7e9f50ccd490096c4f1ff21" kindref="member">ForEachNodeCut()</ref>, <ref refid="namespacecsl_1aba0af68b54eefa2d567faed146678ad7" kindref="member">Transform()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="317" column="6" bodyfile="src/csl/algo.cpp" bodystart="317" bodyend="324" declfile="src/csl/algo.h" declline="336" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a20b42dc1f196e4836cd8c08cdaf204b4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::ForEachNodeReversed</definition>
        <argsstring>(Expr &amp;init, std::function&lt; void(Expr &amp;)&gt; const &amp;f, int depth)</argsstring>
        <name>ForEachNodeReversed</name>
        <qualifiedname>csl::ForEachNodeReversed</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; void(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="326" column="6" bodyfile="src/csl/algo.cpp" bodystart="326" bodyend="335" declfile="src/csl/algo.h" declline="339" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af1844d0ef7e9f50ccd490096c4f1ff21" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::ForEachNodeCut</definition>
        <argsstring>(Expr &amp;init, std::function&lt; bool(Expr &amp;)&gt; const &amp;f, int depth=-1)</argsstring>
        <name>ForEachNodeCut</name>
        <qualifiedname>csl::ForEachNodeCut</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Applies a user function on each node of an expression. The expression may be modified. </para>
        </briefdescription>
        <detaileddescription>
<para>This algorithm browses the whole expression applying <bold>f</bold> to each node. If the user function <bold>f</bold> does not modify the nodes, consider using <ref refid="namespacecsl_1abfb7fdd6c18bd8a98bfa3674e4bebefb" kindref="member">VisitEachNodeCut()</ref> instead. The user function must return a boolean. If true, the algorithm stops on the node (other branches are still explored). <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to browse. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>std::function (can be a c++ lambda expression) taking an <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref>&amp; (may or may not modify it) as parameter. Must return a boolean that tells if the algorithm must stop to search in that branch, if that boolean is true. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>depth</parametername>
</parameternamelist>
<parameterdescription>
<para>Depth of recursion in the search (default = -1, full recursion). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="namespacecsl_1af74bfbc9faa2de7d49f5d37403795b73" kindref="member">ForEachLeaf()</ref>, <ref refid="namespacecsl_1a8bbe21d8979e1d4fa2e9242a34c397be" kindref="member">ForEachNode()</ref>, <ref refid="namespacecsl_1abfb7fdd6c18bd8a98bfa3674e4bebefb" kindref="member">VisitEachNodeCut()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="337" column="6" bodyfile="src/csl/algo.cpp" bodystart="337" bodyend="347" declfile="src/csl/algo.h" declline="377" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af74bfbc9faa2de7d49f5d37403795b73" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::ForEachLeaf</definition>
        <argsstring>(Expr &amp;init, std::function&lt; void(Expr &amp;)&gt; const &amp;f, int depth=-1)</argsstring>
        <name>ForEachLeaf</name>
        <qualifiedname>csl::ForEachLeaf</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; void(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Applies a user function on each leaf of an expression. The expression may be modified. </para>
        </briefdescription>
        <detaileddescription>
<para>This algorithm browses the whole expression applying <bold>f</bold> to each leaf. If the user function <bold>f</bold> does not modify the leafs, consider using <ref refid="namespacecsl_1a795b923fd042a73265a04f5fa551362b" kindref="member">VisitEachLeaf()</ref> instead. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to browse. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>std::function (can be a c++ lambda expression) taking an <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref>&amp; (may or may not modify it) as parameter. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>depth</parametername>
</parameternamelist>
<parameterdescription>
<para>Depth of recursion in the search (default = -1, full recursion). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="namespacecsl_1a8bbe21d8979e1d4fa2e9242a34c397be" kindref="member">ForEachNode()</ref>, <ref refid="namespacecsl_1af1844d0ef7e9f50ccd490096c4f1ff21" kindref="member">ForEachNodeCut()</ref>, <ref refid="namespacecsl_1aba0af68b54eefa2d567faed146678ad7" kindref="member">Transform()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="349" column="6" bodyfile="src/csl/algo.cpp" bodystart="349" bodyend="357" declfile="src/csl/algo.h" declline="356" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a6308a8941a535c68087d65491090bab5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::ForEachNode</definition>
        <argsstring>(std::vector&lt; Expr &gt; init, std::function&lt; void(Expr &amp;)&gt; const &amp;f, int depth)</argsstring>
        <name>ForEachNode</name>
        <qualifiedname>csl::ForEachNode</qualifiedname>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; void(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="359" column="6" bodyfile="src/csl/algo.cpp" bodystart="359" bodyend="366"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ac5e1717ab07ae5bf9bbc6482c9c31717" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::ForEachLeaf</definition>
        <argsstring>(std::vector&lt; Expr &gt; init, std::function&lt; void(Expr &amp;)&gt; const &amp;f, int depth)</argsstring>
        <name>ForEachLeaf</name>
        <qualifiedname>csl::ForEachLeaf</qualifiedname>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; void(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="368" column="6" bodyfile="src/csl/algo.cpp" bodystart="368" bodyend="375"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1abe86be4e2295c35823a965faf12bb0c7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::FirstOfNode</definition>
        <argsstring>(Expr &amp;init, std::function&lt; bool(Expr &amp;)&gt; const &amp;f)</argsstring>
        <name>FirstOfNode</name>
        <qualifiedname>csl::FirstOfNode</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Tells if any of the nodes of an expression respect a certain condition given by the user. The condition function may apply on the go on the expression found. </para>
        </briefdescription>
        <detaileddescription>
<para>If one of the nodes of <bold>init</bold> respects the condition <bold>f</bold> given by the user the function returns <bold>true</bold>. Else it returns false. Once one node has been found, the function stops completely. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression in which the function searches recursively. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>std::function (can be a c++ lambda expression) taking an <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref>&amp; as parameter and returning a boolean. May modify the content of the expression. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if any of the nodes of <bold>init</bold> respects the condition <bold>f</bold>. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
<simplesect kind="see"><para><ref refid="namespacecsl_1af9f72de45510b266cb259a69d11cbf14" kindref="member">FirstOfLeaf()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="377" column="6" bodyfile="src/csl/algo.cpp" bodystart="377" bodyend="385" declfile="src/csl/algo.h" declline="397" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af9f72de45510b266cb259a69d11cbf14" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::FirstOfLeaf</definition>
        <argsstring>(Expr &amp;init, std::function&lt; bool(Expr &amp;)&gt; const &amp;f)</argsstring>
        <name>FirstOfLeaf</name>
        <qualifiedname>csl::FirstOfLeaf</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Tells if any of the leafs of an expression respect a certain condition given by the user. The condition function may apply on the go on the expression found. </para>
        </briefdescription>
        <detaileddescription>
<para>If one of the leafs of <bold>init</bold> respects the condition <bold>f</bold> given by the user the function returns <bold>true</bold>. Else it returns false. Once one node has been found, the function stops completely. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression in which the function searches recursively. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>std::function (can be a c++ lambda expression) taking an <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref>&amp; as parameter and returning a boolean. May modify the content of the expression. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if any of the leafs of <bold>init</bold> respects the condition <bold>f</bold>. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
<simplesect kind="see"><para><ref refid="namespacecsl_1af9f72de45510b266cb259a69d11cbf14" kindref="member">FirstOfLeaf()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="387" column="6" bodyfile="src/csl/algo.cpp" bodystart="387" bodyend="395" declfile="src/csl/algo.h" declline="415" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1add3c68b0e699dd64609a968ea0556b64" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::VisitFirstOfNode</definition>
        <argsstring>(Expr const &amp;init, std::function&lt; bool(Expr const &amp;)&gt; const &amp;f)</argsstring>
        <name>VisitFirstOfNode</name>
        <qualifiedname>csl::VisitFirstOfNode</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="397" column="6" bodyfile="src/csl/algo.cpp" bodystart="397" bodyend="406" declfile="src/csl/algo.h" declline="417" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a705f9b5d9ecdebdc35d89cf30fab41cb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::VisitFirstOfLeaf</definition>
        <argsstring>(Expr const &amp;init, std::function&lt; bool(Expr const &amp;)&gt; const &amp;f)</argsstring>
        <name>VisitFirstOfLeaf</name>
        <qualifiedname>csl::VisitFirstOfLeaf</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="408" column="6" bodyfile="src/csl/algo.cpp" bodystart="408" bodyend="417" declfile="src/csl/algo.h" declline="419" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aba0af68b54eefa2d567faed146678ad7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::Transform</definition>
        <argsstring>(Expr &amp;init, std::function&lt; bool(Expr &amp;)&gt; const &amp;f, int depth=-1)</argsstring>
        <name>Transform</name>
        <qualifiedname>csl::Transform</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Applies a user function on each node of an expression. The expression may be modified. If it is, the expression is refreshed. </para>
        </briefdescription>
        <detaileddescription>
<para>This algorithm browses the whole expression applying <bold>f</bold> to each node. The user function must return true if the expression has to be refreshed after the transformation, false else. If you do not want to refresh the expression (powerful but heavy) consider using <ref refid="namespacecsl_1a8bbe21d8979e1d4fa2e9242a34c397be" kindref="member">ForEachNode()</ref> instead. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to browse. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>std::function (can be a c++ lambda expression) taking an <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref>&amp; (may or may not modify it) as parameter. Must return a boolean, true if the expression requires a refresh after the call, false else. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>depth</parametername>
</parameternamelist>
<parameterdescription>
<para>Depth of recursion in the search (default = -1, full recursion). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="namespacecsl_1a8bbe21d8979e1d4fa2e9242a34c397be" kindref="member">ForEachNode()</ref>, <ref refid="namespacecsl_1a9c5e3c2f5f4c6533ac74d150d29f931d" kindref="member">Refreshed()</ref>, <ref refid="namespacecsl_1ae95bf5940e1dda061d2d9fbdd1a9fff8" kindref="member">DeepRefreshed()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/algo.cpp" line="419" column="6" bodyfile="src/csl/algo.cpp" bodystart="419" bodyend="430" declfile="src/csl/algo.h" declline="438" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a39a8b70c168fe5d94046cf62d41f997a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>csl::allocator&lt; T &gt; &amp;</type>
            <declname>pool</declname>
            <defname>pool</defname>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classstd_1_1shared__ptr" kindref="compound">std::shared_ptr</ref>&lt; T &gt;</type>
        <definition>std::shared_ptr&lt; T &gt; csl::make_shared</definition>
        <argsstring>(Args &amp;&amp;...args)</argsstring>
        <name>make_shared</name>
        <qualifiedname>csl::make_shared</qualifiedname>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/allocator.h" line="32" column="24" bodyfile="src/csl/allocator.h" bodystart="32" bodyend="36"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1acee86c643f3f4dfc6e17c610ced47abb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classstd_1_1shared__ptr" kindref="compound">std::shared_ptr</ref>&lt; T &gt;</type>
        <definition>std::shared_ptr&lt; T &gt; csl::make_shared</definition>
        <argsstring>(Args &amp;&amp;...args)</argsstring>
        <name>make_shared</name>
        <qualifiedname>csl::make_shared</qualifiedname>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/allocator.h" line="39" column="24" bodyfile="src/csl/allocator.h" bodystart="39" bodyend="42"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ab1f635b6bb39cc152780bde7e635d296" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref></type>
        <definition>csl::Expr csl::booleanOperator_s</definition>
        <argsstring>(BooleanOperator::Type type, csl::Expr const &amp;A, csl::Expr const &amp;B, csl::Expr const &amp;ifTrue, csl::Expr const &amp;ifFalse)</argsstring>
        <name>booleanOperator_s</name>
        <qualifiedname>csl::booleanOperator_s</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1BooleanOperator_1a12f3f98c065fe964a43a49bb636e71df" kindref="member">BooleanOperator::Type</ref></type>
          <declname>type</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>B</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>ifTrue</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>ifFalse</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/booleanOperators.cpp" line="279" column="11" bodyfile="src/csl/booleanOperators.cpp" bodystart="279" bodyend="298" declfile="src/csl/booleanOperators.h" declline="108" declcolumn="11"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a574b3fa10ac8c501b492c006999bda22" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref></type>
        <definition>csl::Expr csl::booleanOperator_s</definition>
        <argsstring>(BooleanOperator::Type type, csl::Expr const &amp;A, csl::Expr const &amp;ifTrue, csl::Expr const &amp;ifFalse)</argsstring>
        <name>booleanOperator_s</name>
        <qualifiedname>csl::booleanOperator_s</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1BooleanOperator_1a12f3f98c065fe964a43a49bb636e71df" kindref="member">BooleanOperator::Type</ref></type>
          <declname>type</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>ifTrue</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>ifFalse</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/booleanOperators.cpp" line="300" column="11" bodyfile="src/csl/booleanOperators.cpp" bodystart="300" bodyend="312" declfile="src/csl/booleanOperators.h" declline="114" declcolumn="11"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a88bdab2379328b9230b8b73942d43bce" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; csl::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, BooleanOperator::Type type)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>csl::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1BooleanOperator_1a12f3f98c065fe964a43a49bb636e71df" kindref="member">BooleanOperator::Type</ref></type>
          <declname>type</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/booleanOperators.cpp" line="314" column="1" bodyfile="src/csl/booleanOperators.cpp" bodystart="314" bodyend="345" declfile="src/csl/booleanOperators.h" declline="119" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a522b81a0fa7f75a9a3fc2c8ed87f77b0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T csl::pointer_to_object</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>pointer_to_object</name>
        <qualifiedname>csl::pointer_to_object</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/cast.h" line="35" column="3" bodyfile="src/csl/cast.h" bodystart="35" bodyend="45"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a3c543ad034cdfcbdd9e9f6700b3e7cdd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T &amp;</type>
        <definition>T &amp; csl::pointer_to_object_ref</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>pointer_to_object_ref</name>
        <qualifiedname>csl::pointer_to_object_ref</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/cast.h" line="48" column="3" bodyfile="src/csl/cast.h" bodystart="48" bodyend="55"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ada5ca4f6345837d88114801d0692ad13" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T *</type>
        <definition>T * csl::shared_to_raw_ptr</definition>
        <argsstring>(const Expr_c &amp;expr)</argsstring>
        <name>shared_to_raw_ptr</name>
        <qualifiedname>csl::shared_to_raw_ptr</qualifiedname>
        <param>
          <type>const <ref refid="classstd_1_1shared__ptr" kindref="compound">Expr_c</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/cast.h" line="58" column="3" bodyfile="src/csl/cast.h" bodystart="58" bodyend="65"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae8c56f082158a750761820590c87182d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::object_to_shared</definition>
        <argsstring>(T &amp;csl_expr)</argsstring>
        <name>object_to_shared</name>
        <qualifiedname>csl::object_to_shared</qualifiedname>
        <param>
          <type>T &amp;</type>
          <declname>csl_expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/cast.h" line="68" column="6" bodyfile="src/csl/cast.h" bodystart="68" bodyend="73"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a15620d82e51a1ba2c082a0b17ed773d0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Commutation</definition>
        <argsstring>(const Expr &amp;A, const Expr &amp;B, int sign=-1)</argsstring>
        <name>Commutation</name>
        <qualifiedname>csl::Commutation</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>B</declname>
        </param>
        <param>
          <type>int</type>
          <declname>sign</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Returns the result of the (anit-)commutation of <bold>A</bold> and <bold>B</bold>. In most cases it returns CSL_0, and returns CSL_UNDEF else. Useful to test if two objects commute. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>Left hand side. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>Right hand side. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sign</parametername>
</parameternamelist>
<parameterdescription>
<para>Sign of the commutator, -1 for commutation (default), 1 for anti-commutation.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>CSL_0 if <bold>A</bold> and <bold>B</bold> commute. </para>
</simplesect>
<simplesect kind="return"><para>CSL_UNDEF else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/commutation.cpp" line="27" column="6" bodyfile="src/csl/commutation.cpp" bodystart="27" bodyend="52" declfile="src/csl/commutation.h" declline="43" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a82ce2b8172929e5bddcc1ff6140e9ab1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Commutation</definition>
        <argsstring>(Expr_info A, Expr_info B, int)</argsstring>
        <name>Commutation</name>
        <qualifiedname>csl::Commutation</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>B</declname>
        </param>
        <param>
          <type>int</type>
          <defname>sign</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/commutation.cpp" line="54" column="6" bodyfile="src/csl/commutation.cpp" bodystart="54" bodyend="57" declfile="src/csl/commutation.h" declline="45" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ab82c5a52247dd5ef84518d51deade500" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::WeakCommutation</definition>
        <argsstring>(const Expr &amp;A, const Expr &amp;B, int sign=-1)</argsstring>
        <name>WeakCommutation</name>
        <qualifiedname>csl::WeakCommutation</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>B</declname>
        </param>
        <param>
          <type>int</type>
          <declname>sign</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Returns the result of the (anit-)commutation of <bold>A</bold> and <bold>B</bold>. In most cases it returns CSL_0, and returns CSL_UNDEF else. Useful to test if two objects commute. In the special of this function, <bold>A</bold> is an object that is not commutable (attribute Abstract::commutable) and <bold>B</bold> is commutable. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>Left hand side. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>Right hand side. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sign</parametername>
</parameternamelist>
<parameterdescription>
<para>Sign of the commutator, -1 for commutation (default), 1 for anti-commutation.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>CSL_0 if <bold>A</bold> and <bold>B</bold> commute. </para>
</simplesect>
<simplesect kind="return"><para>CSL_UNDEF else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/commutation.cpp" line="59" column="6" bodyfile="src/csl/commutation.cpp" bodystart="59" bodyend="93" declfile="src/csl/commutation.h" declline="61" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa34083eab2ec8fcc6fddc34478a03558" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::WeakCommutation</definition>
        <argsstring>(Expr_info A, Expr_info B, int)</argsstring>
        <name>WeakCommutation</name>
        <qualifiedname>csl::WeakCommutation</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>B</declname>
        </param>
        <param>
          <type>int</type>
          <defname>sign</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/commutation.cpp" line="95" column="6" bodyfile="src/csl/commutation.cpp" bodystart="95" bodyend="98" declfile="src/csl/commutation.h" declline="63" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1afa314ac9077b2d18a81fa954327ab7e0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::commutator_</definition>
        <argsstring>(const Expr &amp;A, const Expr &amp;B, int t_sign=-1)</argsstring>
        <name>commutator_</name>
        <qualifiedname>csl::commutator_</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>B</declname>
        </param>
        <param>
          <type>int</type>
          <declname>t_sign</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Tries to create a <ref refid="classcsl_1_1Commutator" kindref="compound">Commutator</ref> object of <bold>A</bold> and <bold>B</bold> of sign <bold>sign</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para>If the result is CSL_0, this function returns CSL_0. If <bold>A</bold> and/or <bold>B</bold> are products, the functions expands the give at the end a more complicated expression but with just (anti-)commutators of single elements, expressions of type [{E,F}] with E and F neither sums nor products.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>Left hand side of the <ref refid="classcsl_1_1Commutator" kindref="compound">Commutator</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>Right hand side of the <ref refid="classcsl_1_1Commutator" kindref="compound">Commutator</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>t_sign</parametername>
</parameternamelist>
<parameterdescription>
<para>Sign of the <ref refid="classcsl_1_1Commutator" kindref="compound">Commutator</ref>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[A,B] (or {A,B}) if the result is not defined (in particular not CSL_0). </para>
</simplesect>
<simplesect kind="return"><para>The result of [A,B] (or {A,B}) if there is special things to do. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/commutation.cpp" line="237" column="6" bodyfile="src/csl/commutation.cpp" bodystart="237" bodyend="311" declfile="src/csl/commutation.h" declline="153" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aca518d3d156e148b3068c5b798ba1482" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::real_s</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>real_s</name>
        <qualifiedname>csl::real_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/cslcomplex.cpp" line="189" column="6" bodyfile="src/csl/cslcomplex.cpp" bodystart="189" bodyend="196" declfile="src/csl/cslcomplex.h" declline="131" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af79d8ae0341a0930abaa513affc9dde0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::imaginary_s</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>imaginary_s</name>
        <qualifiedname>csl::imaginary_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/cslcomplex.cpp" line="363" column="6" bodyfile="src/csl/cslcomplex.cpp" bodystart="363" bodyend="370" declfile="src/csl/cslcomplex.h" declline="133" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa11d004a0fbfd2cf7d41c1aebfbb5c1d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::cconjugate_</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>cconjugate_</name>
        <qualifiedname>csl::cconjugate_</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/cslcomplex.cpp" line="372" column="6" bodyfile="src/csl/cslcomplex.cpp" bodystart="372" bodyend="375" declfile="src/csl/cslcomplex.h" declline="135" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a0b217a885c5f55d9f9d65da07a1243a9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::findCommonFactor</definition>
        <argsstring>(std::vector&lt; Expr * &gt; const &amp;expressions)</argsstring>
        <name>findCommonFactor</name>
        <qualifiedname>csl::findCommonFactor</qualifiedname>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> * &gt; const &amp;</type>
          <declname>expressions</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/diagonalization.cpp" line="159" column="6" bodyfile="src/csl/diagonalization.cpp" bodystart="159" bodyend="226"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae69cdb1c6ddfa666c766cd2edf66823e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Iterator</type>
          </param>
          <param>
            <type>class Comparator</type>
          </param>
        </templateparamlist>
        <type>Iterator</type>
        <definition>Iterator csl::dichotomyFindIf</definition>
        <argsstring>(Iterator first, Iterator last, Comparator &amp;&amp;f)</argsstring>
        <name>dichotomyFindIf</name>
        <qualifiedname>csl::dichotomyFindIf</qualifiedname>
        <param>
          <type>Iterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>last</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Comparator" kindref="compound">Comparator</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Template dichotomy algorithm using a comparator. </para>
        </briefdescription>
        <detaileddescription>
<para>For the insertion of an element e, the comparator given must take one argument (of the same type as the range&apos;s elements) and return +1 if the element to insert is <bold>simpler</bold> than the argument, -1 if it is <bold>less simple</bold>, and 0 otherwise.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Iterator</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername><ref refid="classcsl_1_1Comparator" kindref="compound">Comparator</ref></parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Comparator" kindref="compound">Comparator</ref> type. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>First iterator in the range. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Last iterator in the range. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Comparator" kindref="compound">Comparator</ref> function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The iterator where the element compared with $$f$$ must be inserted. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/dichotomy.h" line="22" column="10" bodyfile="src/csl/dichotomy.h" bodystart="22" bodyend="44"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a3ae0f79c06f6d9ee116594b70e862633" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ostream &amp;</type>
        <definition>ostream &amp; csl::operator&lt;&lt;</definition>
        <argsstring>(ostream &amp;fout, csl::Type type)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>csl::operator&lt;&lt;</qualifiedname>
        <param>
          <type>ostream &amp;</type>
          <declname>fout</declname>
        </param>
        <param>
          <type><ref refid="namespacecsl_1ace591865c69b6315c533a1a325777312" kindref="member">csl::Type</ref></type>
          <declname>type</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/enum.cpp" line="22" column="1" bodyfile="src/csl/enum.cpp" bodystart="22" bodyend="155"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae88558ef1cc387019165f7ed6c033e8a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ostream &amp;</type>
        <definition>ostream &amp; csl::operator&lt;&lt;</definition>
        <argsstring>(ostream &amp;fout, csl::PrimaryType primaryType)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>csl::operator&lt;&lt;</qualifiedname>
        <param>
          <type>ostream &amp;</type>
          <declname>fout</declname>
        </param>
        <param>
          <type><ref refid="namespacecsl_1a70046459ec0082db8cb97005c13c9a54" kindref="member">csl::PrimaryType</ref></type>
          <declname>primaryType</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/enum.cpp" line="157" column="1" bodyfile="src/csl/enum.cpp" bodystart="157" bodyend="192"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ab2f0c75f3e501b2ff4c2ac4e8ae3ef3f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; csl::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;fout, csl::Type type)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>csl::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>fout</declname>
        </param>
        <param>
          <type><ref refid="namespacecsl_1ace591865c69b6315c533a1a325777312" kindref="member">csl::Type</ref></type>
          <declname>type</declname>
        </param>
        <briefdescription>
<para>Displays the name of a given <ref refid="namespacecsl_1ace591865c69b6315c533a1a325777312" kindref="member">csl::Type</ref> in order to be readable. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fout</parametername>
</parameternamelist>
<parameterdescription>
<para>Out stream in which the type is send. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>type</parametername>
</parameternamelist>
<parameterdescription>
<para>Type to display. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>fout</bold> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/enum.h" line="121" column="1" declfile="src/csl/enum.h" declline="121" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa69a4eeb7c9aeaa25066a9afbc2e72ba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; csl::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;fout, csl::PrimaryType primaryType)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>csl::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>fout</declname>
        </param>
        <param>
          <type><ref refid="namespacecsl_1a70046459ec0082db8cb97005c13c9a54" kindref="member">csl::PrimaryType</ref></type>
          <declname>primaryType</declname>
        </param>
        <briefdescription>
<para>Displays the name of a given <ref refid="namespacecsl_1a70046459ec0082db8cb97005c13c9a54" kindref="member">csl::PrimaryType</ref> in order to be readable. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fout</parametername>
</parameternamelist>
<parameterdescription>
<para>Out stream in which the type is send. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>type</parametername>
</parameternamelist>
<parameterdescription>
<para>PrimaryType to display. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>fout</bold> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/enum.h" line="128" column="1" declfile="src/csl/enum.h" declline="128" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a0e95d5ad3b90520d3cee7800e6bf45fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class...</type>
            <declname>T_Args</declname>
            <defname>T_Args</defname>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; csl::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, Functional&lt; T_Args... &gt; func)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>csl::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Functional" kindref="compound">Functional</ref>&lt; T_Args... &gt;</type>
          <declname>func</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/functional.cpp" line="21" column="1" bodyfile="src/csl/functional.cpp" bodystart="21" bodyend="27"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a287aa8da95d30480fd9b132d399b873c" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1MultiPermutation" kindref="compound">MultiPermutation</ref></type>
        <definition>static MultiPermutation csl::getAllPossiblePermutations</definition>
        <argsstring>(std::vector&lt; csl::Expr &gt; const &amp;tensors)</argsstring>
        <name>getAllPossiblePermutations</name>
        <qualifiedname>csl::getAllPossiblePermutations</qualifiedname>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt; const &amp;</type>
          <declname>tensors</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/hardComparison.cpp" line="9" column="1" bodyfile="src/csl/hardComparison.cpp" bodystart="9" bodyend="33"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aeed6858b33274cbbac7d62b9c2ee3b42" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void csl::sortTensors</definition>
        <argsstring>(std::vector&lt; csl::Expr &gt; &amp;tensors)</argsstring>
        <name>sortTensors</name>
        <qualifiedname>csl::sortTensors</qualifiedname>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt; &amp;</type>
          <declname>tensors</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/hardComparison.cpp" line="35" column="13" bodyfile="src/csl/hardComparison.cpp" bodystart="35" bodyend="72"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a1c145fa0b9d57351d68a9a284201d754" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::pair&lt; std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt;, std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt; &gt;</type>
        <definition>static std::pair&lt; std::vector&lt; csl::Expr &gt;, std::vector&lt; csl::Expr &gt; &gt; csl::getSortedTensors</definition>
        <argsstring>(csl::Expr const &amp;A, csl::Expr const &amp;B)</argsstring>
        <name>getSortedTensors</name>
        <qualifiedname>csl::getSortedTensors</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/hardComparison.cpp" line="75" column="1" bodyfile="src/csl/hardComparison.cpp" bodystart="75" bodyend="96"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1afbad184b8525501fb9aecfcd49e53686" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int csl::matchBOnA</definition>
        <argsstring>(csl::Expr &amp;B, std::vector&lt; csl::Expr &gt; const &amp;tensorsInA, std::vector&lt; csl::Expr &gt; const &amp;tensorsInB)</argsstring>
        <name>matchBOnA</name>
        <qualifiedname>csl::matchBOnA</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>B</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt; const &amp;</type>
          <declname>tensorsInA</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt; const &amp;</type>
          <declname>tensorsInB</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/hardComparison.cpp" line="98" column="5" bodyfile="src/csl/hardComparison.cpp" bodystart="98" bodyend="162"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a485a2bfffb2255543ab75208dacc95cc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int csl::matchBOnA</definition>
        <argsstring>(csl::Expr const &amp;A, csl::Expr &amp;B)</argsstring>
        <name>matchBOnA</name>
        <qualifiedname>csl::matchBOnA</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/hardComparison.cpp" line="164" column="5" bodyfile="src/csl/hardComparison.cpp" bodystart="164" bodyend="171"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ab7ab1fc8c1c82d0c1be1be24f21653b2" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>static bool csl::hardComparison_impl</definition>
        <argsstring>(csl::Expr const &amp;A, csl::Expr const &amp;B)</argsstring>
        <name>hardComparison_impl</name>
        <qualifiedname>csl::hardComparison_impl</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/hardComparison.cpp" line="173" column="13" bodyfile="src/csl/hardComparison.cpp" bodystart="173" bodyend="188"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a6a9ef309803ba23183691a777ea83b41" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::hardComparison</definition>
        <argsstring>(csl::Expr const &amp;A, csl::Expr const &amp;B)</argsstring>
        <name>hardComparison</name>
        <qualifiedname>csl::hardComparison</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/hardComparison.cpp" line="190" column="6" bodyfile="src/csl/hardComparison.cpp" bodystart="190" bodyend="195" declfile="src/csl/hardComparison.h" declline="8" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a0e506c78c97457f482977befdfd8f284" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>static bool csl::hardOrdering_impl</definition>
        <argsstring>(csl::Expr const &amp;A, csl::Expr &amp;B)</argsstring>
        <name>hardOrdering_impl</name>
        <qualifiedname>csl::hardOrdering_impl</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/hardComparison.cpp" line="197" column="13" bodyfile="src/csl/hardComparison.cpp" bodystart="197" bodyend="203"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a39cca20a210428c92adef0e96543aefb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::hardOrdering</definition>
        <argsstring>(csl::Expr const &amp;A, csl::Expr const &amp;B)</argsstring>
        <name>hardOrdering</name>
        <qualifiedname>csl::hardOrdering</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/hardComparison.cpp" line="205" column="6" bodyfile="src/csl/hardComparison.cpp" bodystart="205" bodyend="210" declfile="src/csl/hardComparison.h" declline="9" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a1fc55ac80542f4378b1d18a8cc311681" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int csl::matchBOnA</definition>
        <argsstring>(csl::Expr const &amp;A, csl::Expr const &amp;B)</argsstring>
        <name>matchBOnA</name>
        <qualifiedname>csl::matchBOnA</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/hardComparison.h" line="7" column="6" declfile="src/csl/hardComparison.h" declline="7" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a151e69835322d06a4d91de11586b55ed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int csl::isSuperFactor</definition>
        <argsstring>(Expr const &amp;fL, Expr const &amp;fR)</argsstring>
        <name>isSuperFactor</name>
        <qualifiedname>csl::isSuperFactor</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>fL</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>fR</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/hardFactor.cpp" line="28" column="5" bodyfile="src/csl/hardFactor.cpp" bodystart="28" bodyend="52"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af164e0d377dc6f578908ef16b9b005fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t csl::nSimilar</definition>
        <argsstring>(std::vector&lt; size_t &gt; const &amp;sortedA, std::vector&lt; size_t &gt; const &amp;sortedB)</argsstring>
        <name>nSimilar</name>
        <qualifiedname>csl::nSimilar</qualifiedname>
        <param>
          <type>std::vector&lt; size_t &gt; const &amp;</type>
          <declname>sortedA</declname>
        </param>
        <param>
          <type>std::vector&lt; size_t &gt; const &amp;</type>
          <declname>sortedB</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/hardFactor.cpp" line="56" column="8" bodyfile="src/csl/hardFactor.cpp" bodystart="56" bodyend="79"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a302a262771b342da7cf067db01c14c18" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t csl::maxSimilarity</definition>
        <argsstring>(std::vector&lt; size_t &gt; const &amp;pos, csl::linear_map&lt; csl::Expr, std::vector&lt; size_t &gt; &gt; const &amp;m)</argsstring>
        <name>maxSimilarity</name>
        <qualifiedname>csl::maxSimilarity</qualifiedname>
        <param>
          <type>std::vector&lt; size_t &gt; const &amp;</type>
          <declname>pos</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1linear__map" kindref="compound">csl::linear_map</ref>&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref>, std::vector&lt; size_t &gt; &gt; const &amp;</type>
          <declname>m</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/hardFactor.cpp" line="83" column="8" bodyfile="src/csl/hardFactor.cpp" bodystart="83" bodyend="96"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa5960f0a61a2bdb99a4740500a004fca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>FactorType const *</type>
        <definition>FactorType const  * csl::getBestFactor</definition>
        <argsstring>(csl::linear_map&lt; csl::Expr, std::vector&lt; size_t &gt; &gt; const &amp;m)</argsstring>
        <name>getBestFactor</name>
        <qualifiedname>csl::getBestFactor</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1linear__map" kindref="compound">csl::linear_map</ref>&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref>, std::vector&lt; size_t &gt; &gt; const &amp;</type>
          <declname>m</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/hardFactor.cpp" line="100" column="1" bodyfile="src/csl/hardFactor.cpp" bodystart="100" bodyend="144"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a81d7257720850ddcce57c458f1329f73" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::pair&lt; bool, bool &gt;</type>
        <definition>std::pair&lt; bool, bool &gt; csl::hasRecursiveFactors</definition>
        <argsstring>(FactorType const *best, csl::linear_map&lt; csl::Expr, std::vector&lt; size_t &gt; &gt; const &amp;m)</argsstring>
        <name>hasRecursiveFactors</name>
        <qualifiedname>csl::hasRecursiveFactors</qualifiedname>
        <param>
          <type>FactorType const *</type>
          <declname>best</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1linear__map" kindref="compound">csl::linear_map</ref>&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref>, std::vector&lt; size_t &gt; &gt; const &amp;</type>
          <declname>m</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/hardFactor.cpp" line="147" column="1" bodyfile="src/csl/hardFactor.cpp" bodystart="147" bodyend="166"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a576d70319644bcce1836175152a07ffe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1linear__map" kindref="compound">csl::linear_map</ref>&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref>, std::vector&lt; size_t &gt; &gt;::iterator</type>
        <definition>csl::linear_map&lt; csl::Expr, std::vector&lt; size_t &gt; &gt;::iterator csl::linear_find</definition>
        <argsstring>(csl::linear_map&lt; csl::Expr, std::vector&lt; size_t &gt; &gt; &amp;m, csl::Expr const &amp;expr)</argsstring>
        <name>linear_find</name>
        <qualifiedname>csl::linear_find</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1linear__map" kindref="compound">csl::linear_map</ref>&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref>, std::vector&lt; size_t &gt; &gt; &amp;</type>
          <declname>m</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/hardFactor.cpp" line="169" column="1" bodyfile="src/csl/hardFactor.cpp" bodystart="169" bodyend="180"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa1f07932067b4899afd690c292463da1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::HardFactorImplementation</definition>
        <argsstring>(Expr &amp;sum, bool applyRecursively)</argsstring>
        <name>HardFactorImplementation</name>
        <qualifiedname>csl::HardFactorImplementation</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>sum</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>applyRecursively</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/hardFactor.cpp" line="182" column="6" bodyfile="src/csl/hardFactor.cpp" bodystart="182" bodyend="304" declfile="src/csl/hardFactor.h" declline="22" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ab958cdded2d2629a922694b0ae6694a7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::HardFactor</definition>
        <argsstring>(Expr &amp;init)</argsstring>
        <name>HardFactor</name>
        <qualifiedname>csl::HardFactor</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/hardFactor.cpp" line="306" column="6" bodyfile="src/csl/hardFactor.cpp" bodystart="306" bodyend="310" declfile="src/csl/hardFactor.h" declline="25" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ad242ca3c0cdb63e3d5c495e3fb73b5d8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::DeepHardFactor</definition>
        <argsstring>(Expr &amp;init)</argsstring>
        <name>DeepHardFactor</name>
        <qualifiedname>csl::DeepHardFactor</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/hardFactor.cpp" line="312" column="6" bodyfile="src/csl/hardFactor.cpp" bodystart="312" bodyend="322" declfile="src/csl/hardFactor.h" declline="27" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af6c92123131d8e5fb5e17af2737862aa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::HardFactored</definition>
        <argsstring>(Expr const &amp;init)</argsstring>
        <name>HardFactored</name>
        <qualifiedname>csl::HardFactored</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/hardFactor.cpp" line="324" column="6" bodyfile="src/csl/hardFactor.cpp" bodystart="324" bodyend="329" declfile="src/csl/hardFactor.h" declline="24" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a6a3375a7f7f29dced30eb695bd11b2df" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::DeepHardFactored</definition>
        <argsstring>(Expr const &amp;init)</argsstring>
        <name>DeepHardFactored</name>
        <qualifiedname>csl::DeepHardFactored</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/hardFactor.cpp" line="331" column="6" bodyfile="src/csl/hardFactor.cpp" bodystart="331" bodyend="336" declfile="src/csl/hardFactor.h" declline="26" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a7239c266a7391f8a652b83e65d927f4a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Index" kindref="compound">Index</ref></type>
        <definition>Index csl::operator!</definition>
        <argsstring>(const Index &amp;index)</argsstring>
        <name>operator!</name>
        <qualifiedname>csl::operator!</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>index</declname>
        </param>
        <briefdescription>
<para>operator!, unary operator on <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> that change the free property of the <ref refid="classcsl_1_1Index" kindref="compound">Index</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> to copy.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A free <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> similar to <bold>index</bold> if it is dummy. </para>
</simplesect>
<simplesect kind="return"><para>A dummy <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> similar to <bold>index</bold> if it is free. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/index.cpp" line="354" column="7" bodyfile="src/csl/index.cpp" bodystart="354" bodyend="359" declfile="src/csl/index.h" declline="439" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae8258f8706933e1c10c973c721cd6151" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Index" kindref="compound">Index</ref></type>
        <definition>Index csl::operator+</definition>
        <argsstring>(const Index &amp;index)</argsstring>
        <name>operator+</name>
        <qualifiedname>csl::operator+</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>index</declname>
        </param>
        <briefdescription>
<para>operator+, unary operator on <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> that returns a similar <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> with sign = 1 if the <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> is signed, i.e. an <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> up. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> to copy.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An index similar to <bold>index</bold> with a sign 1 i.e. a up <ref refid="classcsl_1_1Index" kindref="compound">Index</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/index.cpp" line="360" column="7" bodyfile="src/csl/index.cpp" bodystart="360" bodyend="366" declfile="src/csl/index.h" declline="449" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa060a7f29c77b51682733901c7a24d04" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Index" kindref="compound">Index</ref></type>
        <definition>Index csl::operator-</definition>
        <argsstring>(const Index &amp;index)</argsstring>
        <name>operator-</name>
        <qualifiedname>csl::operator-</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>index</declname>
        </param>
        <briefdescription>
<para>operator-, unary operator on <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> that returns a similar <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> with sign = 0 if the <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> is signed, i.e. an <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> down. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> to copy.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An index similar to <bold>index</bold> with a sign 0 i.e. a down <ref refid="classcsl_1_1Index" kindref="compound">Index</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/index.cpp" line="367" column="7" bodyfile="src/csl/index.cpp" bodystart="367" bodyend="373" declfile="src/csl/index.h" declline="459" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a55a8427b653a161e9d1217ef73a91077" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ostream &amp;</type>
        <definition>ostream &amp; csl::operator&lt;&lt;</definition>
        <argsstring>(ostream &amp;fout, const Index &amp;index)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>csl::operator&lt;&lt;</qualifiedname>
        <param>
          <type>ostream &amp;</type>
          <declname>fout</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/index.cpp" line="375" column="1" bodyfile="src/csl/index.cpp" bodystart="375" bodyend="393"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ac2a1e87e4436c3df942585e9485222e8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &gt;</type>
        <definition>std::vector&lt; Index &gt; csl::integerToIndices</definition>
        <argsstring>(const std::vector&lt; int &gt; &amp;indices)</argsstring>
        <name>integerToIndices</name>
        <qualifiedname>csl::integerToIndices</qualifiedname>
        <param>
          <type>const std::vector&lt; int &gt; &amp;</type>
          <declname>indices</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/index.cpp" line="395" column="13" bodyfile="src/csl/index.cpp" bodystart="395" bodyend="402" declfile="src/csl/index.h" declline="428" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a903caba70ca68ef490431768b8d8a2d0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ostream &amp;</type>
        <definition>ostream &amp; csl::operator&lt;&lt;</definition>
        <argsstring>(ostream &amp;fout, const IndexStructure &amp;structure)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>csl::operator&lt;&lt;</qualifiedname>
        <param>
          <type>ostream &amp;</type>
          <declname>fout</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1IndexStructure" kindref="compound">IndexStructure</ref> &amp;</type>
          <declname>structure</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/index.cpp" line="713" column="1" bodyfile="src/csl/index.cpp" bodystart="713" bodyend="727"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a08f97f44b1543ac4151d41d6c4a89e20" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsIndicialTensor</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>IsIndicialTensor</name>
        <qualifiedname>csl::IsIndicialTensor</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="38" column="6" bodyfile="src/csl/indicial.cpp" bodystart="38" bodyend="41" declfile="src/csl/indicial.h" declline="943" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1acd8580c64c7331dd2ea20f976fb57c81" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsIndicialTensor</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsIndicialTensor</name>
        <qualifiedname>csl::IsIndicialTensor</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="43" column="6" bodyfile="src/csl/indicial.cpp" bodystart="43" bodyend="48" declfile="src/csl/indicial.h" declline="945" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ad320dbb2a1c89bab6ccc90a65e776e3e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>csl::vector_expr</type>
        <definition>csl::vector_expr csl::getAllPermutations</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>getAllPermutations</name>
        <qualifiedname>csl::getAllPermutations</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="50" column="18" bodyfile="src/csl/indicial.cpp" bodystart="50" bodyend="72" declfile="src/csl/indicial.h" declline="44" declcolumn="18"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a218927caa97681fb12412e7254063055" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::nameTensor</definition>
        <argsstring>(const string &amp;name, Expr &amp;tensor, bool first)</argsstring>
        <name>nameTensor</name>
        <qualifiedname>csl::nameTensor</qualifiedname>
        <param>
          <type>const string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>tensor</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>first</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="74" column="6" bodyfile="src/csl/indicial.cpp" bodystart="74" bodyend="106"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a3627cd3c5e366b53d9c53e48dba7a9a3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::generateTensor</definition>
        <argsstring>(const string &amp;name, const vector&lt; const Space * &gt; &amp;spaces)</argsstring>
        <name>generateTensor</name>
        <qualifiedname>csl::generateTensor</qualifiedname>
        <param>
          <type>const string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const vector&lt; const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> * &gt; &amp;</type>
          <declname>spaces</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="108" column="6" bodyfile="src/csl/indicial.cpp" bodystart="108" bodyend="118"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a13e0bec3eb68be5dea4ca8f851f99cda" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ostream &amp;</type>
        <definition>ostream &amp; csl::operator&lt;&lt;</definition>
        <argsstring>(ostream &amp;fout, const SelfContraction &amp;c)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>csl::operator&lt;&lt;</qualifiedname>
        <param>
          <type>ostream &amp;</type>
          <declname>fout</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1SelfContraction" kindref="compound">SelfContraction</ref> &amp;</type>
          <declname>c</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="356" column="1" bodyfile="src/csl/indicial.cpp" bodystart="356" bodyend="364"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a5cb1d9d4e5ff9a1a2bd8adc571075517" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::isInContraction</definition>
        <argsstring>(std::vector&lt; std::array&lt; int, 4 &gt; &gt; const &amp;contractions, int iTensor, int iIndex)</argsstring>
        <name>isInContraction</name>
        <qualifiedname>csl::isInContraction</qualifiedname>
        <param>
          <type>std::vector&lt; std::array&lt; int, 4 &gt; &gt; const &amp;</type>
          <declname>contractions</declname>
        </param>
        <param>
          <type>int</type>
          <declname>iTensor</declname>
        </param>
        <param>
          <type>int</type>
          <declname>iIndex</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="709" column="6" bodyfile="src/csl/indicial.cpp" bodystart="709" bodyend="718"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a7c4766d9d98d58978d879fd7f165ac2e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ostream &amp;</type>
        <definition>ostream &amp; csl::operator&lt;&lt;</definition>
        <argsstring>(ostream &amp;fout, const ContractionChain &amp;c)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>csl::operator&lt;&lt;</qualifiedname>
        <param>
          <type>ostream &amp;</type>
          <declname>fout</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1ContractionChain" kindref="compound">ContractionChain</ref> &amp;</type>
          <declname>c</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="844" column="1" bodyfile="src/csl/indicial.cpp" bodystart="844" bodyend="863"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a3f963a9d8849fffcd2c647b813b0aa51" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>vector&lt; pair&lt; T, <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; &gt;::iterator</type>
        <definition>vector&lt; pair&lt; T, Expr &gt; &gt;::iterator csl::findContraction</definition>
        <argsstring>(typename vector&lt; pair&lt; T, Expr &gt; &gt;::iterator it, typename vector&lt; pair&lt; T, Expr &gt; &gt;::iterator last, T element)</argsstring>
        <name>findContraction</name>
        <qualifiedname>csl::findContraction</qualifiedname>
        <param>
          <type>typename vector&lt; pair&lt; T, <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; &gt;::iterator</type>
          <declname>it</declname>
        </param>
        <param>
          <type>typename vector&lt; pair&lt; T, <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; &gt;::iterator</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T</type>
          <declname>element</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="1435" column="1" bodyfile="src/csl/indicial.cpp" bodystart="1435" bodyend="1447"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a4a3c3dc03e0acbdac97339bc62079e7b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>vector&lt; pair&lt; T, <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; &gt;::const_iterator</type>
        <definition>vector&lt; pair&lt; T, Expr &gt; &gt;::const_iterator csl::findContraction</definition>
        <argsstring>(typename vector&lt; pair&lt; T, Expr &gt; &gt;::const_iterator it, typename vector&lt; pair&lt; T, Expr &gt; &gt;::const_iterator last, T element)</argsstring>
        <name>findContraction</name>
        <qualifiedname>csl::findContraction</qualifiedname>
        <param>
          <type>typename vector&lt; pair&lt; T, <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; &gt;::const_iterator</type>
          <declname>it</declname>
        </param>
        <param>
          <type>typename vector&lt; pair&lt; T, <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; &gt;::const_iterator</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T</type>
          <declname>element</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="1451" column="1" bodyfile="src/csl/indicial.cpp" bodystart="1451" bodyend="1463"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a7723657c19a7973e51aac929be3bb6d9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::fillKeptIndices</definition>
        <argsstring>(vector&lt; vector&lt; vector&lt; int &gt; &gt; &gt; &amp;keptIndices, vector&lt; size_t &gt;::const_iterator posBroken, vector&lt; size_t &gt;::const_iterator endPosBroken, vector&lt; vector&lt; int &gt; &gt; const &amp;toInsert)</argsstring>
        <name>fillKeptIndices</name>
        <qualifiedname>csl::fillKeptIndices</qualifiedname>
        <param>
          <type>vector&lt; vector&lt; vector&lt; int &gt; &gt; &gt; &amp;</type>
          <declname>keptIndices</declname>
        </param>
        <param>
          <type>vector&lt; size_t &gt;::const_iterator</type>
          <declname>posBroken</declname>
        </param>
        <param>
          <type>vector&lt; size_t &gt;::const_iterator</type>
          <declname>endPosBroken</declname>
        </param>
        <param>
          <type>vector&lt; vector&lt; int &gt; &gt; const &amp;</type>
          <declname>toInsert</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="1649" column="6" bodyfile="src/csl/indicial.cpp" bodystart="1649" bodyend="1667" declfile="src/csl/indicial.cpp" declline="1604" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1addacb9e9030bd2f932eb188addd3d673" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::fillKeptIndices</definition>
        <argsstring>(vector&lt; vector&lt; vector&lt; int &gt; &gt; &gt; &amp;keptIndices, vector&lt; size_t &gt;::const_iterator posBroken, vector&lt; size_t &gt;::const_iterator endPosBroken, vector&lt; size_t &gt; const &amp;pieces)</argsstring>
        <name>fillKeptIndices</name>
        <qualifiedname>csl::fillKeptIndices</qualifiedname>
        <param>
          <type>vector&lt; vector&lt; vector&lt; int &gt; &gt; &gt; &amp;</type>
          <declname>keptIndices</declname>
        </param>
        <param>
          <type>vector&lt; size_t &gt;::const_iterator</type>
          <declname>posBroken</declname>
        </param>
        <param>
          <type>vector&lt; size_t &gt;::const_iterator</type>
          <declname>endPosBroken</declname>
        </param>
        <param>
          <type>vector&lt; size_t &gt; const &amp;</type>
          <declname>pieces</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="1609" column="6" bodyfile="src/csl/indicial.cpp" bodystart="1609" bodyend="1648"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a5469cce6789f5e329f43ecd1d67253da" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::fillNewSpaces</definition>
        <argsstring>(vector&lt; vector&lt; const Space * &gt; &gt; &amp;newSpace, vector&lt; size_t &gt;::const_iterator posBroken, vector&lt; size_t &gt;::const_iterator endPosBroken, vector&lt; const Space * &gt; const &amp;fillingSpace)</argsstring>
        <name>fillNewSpaces</name>
        <qualifiedname>csl::fillNewSpaces</qualifiedname>
        <param>
          <type>vector&lt; vector&lt; const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> * &gt; &gt; &amp;</type>
          <declname>newSpace</declname>
        </param>
        <param>
          <type>vector&lt; size_t &gt;::const_iterator</type>
          <declname>posBroken</declname>
        </param>
        <param>
          <type>vector&lt; size_t &gt;::const_iterator</type>
          <declname>endPosBroken</declname>
        </param>
        <param>
          <type>vector&lt; const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> * &gt; const &amp;</type>
          <declname>fillingSpace</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="1692" column="6" bodyfile="src/csl/indicial.cpp" bodystart="1692" bodyend="1710" declfile="src/csl/indicial.cpp" declline="1669" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a0bd33431094a24efd6e5598424c7c79b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>vector&lt; vector&lt; const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> * &gt; &gt;</type>
        <definition>vector&lt; vector&lt; const Space * &gt; &gt; csl::fillNewSpaces</definition>
        <argsstring>(vector&lt; const Space * &gt; const &amp;init, vector&lt; size_t &gt;::const_iterator posBroken, vector&lt; size_t &gt;::const_iterator endPosBroken, vector&lt; const Space * &gt; const &amp;fillingSpace)</argsstring>
        <name>fillNewSpaces</name>
        <qualifiedname>csl::fillNewSpaces</qualifiedname>
        <param>
          <type>vector&lt; const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> * &gt; const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>vector&lt; size_t &gt;::const_iterator</type>
          <declname>posBroken</declname>
        </param>
        <param>
          <type>vector&lt; size_t &gt;::const_iterator</type>
          <declname>endPosBroken</declname>
        </param>
        <param>
          <type>vector&lt; const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> * &gt; const &amp;</type>
          <declname>fillingSpace</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="1675" column="1" bodyfile="src/csl/indicial.cpp" bodystart="1675" bodyend="1690"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a82ae082b6b975f09d8da7c377ab5993b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string csl::getBrokenName</definition>
        <argsstring>(std::string const &amp;initName, std::vector&lt; std::vector&lt; int &gt; &gt; const &amp;indices)</argsstring>
        <name>getBrokenName</name>
        <qualifiedname>csl::getBrokenName</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>initName</declname>
        </param>
        <param>
          <type>std::vector&lt; std::vector&lt; int &gt; &gt; const &amp;</type>
          <declname>indices</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="1717" column="13" bodyfile="src/csl/indicial.cpp" bodystart="1717" bodyend="1736"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a80970feaa1eb9a44f59adb8451db1680" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; csl::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;fout, const TensorParent &amp;i)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>csl::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>fout</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1TensorParent" kindref="compound">TensorParent</ref> &amp;</type>
          <declname>i</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>\function std::ostream&amp; <ref refid="namespacecsl_1a80970feaa1eb9a44f59adb8451db1680" kindref="member">operator&lt;&lt;(std::ostream&amp; fout,
                                    const TensorParent&amp; p)</ref> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="1847" column="1" bodyfile="src/csl/indicial.cpp" bodystart="1847" bodyend="1862"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a92ac045f286ef7f712193aad46f01007" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::fillStructures</definition>
        <argsstring>(vector&lt; IndexStructure &gt; &amp;toFill, const vector&lt; Index &gt; &amp;indices, vector&lt; size_t &gt;::const_iterator pos, vector&lt; size_t &gt;::const_iterator end, size_t iter=0)</argsstring>
        <name>fillStructures</name>
        <qualifiedname>csl::fillStructures</qualifiedname>
        <param>
          <type>vector&lt; <ref refid="classcsl_1_1IndexStructure" kindref="compound">IndexStructure</ref> &gt; &amp;</type>
          <declname>toFill</declname>
        </param>
        <param>
          <type>const vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &gt; &amp;</type>
          <declname>indices</declname>
        </param>
        <param>
          <type>vector&lt; size_t &gt;::const_iterator</type>
          <declname>pos</declname>
        </param>
        <param>
          <type>vector&lt; size_t &gt;::const_iterator</type>
          <declname>end</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>iter</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="2513" column="6" bodyfile="src/csl/indicial.cpp" bodystart="2513" bodyend="2528"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2bb818848ac78d1e7e0bda5b70169d34" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::clearNullIndices</definition>
        <argsstring>(vector&lt; IndexStructure &gt; &amp;toClear)</argsstring>
        <name>clearNullIndices</name>
        <qualifiedname>csl::clearNullIndices</qualifiedname>
        <param>
          <type>vector&lt; <ref refid="classcsl_1_1IndexStructure" kindref="compound">IndexStructure</ref> &gt; &amp;</type>
          <declname>toClear</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="2530" column="6" bodyfile="src/csl/indicial.cpp" bodystart="2530" bodyend="2539"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a101f11c8a5b3db0d28ed3ae31c3464b4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::uniformizeIndices</definition>
        <argsstring>(csl::vector_expr &amp;terms)</argsstring>
        <name>uniformizeIndices</name>
        <qualifiedname>csl::uniformizeIndices</qualifiedname>
        <param>
          <type>csl::vector_expr &amp;</type>
          <declname>terms</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="3118" column="6" bodyfile="src/csl/indicial.cpp" bodystart="3118" bodyend="3128"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a070cd4d07f0a13d41eb400d0d0090ffb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::keep_duplicates</definition>
        <argsstring>(vector&lt; Index &gt; &amp;vec)</argsstring>
        <name>keep_duplicates</name>
        <qualifiedname>csl::keep_duplicates</qualifiedname>
        <param>
          <type>vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &gt; &amp;</type>
          <declname>vec</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="3524" column="6" bodyfile="src/csl/indicial.cpp" bodystart="3524" bodyend="3559"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1acf0f96dbefbb12ff881a040d2dc9498b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::contract</definition>
        <argsstring>(Expr &amp;arg1, Expr &amp;arg2, csl::Index const &amp;index1, csl::Index const &amp;index2)</argsstring>
        <name>contract</name>
        <qualifiedname>csl::contract</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>arg1</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>arg2</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref> const &amp;</type>
          <declname>index1</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref> const &amp;</type>
          <declname>index2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="3612" column="6" bodyfile="src/csl/indicial.cpp" bodystart="3612" bodyend="3624"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a4364437c47d5cd466658d2d0e734f711" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::fillPosition</definition>
        <argsstring>(vector&lt; vector&lt; size_t &gt; &gt; &amp;positions, size_t Nspaces)</argsstring>
        <name>fillPosition</name>
        <qualifiedname>csl::fillPosition</qualifiedname>
        <param>
          <type>vector&lt; vector&lt; size_t &gt; &gt; &amp;</type>
          <declname>positions</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>Nspaces</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="3879" column="6" bodyfile="src/csl/indicial.cpp" bodystart="3879" bodyend="3889"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ab14d7c9e2b7029b82562aebb7a8691c3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::getBrokenExpr</definition>
        <argsstring>(const Expr &amp;init, const csl::vector_expr &amp;brokenExpr, const vector&lt; Index &gt; &amp;brokenIndices, const vector&lt; Index &gt; &amp;replacement, const vector&lt; size_t &gt; &amp;positions, const size_t Nspaces)</argsstring>
        <name>getBrokenExpr</name>
        <qualifiedname>csl::getBrokenExpr</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>const csl::vector_expr &amp;</type>
          <declname>brokenExpr</declname>
        </param>
        <param>
          <type>const vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &gt; &amp;</type>
          <declname>brokenIndices</declname>
        </param>
        <param>
          <type>const vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &gt; &amp;</type>
          <declname>replacement</declname>
        </param>
        <param>
          <type>const vector&lt; size_t &gt; &amp;</type>
          <declname>positions</declname>
        </param>
        <param>
          <type>const size_t</type>
          <declname>Nspaces</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="3891" column="6" bodyfile="src/csl/indicial.cpp" bodystart="3891" bodyend="3967"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a483729c7ee457a84525d97a038b883f1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>std::vector&lt; Expr &gt; csl::sumDummyIndices</definition>
        <argsstring>(std::vector&lt; Expr &gt; const &amp;init, std::vector&lt; std::vector&lt; size_t &gt; &gt; const &amp;posIndices, std::vector&lt; size_t &gt; const &amp;dummyIndices)</argsstring>
        <name>sumDummyIndices</name>
        <qualifiedname>csl::sumDummyIndices</qualifiedname>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::vector&lt; std::vector&lt; size_t &gt; &gt; const &amp;</type>
          <declname>posIndices</declname>
        </param>
        <param>
          <type>std::vector&lt; size_t &gt; const &amp;</type>
          <declname>dummyIndices</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="3970" column="1" bodyfile="src/csl/indicial.cpp" bodystart="3970" bodyend="4007"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a40bb44be3041543fccdc2202754cbaf4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::sortIndices</definition>
        <argsstring>(std::vector&lt; csl::Index &gt; &amp;indices, std::vector&lt; size_t &gt; &amp;positions)</argsstring>
        <name>sortIndices</name>
        <qualifiedname>csl::sortIndices</qualifiedname>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref> &gt; &amp;</type>
          <declname>indices</declname>
        </param>
        <param>
          <type>std::vector&lt; size_t &gt; &amp;</type>
          <declname>positions</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.cpp" line="4009" column="6" bodyfile="src/csl/indicial.cpp" bodystart="4009" bodyend="4028"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a61265c9322c397664a62b5d5b0adfa6e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classstd_1_1shared__ptr" kindref="compound">std::shared_ptr</ref>&lt; <ref refid="classcsl_1_1TensorParent" kindref="compound">TensorParent</ref> &gt;</type>
        <definition>std::shared_ptr&lt; TensorParent &gt; csl::tensor_s</definition>
        <argsstring>(Args &amp;&amp;... args)</argsstring>
        <name>tensor_s</name>
        <qualifiedname>csl::tensor_s</qualifiedname>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="505" column="17" bodyfile="src/csl/indicial.h" bodystart="505" bodyend="508"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af3325a8e0d607176f59dcf8cee2deb67" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classstd_1_1shared__ptr" kindref="compound">std::shared_ptr</ref>&lt; <ref refid="classcsl_1_1TensorParent" kindref="compound">TensorParent</ref> &gt;</type>
        <definition>std::shared_ptr&lt; TensorParent &gt; csl::tensor_s</definition>
        <argsstring>(std::string const &amp;name, std::vector&lt; const Space * &gt; const &amp;indices, Args &amp;&amp;... args)</argsstring>
        <name>tensor_s</name>
        <qualifiedname>csl::tensor_s</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> * &gt; const &amp;</type>
          <declname>indices</declname>
        </param>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="512" column="1" bodyfile="src/csl/indicial.h" bodystart="512" bodyend="518"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a94a3c110e8a5015bc285f8e3be015472" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::tensorelement_s</definition>
        <argsstring>(Args &amp;&amp;... args)</argsstring>
        <name>tensorelement_s</name>
        <qualifiedname>csl::tensorelement_s</qualifiedname>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="936" column="6" bodyfile="src/csl/indicial.h" bodystart="936" bodyend="941"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ab17fb7de179f8643818e2eb85c4adda8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::nameTensor</definition>
        <argsstring>(const std::string &amp;name, Expr &amp;tensor, bool first=true)</argsstring>
        <name>nameTensor</name>
        <qualifiedname>csl::nameTensor</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>tensor</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>first</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Fills an tensor with variables of the same name with the numbers correponding to their place in the tensor. Allows for example to name elements of a vector <formula id="33">$ V $</formula>:  <formula id="34">$ \left(
V_0,V_1,V_2,V_3\right)$</formula>. </para>
        </briefdescription>
        <detaileddescription>
<para>The parameter first is due to the recursive nature of the function. It allows to know if the call of nameTensor() is the user&apos;s (first = true) or from another nameTensor()&apos;s call (first = false). This parameter should then not be given by the user, but let to its default value <bold>true</bold>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of the elements. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tensor</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Tensor" kindref="compound">Tensor</ref> to fill (the <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> is modified in the function). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>This parameter should not be given by the user. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="962" column="6" declfile="src/csl/indicial.h" declline="962" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a6343f864651a51563696008ea8c73f64" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::generateTensor</definition>
        <argsstring>(const std::string &amp;name, const std::vector&lt; const Space * &gt; &amp;spaces)</argsstring>
        <name>generateTensor</name>
        <qualifiedname>csl::generateTensor</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const std::vector&lt; const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> * &gt; &amp;</type>
          <declname>spaces</declname>
        </param>
        <briefdescription>
<para>Generates a tensor of name <bold>name</bold> that lives in a list of spaces, filled with variables given by nameTensor(). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of the tensor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>spaces</parametername>
</parameternamelist>
<parameterdescription>
<para>List of spaces in which the tensor lives (just to get the dimensions).</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> that is the generated tensor. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="974" column="6" declfile="src/csl/indicial.h" declline="974" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2cba002dbb691fe0c9b1c496e0d41706" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::GetSymbol</definition>
        <argsstring>(std::string_view name, Expr const &amp;init)</argsstring>
        <name>GetSymbol</name>
        <qualifiedname>csl::GetSymbol</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="33" column="6" bodyfile="src/csl/interface.cpp" bodystart="33" bodyend="46" declfile="src/csl/interface.h" declline="71" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a63350b46f1d9c1bba3ad6f086bbe9463" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref></type>
        <definition>Parent csl::GetParent</definition>
        <argsstring>(std::string_view name, Expr const &amp;init)</argsstring>
        <name>GetParent</name>
        <qualifiedname>csl::GetParent</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="48" column="8" bodyfile="src/csl/interface.cpp" bodystart="48" bodyend="54" declfile="src/csl/interface.h" declline="73" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aec9c163d8fcf06cd00ecf1887be3f977" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Expand</definition>
        <argsstring>(Expr &amp;expression, bool full, bool inplace)</argsstring>
        <name>Expand</name>
        <qualifiedname>csl::Expand</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>inplace</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="56" column="6" bodyfile="src/csl/interface.cpp" bodystart="56" bodyend="59" declfile="src/csl/interface.h" declline="96" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a3b08308bf6912078883415b6c93b7c6d" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Expanded</definition>
        <argsstring>(const Expr &amp;expression, bool full, bool inplace)</argsstring>
        <name>Expanded</name>
        <qualifiedname>csl::Expanded</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>inplace</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="61" column="6" bodyfile="src/csl/interface.cpp" bodystart="61" bodyend="64" declfile="src/csl/interface.h" declline="99" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ab5a5477e0a31f172addf6bd222a37f41" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::ExpandIf</definition>
        <argsstring>(Expr &amp;expression, std::function&lt; bool(Expr const &amp;)&gt; const &amp;f, bool full, bool inplace)</argsstring>
        <name>ExpandIf</name>
        <qualifiedname>csl::ExpandIf</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>inplace</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="66" column="6" bodyfile="src/csl/interface.cpp" bodystart="66" bodyend="72" declfile="src/csl/interface.h" declline="101" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a6e6d3e835b63d38c10b309b562b1291c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::DeepExpandIf_lock</definition>
        <argsstring>(Expr &amp;expression, std::function&lt; bool(Expr const &amp;)&gt; const &amp;f, int lockID, bool inplace, bool refactor)</argsstring>
        <name>DeepExpandIf_lock</name>
        <qualifiedname>csl::DeepExpandIf_lock</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lockID</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>inplace</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>refactor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="74" column="6" bodyfile="src/csl/interface.cpp" bodystart="74" bodyend="92" declfile="src/csl/interface.h" declline="137" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a7d0211fcc002c3614c97682a02f43cdb" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::DeepExpandedIf_lock</definition>
        <argsstring>(Expr const &amp;expression, std::function&lt; bool(Expr const &amp;)&gt; const &amp;f, int lockID, bool inplace, bool refactor)</argsstring>
        <name>DeepExpandedIf_lock</name>
        <qualifiedname>csl::DeepExpandedIf_lock</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lockID</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>inplace</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>refactor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="94" column="6" bodyfile="src/csl/interface.cpp" bodystart="94" bodyend="103" declfile="src/csl/interface.h" declline="144" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a9a98ca2929bf36c880b5fa2cee5eb728" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::ExpandedIf</definition>
        <argsstring>(const Expr &amp;expression, std::function&lt; bool(Expr const &amp;)&gt; const &amp;f, bool full, bool inplace)</argsstring>
        <name>ExpandedIf</name>
        <qualifiedname>csl::ExpandedIf</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>inplace</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="105" column="6" bodyfile="src/csl/interface.cpp" bodystart="105" bodyend="111" declfile="src/csl/interface.h" declline="106" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae2f427df8fd6ecb4e66e907a9928e754" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Factor</definition>
        <argsstring>(Expr &amp;expression, bool full)</argsstring>
        <name>Factor</name>
        <qualifiedname>csl::Factor</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="113" column="6" bodyfile="src/csl/interface.cpp" bodystart="113" bodyend="116" declfile="src/csl/interface.h" declline="150" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1acb31dbddd11ad1ffabcf37b754534054" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Factored</definition>
        <argsstring>(const Expr &amp;expression, bool full)</argsstring>
        <name>Factored</name>
        <qualifiedname>csl::Factored</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="118" column="6" bodyfile="src/csl/interface.cpp" bodystart="118" bodyend="121" declfile="src/csl/interface.h" declline="159" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a6c535da39beae377fab4e4665bbff9ce" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Factor</definition>
        <argsstring>(Expr &amp;expression, Expr_info factor, bool full)</argsstring>
        <name>Factor</name>
        <qualifiedname>csl::Factor</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>factor</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="123" column="6" bodyfile="src/csl/interface.cpp" bodystart="123" bodyend="126" declfile="src/csl/interface.h" declline="152" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2fa28c54ff477f065ce090afb3e91cd4" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Factored</definition>
        <argsstring>(const Expr &amp;expression, Expr_info factor, bool full)</argsstring>
        <name>Factored</name>
        <qualifiedname>csl::Factored</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>factor</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="128" column="6" bodyfile="src/csl/interface.cpp" bodystart="128" bodyend="131" declfile="src/csl/interface.h" declline="162" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a03e0d13976a4bd8cbc200e09581678f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Collect</definition>
        <argsstring>(Expr &amp;expr, std::vector&lt; Expr &gt; const &amp;factors)</argsstring>
        <name>Collect</name>
        <qualifiedname>csl::Collect</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; const &amp;</type>
          <declname>factors</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="133" column="6" bodyfile="src/csl/interface.cpp" bodystart="133" bodyend="138" declfile="src/csl/interface.h" declline="202" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ab8606c566e78a2682ee87943ba2539df" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::DeepCollect</definition>
        <argsstring>(Expr &amp;expr, std::vector&lt; Expr &gt; const &amp;factors)</argsstring>
        <name>DeepCollect</name>
        <qualifiedname>csl::DeepCollect</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; const &amp;</type>
          <declname>factors</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="139" column="6" bodyfile="src/csl/interface.cpp" bodystart="139" bodyend="144" declfile="src/csl/interface.h" declline="203" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a219ea397a53999668ada423de73a8104" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Collected</definition>
        <argsstring>(Expr const &amp;expr, std::vector&lt; Expr &gt; const &amp;factors)</argsstring>
        <name>Collected</name>
        <qualifiedname>csl::Collected</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; const &amp;</type>
          <declname>factors</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="145" column="6" bodyfile="src/csl/interface.cpp" bodystart="145" bodyend="150" declfile="src/csl/interface.h" declline="204" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a7aba8653c79291b7f2fc5d773d38a03a" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::DeepCollected</definition>
        <argsstring>(Expr const &amp;expr, std::vector&lt; Expr &gt; const &amp;factors)</argsstring>
        <name>DeepCollected</name>
        <qualifiedname>csl::DeepCollected</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; const &amp;</type>
          <declname>factors</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="151" column="6" bodyfile="src/csl/interface.cpp" bodystart="151" bodyend="156" declfile="src/csl/interface.h" declline="206" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ad662e96e70173825dae5cda482cdcdaa" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Distributed</definition>
        <argsstring>(Expr const &amp;expression, Parent_info factor, bool full)</argsstring>
        <name>Distributed</name>
        <qualifiedname>csl::Distributed</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1AbstractParent" kindref="compound">Parent_info</ref></type>
          <declname>factor</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="158" column="6" bodyfile="src/csl/interface.cpp" bodystart="158" bodyend="163" declfile="src/csl/interface.h" declline="248" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a0c66c3fc2752bb7b25fb567223e10232" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Distribute</definition>
        <argsstring>(Expr &amp;expr, Parent_info factor, bool full)</argsstring>
        <name>Distribute</name>
        <qualifiedname>csl::Distribute</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1AbstractParent" kindref="compound">Parent_info</ref></type>
          <declname>factor</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="165" column="6" bodyfile="src/csl/interface.cpp" bodystart="165" bodyend="200" declfile="src/csl/interface.h" declline="250" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1abc1caa806bd9143843477dee65ba11ab" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Distributed</definition>
        <argsstring>(Expr const &amp;expression, Expr_info factor, bool full)</argsstring>
        <name>Distributed</name>
        <qualifiedname>csl::Distributed</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>factor</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="202" column="6" bodyfile="src/csl/interface.cpp" bodystart="202" bodyend="207" declfile="src/csl/interface.h" declline="210" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1adc247df147cbb6701422c99e48eb9c87" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Distribute</definition>
        <argsstring>(Expr &amp;expr, Expr_info factor, bool full)</argsstring>
        <name>Distribute</name>
        <qualifiedname>csl::Distribute</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>factor</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="209" column="6" bodyfile="src/csl/interface.cpp" bodystart="209" bodyend="243" declfile="src/csl/interface.h" declline="212" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a942b76b050460dc9b149367308aac424" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::DistributedIf</definition>
        <argsstring>(Expr const &amp;expression, std::function&lt; bool(Expr const &amp;)&gt; f, bool full)</argsstring>
        <name>DistributedIf</name>
        <qualifiedname>csl::DistributedIf</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="245" column="6" bodyfile="src/csl/interface.cpp" bodystart="245" bodyend="252" declfile="src/csl/interface.h" declline="286" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a0a2af1d0c040b3dbf09c0b73e330e9ed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::DistributeIf</definition>
        <argsstring>(Expr &amp;expr, std::function&lt; bool(Expr const &amp;)&gt; f, bool full)</argsstring>
        <name>DistributeIf</name>
        <qualifiedname>csl::DistributeIf</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="254" column="6" bodyfile="src/csl/interface.cpp" bodystart="254" bodyend="288" declfile="src/csl/interface.h" declline="290" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a51ac2b475bc681e2d35463eb0006b303" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::GetTerm</definition>
        <argsstring>(const Expr &amp;expression)</argsstring>
        <name>GetTerm</name>
        <qualifiedname>csl::GetTerm</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="290" column="6" bodyfile="src/csl/interface.cpp" bodystart="290" bodyend="293" declfile="src/csl/interface.h" declline="306" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a06afad91a45afb3fb065c256774fe57b" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Derived</definition>
        <argsstring>(const Expr &amp;expression, Expr_info variable)</argsstring>
        <name>Derived</name>
        <qualifiedname>csl::Derived</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>variable</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="295" column="6" bodyfile="src/csl/interface.cpp" bodystart="295" bodyend="298" declfile="src/csl/interface.h" declline="308" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a70d73b2299a37eef69581a213172d450" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::GetPolynomialTerm</definition>
        <argsstring>(const Expr &amp;expression, Expr_info variable, int order)</argsstring>
        <name>GetPolynomialTerm</name>
        <qualifiedname>csl::GetPolynomialTerm</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>variable</declname>
        </param>
        <param>
          <type>int</type>
          <declname>order</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="300" column="6" bodyfile="src/csl/interface.cpp" bodystart="300" bodyend="303" declfile="src/csl/interface.h" declline="326" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a547000792cc7a324993dc5bd7fc40030" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Evaluated</definition>
        <argsstring>(const Expr &amp;expression)</argsstring>
        <name>Evaluated</name>
        <qualifiedname>csl::Evaluated</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="305" column="6" bodyfile="src/csl/interface.cpp" bodystart="305" bodyend="308" declfile="src/csl/interface.h" declline="334" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a57e945ec91d4d3c42684a1911b2926f7" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Evaluated</definition>
        <argsstring>(const Expr &amp;expression, csl::eval::mode user_mode)</argsstring>
        <name>Evaluated</name>
        <qualifiedname>csl::Evaluated</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>csl::eval::mode</type>
          <declname>user_mode</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="310" column="6" bodyfile="src/csl/interface.cpp" bodystart="310" bodyend="313" declfile="src/csl/interface.h" declline="336" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2a8df6ba7c39fd03780af28b9cb2d918" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0e" kindref="member">ComplexProperty</ref></type>
        <definition>ComplexProperty csl::GetComplexProperty</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>GetComplexProperty</name>
        <qualifiedname>csl::GetComplexProperty</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="315" column="17" bodyfile="src/csl/interface.cpp" bodystart="315" bodyend="318" declfile="src/csl/interface.h" declline="349" declcolumn="18"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a501154931770fe51f69645d8a57ebf12" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::SetComplexProperty</definition>
        <argsstring>(Expr &amp;expr, ComplexProperty prop)</argsstring>
        <name>SetComplexProperty</name>
        <qualifiedname>csl::SetComplexProperty</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0e" kindref="member">ComplexProperty</ref></type>
          <declname>prop</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="320" column="6" bodyfile="src/csl/interface.cpp" bodystart="320" bodyend="323" declfile="src/csl/interface.h" declline="351" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a4badade11e622f75d9c887291bcc5d06" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0e" kindref="member">ComplexProperty</ref></type>
        <definition>ComplexProperty csl::GetComplexProperty</definition>
        <argsstring>(csl::Parent const &amp;parent)</argsstring>
        <name>GetComplexProperty</name>
        <qualifiedname>csl::GetComplexProperty</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Parent" kindref="compound">csl::Parent</ref> const &amp;</type>
          <declname>parent</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="325" column="17" bodyfile="src/csl/interface.cpp" bodystart="325" bodyend="328" declfile="src/csl/interface.h" declline="353" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a5bc4ed5e9d464a3a13d7fe5a91df2261" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::SetComplexProperty</definition>
        <argsstring>(csl::Parent &amp;parent, ComplexProperty prop)</argsstring>
        <name>SetComplexProperty</name>
        <qualifiedname>csl::SetComplexProperty</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Parent" kindref="compound">csl::Parent</ref> &amp;</type>
          <declname>parent</declname>
        </param>
        <param>
          <type><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0e" kindref="member">ComplexProperty</ref></type>
          <declname>prop</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="330" column="6" bodyfile="src/csl/interface.cpp" bodystart="330" bodyend="333" declfile="src/csl/interface.h" declline="355" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a7afcab855dcbe3f48f03b2c589bb7385" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::GetRealPart</definition>
        <argsstring>(const Expr &amp;expression)</argsstring>
        <name>GetRealPart</name>
        <qualifiedname>csl::GetRealPart</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="335" column="6" bodyfile="src/csl/interface.cpp" bodystart="335" bodyend="338" declfile="src/csl/interface.h" declline="364" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ad47dcd50e52537bd07e77109e139ddd3" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::GetImaginaryPart</definition>
        <argsstring>(const Expr &amp;expression)</argsstring>
        <name>GetImaginaryPart</name>
        <qualifiedname>csl::GetImaginaryPart</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="340" column="6" bodyfile="src/csl/interface.cpp" bodystart="340" bodyend="343" declfile="src/csl/interface.h" declline="366" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a064e11568f971ef9ac6f989390283920" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::GetComplexModulus</definition>
        <argsstring>(const Expr &amp;expression)</argsstring>
        <name>GetComplexModulus</name>
        <qualifiedname>csl::GetComplexModulus</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="345" column="6" bodyfile="src/csl/interface.cpp" bodystart="345" bodyend="348" declfile="src/csl/interface.h" declline="368" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1acc1b222d7e7a23d784d6509f1c23c3f2" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::GetComplexArgument</definition>
        <argsstring>(const Expr &amp;expression)</argsstring>
        <name>GetComplexArgument</name>
        <qualifiedname>csl::GetComplexArgument</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="350" column="6" bodyfile="src/csl/interface.cpp" bodystart="350" bodyend="353" declfile="src/csl/interface.h" declline="370" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aabf21d6b36935e0e8dbdeb8f984e6e9f" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::GetComplexConjugate</definition>
        <argsstring>(const Expr &amp;expression)</argsstring>
        <name>GetComplexConjugate</name>
        <qualifiedname>csl::GetComplexConjugate</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="355" column="6" bodyfile="src/csl/interface.cpp" bodystart="355" bodyend="358" declfile="src/csl/interface.h" declline="372" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a013895f099393bed50aa77723172db10" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::GetTransposed</definition>
        <argsstring>(const Expr &amp;expression, const Space *space, bool applyProp)</argsstring>
        <name>GetTransposed</name>
        <qualifiedname>csl::GetTransposed</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> *</type>
          <declname>space</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>applyProp</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="360" column="6" bodyfile="src/csl/interface.cpp" bodystart="360" bodyend="363" declfile="src/csl/interface.h" declline="374" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aee96feda42e1e340c70a0b0db1dfa4bb" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::GetTransposed</definition>
        <argsstring>(const Expr &amp;expression, const vector&lt; const Space * &gt; &amp;spaces, bool applyProp)</argsstring>
        <name>GetTransposed</name>
        <qualifiedname>csl::GetTransposed</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>const vector&lt; const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> * &gt; &amp;</type>
          <declname>spaces</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>applyProp</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="365" column="6" bodyfile="src/csl/interface.cpp" bodystart="365" bodyend="370"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aafe9bfe96fea320eb82169ab44a5f9c5" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::GetHermitianConjugate</definition>
        <argsstring>(const Expr &amp;expression, const Space *space)</argsstring>
        <name>GetHermitianConjugate</name>
        <qualifiedname>csl::GetHermitianConjugate</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> *</type>
          <declname>space</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="372" column="6" bodyfile="src/csl/interface.cpp" bodystart="372" bodyend="375" declfile="src/csl/interface.h" declline="382" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a763aba0bc4f7c407bcebcf12de3cec14" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::GetHermitianConjugate</definition>
        <argsstring>(const Expr &amp;expression, const vector&lt; const Space * &gt; &amp;spaces)</argsstring>
        <name>GetHermitianConjugate</name>
        <qualifiedname>csl::GetHermitianConjugate</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>const vector&lt; const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> * &gt; &amp;</type>
          <declname>spaces</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="377" column="6" bodyfile="src/csl/interface.cpp" bodystart="377" bodyend="381"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a6566e59bd360c812d65b86746a418981" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Swapped</definition>
        <argsstring>(const Expr &amp;expression, const Index &amp;index1, const Index &amp;index2, bool refresh)</argsstring>
        <name>Swapped</name>
        <qualifiedname>csl::Swapped</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>index1</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>index2</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>refresh</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="383" column="6" bodyfile="src/csl/interface.cpp" bodystart="383" bodyend="397" declfile="src/csl/interface.h" declline="389" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a270812b898e7c93e7ed638349876a038" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Swapped</definition>
        <argsstring>(const Expr &amp;expression, const Expr &amp;index1, const Expr &amp;index2, bool refresh)</argsstring>
        <name>Swapped</name>
        <qualifiedname>csl::Swapped</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>index1</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>index2</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>refresh</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="399" column="6" bodyfile="src/csl/interface.cpp" bodystart="399" bodyend="411" declfile="src/csl/interface.h" declline="394" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a593467622637ae2a0acb9c71c3b247f0" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Swapped</definition>
        <argsstring>(const Expr &amp;expression, const Parent &amp;parent1, const Parent &amp;parent2, bool refresh)</argsstring>
        <name>Swapped</name>
        <qualifiedname>csl::Swapped</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref> &amp;</type>
          <declname>parent1</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref> &amp;</type>
          <declname>parent2</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>refresh</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="413" column="6" bodyfile="src/csl/interface.cpp" bodystart="413" bodyend="425" declfile="src/csl/interface.h" declline="399" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a72c1e64ee3f7850e821f509e3aa3c3cf" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::ContractIndex</definition>
        <argsstring>(const Expr &amp;expression, const Index &amp;index)</argsstring>
        <name>ContractIndex</name>
        <qualifiedname>csl::ContractIndex</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="442" column="6" bodyfile="src/csl/interface.cpp" bodystart="442" bodyend="445" declfile="src/csl/interface.h" declline="415" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a435a4fc69a62dd8bc092865afb275157" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref></type>
        <definition>csl::Index csl::GenerateIndex</definition>
        <argsstring>(const csl::Space *space, const std::string &amp;name)</argsstring>
        <name>GenerateIndex</name>
        <qualifiedname>csl::GenerateIndex</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Space" kindref="compound">csl::Space</ref> *</type>
          <declname>space</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="447" column="12" bodyfile="src/csl/interface.cpp" bodystart="447" bodyend="452" declfile="src/csl/interface.h" declline="417" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ad3308499e1a6a0308721cf4a5160310a" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref></type>
        <definition>csl::Tensor csl::GetDelta</definition>
        <argsstring>(const csl::Space *space)</argsstring>
        <name>GetDelta</name>
        <qualifiedname>csl::GetDelta</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Space" kindref="compound">csl::Space</ref> *</type>
          <declname>space</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="454" column="13" bodyfile="src/csl/interface.cpp" bodystart="454" bodyend="457" declfile="src/csl/interface.h" declline="420" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a627520800fbe183de1614aa9ccaf187b" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref></type>
        <definition>csl::Tensor csl::GetMetric</definition>
        <argsstring>(const csl::Space *space)</argsstring>
        <name>GetMetric</name>
        <qualifiedname>csl::GetMetric</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Space" kindref="compound">csl::Space</ref> *</type>
          <declname>space</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="459" column="13" bodyfile="src/csl/interface.cpp" bodystart="459" bodyend="462" declfile="src/csl/interface.h" declline="421" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a41b7a3d00640c5c0baef0d045a49e5ff" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref></type>
        <definition>csl::Tensor csl::GetEpsilon</definition>
        <argsstring>(const csl::Space *space)</argsstring>
        <name>GetEpsilon</name>
        <qualifiedname>csl::GetEpsilon</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Space" kindref="compound">csl::Space</ref> *</type>
          <declname>space</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="464" column="13" bodyfile="src/csl/interface.cpp" bodystart="464" bodyend="467" declfile="src/csl/interface.h" declline="422" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a012ebc8a748514390004737bf132e204" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref></type>
        <definition>csl::Tensor csl::GetDelta</definition>
        <argsstring>(const csl::Space &amp;space)</argsstring>
        <name>GetDelta</name>
        <qualifiedname>csl::GetDelta</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Space" kindref="compound">csl::Space</ref> &amp;</type>
          <declname>space</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="469" column="13" bodyfile="src/csl/interface.cpp" bodystart="469" bodyend="472" declfile="src/csl/interface.h" declline="424" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a662f9d542ff4dc856444bea7812f8035" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref></type>
        <definition>csl::Tensor csl::GetMetric</definition>
        <argsstring>(const csl::Space &amp;space)</argsstring>
        <name>GetMetric</name>
        <qualifiedname>csl::GetMetric</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Space" kindref="compound">csl::Space</ref> &amp;</type>
          <declname>space</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="474" column="13" bodyfile="src/csl/interface.cpp" bodystart="474" bodyend="477" declfile="src/csl/interface.h" declline="425" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a1be9c4e1a0deb6c6e4963eaccd88251b" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref></type>
        <definition>csl::Tensor csl::GetEpsilon</definition>
        <argsstring>(const csl::Space &amp;space)</argsstring>
        <name>GetEpsilon</name>
        <qualifiedname>csl::GetEpsilon</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Space" kindref="compound">csl::Space</ref> &amp;</type>
          <declname>space</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="479" column="13" bodyfile="src/csl/interface.cpp" bodystart="479" bodyend="482" declfile="src/csl/interface.h" declline="426" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a283b7920a06dd6ce3b3e38b945428721" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref></type>
        <definition>Parent csl::GetParent</definition>
        <argsstring>(Expr const &amp;tensor)</argsstring>
        <name>GetParent</name>
        <qualifiedname>csl::GetParent</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>tensor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="484" column="8" bodyfile="src/csl/interface.cpp" bodystart="484" bodyend="487" declfile="src/csl/interface.h" declline="428" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a7cbb1c2e16eb5567cba6dbf4a6e4d976" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor csl::GetTensorParent</definition>
        <argsstring>(Expr const &amp;tensor)</argsstring>
        <name>GetTensorParent</name>
        <qualifiedname>csl::GetTensorParent</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>tensor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="489" column="8" bodyfile="src/csl/interface.cpp" bodystart="489" bodyend="497" declfile="src/csl/interface.h" declline="429" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aad83d07136b6e3feb0ec3531c3003792" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1TensorField" kindref="compound">TensorField</ref></type>
        <definition>TensorField csl::GetTensorFieldParent</definition>
        <argsstring>(Expr const &amp;tensor)</argsstring>
        <name>GetTensorFieldParent</name>
        <qualifiedname>csl::GetTensorFieldParent</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>tensor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="498" column="13" bodyfile="src/csl/interface.cpp" bodystart="498" bodyend="507" declfile="src/csl/interface.h" declline="430" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a18b90dc4c985c02d89dc1cbd5bc55ef5" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1TDerivative" kindref="compound">TDerivative</ref></type>
        <definition>TDerivative csl::GetTDerivativeParent</definition>
        <argsstring>(Expr const &amp;tensor)</argsstring>
        <name>GetTDerivativeParent</name>
        <qualifiedname>csl::GetTDerivativeParent</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>tensor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="508" column="13" bodyfile="src/csl/interface.cpp" bodystart="508" bodyend="517" declfile="src/csl/interface.h" declline="431" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a9f78de91ea6578bfcfbb31857ecba116" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::AddSelfContraction</definition>
        <argsstring>(csl::Tensor &amp;parent, Expr const &amp;A, Expr const &amp;B, Expr const &amp;res)</argsstring>
        <name>AddSelfContraction</name>
        <qualifiedname>csl::AddSelfContraction</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref> &amp;</type>
          <declname>parent</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>B</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>res</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="519" column="6" bodyfile="src/csl/interface.cpp" bodystart="519" bodyend="525" declfile="src/csl/interface.h" declline="433" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a14694e3ce4d63350b9d0180aaf17ce89" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::AddContractionProperty</definition>
        <argsstring>(csl::Tensor &amp;parent, std::vector&lt; Expr &gt; const &amp;tensors, Expr const &amp;res)</argsstring>
        <name>AddContractionProperty</name>
        <qualifiedname>csl::AddContractionProperty</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref> &amp;</type>
          <declname>parent</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; const &amp;</type>
          <declname>tensors</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>res</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="527" column="6" bodyfile="src/csl/interface.cpp" bodystart="527" bodyend="532" declfile="src/csl/interface.h" declline="438" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a0bdacb64f7e44195c02bfd8e7a4424b8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::AddComplexProperty</definition>
        <argsstring>(csl::Tensor &amp;parent, Expr const &amp;A, Expr const &amp;B)</argsstring>
        <name>AddComplexProperty</name>
        <qualifiedname>csl::AddComplexProperty</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref> &amp;</type>
          <declname>parent</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="534" column="6" bodyfile="src/csl/interface.cpp" bodystart="534" bodyend="537" declfile="src/csl/interface.h" declline="442" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a73c047788103acd2024ebff5c7866895" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::AddTransposedProperty</definition>
        <argsstring>(csl::Tensor &amp;parent, csl::Space const *space, Expr const &amp;A, Expr const &amp;B)</argsstring>
        <name>AddTransposedProperty</name>
        <qualifiedname>csl::AddTransposedProperty</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref> &amp;</type>
          <declname>parent</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Space" kindref="compound">csl::Space</ref> const *</type>
          <declname>space</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="539" column="6" bodyfile="src/csl/interface.cpp" bodystart="539" bodyend="545" declfile="src/csl/interface.h" declline="444" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a9a55d76363aa38a8f938d44ddf544155" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::AddHermitianProperty</definition>
        <argsstring>(csl::Tensor &amp;parent, csl::Space const *space, Expr const &amp;A, Expr const &amp;B)</argsstring>
        <name>AddHermitianProperty</name>
        <qualifiedname>csl::AddHermitianProperty</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref> &amp;</type>
          <declname>parent</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Space" kindref="compound">csl::Space</ref> const *</type>
          <declname>space</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="547" column="6" bodyfile="src/csl/interface.cpp" bodystart="547" bodyend="553" declfile="src/csl/interface.h" declline="449" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a48ec243297d5beb9768c29f61019c263" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1LibDependency" kindref="compound">LibDependency</ref></type>
        <definition>LibDependency csl::GetLibraryDependencies</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>GetLibraryDependencies</name>
        <qualifiedname>csl::GetLibraryDependencies</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="555" column="15" bodyfile="src/csl/interface.cpp" bodystart="555" bodyend="569" declfile="src/csl/interface.h" declline="454" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1acf713387a07a13348155f7043b55c933" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::ApplySelfProperty</definition>
        <argsstring>(Expr &amp;init, csl::Tensor &amp;tensor, Expr const &amp;A, Expr const &amp;B, Expr const &amp;res)</argsstring>
        <name>ApplySelfProperty</name>
        <qualifiedname>csl::ApplySelfProperty</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref> &amp;</type>
          <declname>tensor</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>B</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>res</declname>
        </param>
        <briefdescription>
<para>Declares a self contraction property just the time of a refresh in order to apply it on one expression. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression on which we apply the property. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tensor</parametername>
</parameternamelist>
<parameterdescription>
<para>Indicial tensor that has the property. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>First tensor in the contraction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>Second tensor in the contraction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>res</parametername>
</parameternamelist>
<parameterdescription>
<para>Result of the contraction. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="namespacecsl_1a36d313d19ed9c1b6e4cfbefbb7af7169" kindref="member">ApplyChainProperty()</ref>, AddSelfContraction() , <ref refid="classcsl_1_1TensorParent_1a81eabaf09cb9fe1855a35a91faf3b132" kindref="member">TensorParent::addSelfContraction()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="571" column="6" bodyfile="src/csl/interface.cpp" bodystart="571" bodyend="580" declfile="src/csl/interface.h" declline="927" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a36d313d19ed9c1b6e4cfbefbb7af7169" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::ApplyChainProperty</definition>
        <argsstring>(Expr &amp;init, csl::Tensor &amp;tensor, std::vector&lt; Expr &gt; const &amp;prod, Expr const &amp;res)</argsstring>
        <name>ApplyChainProperty</name>
        <qualifiedname>csl::ApplyChainProperty</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref> &amp;</type>
          <declname>tensor</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; const &amp;</type>
          <declname>prod</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>res</declname>
        </param>
        <briefdescription>
<para>Declares a chain contraction property just the time of a refresh in order to apply it on one expression. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression on which we apply the property. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tensor</parametername>
</parameternamelist>
<parameterdescription>
<para>Indicial tensor that has the property. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>prod</parametername>
</parameternamelist>
<parameterdescription>
<para>Tensors in the contraction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>res</parametername>
</parameternamelist>
<parameterdescription>
<para>Result of the contraction. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="namespacecsl_1a36d313d19ed9c1b6e4cfbefbb7af7169" kindref="member">ApplyChainProperty()</ref>, AddSelfContraction() , <ref refid="classcsl_1_1TensorParent_1a81eabaf09cb9fe1855a35a91faf3b132" kindref="member">TensorParent::addSelfContraction()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="582" column="6" bodyfile="src/csl/interface.cpp" bodystart="582" bodyend="590" declfile="src/csl/interface.h" declline="943" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a9b1baa69edc83c2d90efd6f79bbdb0b4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::CheckValidity</definition>
        <argsstring>(Expr const &amp;init, std::vector&lt; Expr_info &gt; encountered=std::vector&lt; Expr_info &gt;())</argsstring>
        <name>CheckValidity</name>
        <qualifiedname>csl::CheckValidity</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref> &gt;</type>
          <declname>encountered</declname>
          <defval>std::vector&lt; <ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref> &gt;()</defval>
        </param>
        <briefdescription>
<para>Checks the validity of an expression. </para>
        </briefdescription>
        <detaileddescription>
<para>Browses the whole expression and checks that every node of the tree is valid (!= nullptr). <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to check. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>encountered</parametername>
</parameternamelist>
<parameterdescription>
<para>List of expressions already checked. Should not be given by the user in general. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if the expression is valid. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="592" column="6" bodyfile="src/csl/interface.cpp" bodystart="592" bodyend="607" declfile="src/csl/interface.h" declline="958" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a769c039db45134ce7cbdd918da92273b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t csl::MemorySizeOf</definition>
        <argsstring>(Expr const &amp;expression)</argsstring>
        <name>MemorySizeOf</name>
        <qualifiedname>csl::MemorySizeOf</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expression</declname>
        </param>
        <briefdescription>
<para>Calculates an estimate of the total memory that an expression takes. </para>
        </briefdescription>
        <detaileddescription>
<para>This function is not exact. It should be extended. The problem is that it is not possible for class with pointers to determine automatically the size of all elements and pointed elements. It has to be hard coded. This function ignores all pointed elements that are not accessible by the <ref refid="classcsl_1_1Abstract_1ac33a42309d629d47bfdbede4e152414e" kindref="member">Abstract::getArgument()</ref> function. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expression</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression from which we measure the size. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The total (recursive) size in bytes of the expression tree, ignoring all non-Expr pointed elements. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.cpp" line="609" column="8" bodyfile="src/csl/interface.cpp" bodystart="609" bodyend="631" declfile="src/csl/interface.h" declline="975" declcolumn="8"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa9b3631b21546c09b91f2babd823660f" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="namespacecsl_1ace591865c69b6315c533a1a325777312" kindref="member">csl::Type</ref></type>
        <definition>csl::Type csl::GetType</definition>
        <argsstring>(T const &amp;expr)</argsstring>
        <name>GetType</name>
        <qualifiedname>csl::GetType</qualifiedname>
        <param>
          <type>T const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="36" column="19" bodyfile="src/csl/interface.h" bodystart="36" bodyend="39"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a8d3ff0e0c474bc013652a749e30491a0" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="namespacecsl_1ace591865c69b6315c533a1a325777312" kindref="member">csl::Type</ref></type>
        <definition>csl::Type csl::GetPrimaryType</definition>
        <argsstring>(T const &amp;expr)</argsstring>
        <name>GetPrimaryType</name>
        <qualifiedname>csl::GetPrimaryType</qualifiedname>
        <param>
          <type>T const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="41" column="19" bodyfile="src/csl/interface.h" bodystart="41" bodyend="44"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a341d589a60a69404eb57fab4633cacf3" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t csl::Size</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>Size</name>
        <qualifiedname>csl::Size</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="46" column="16" bodyfile="src/csl/interface.h" bodystart="46" bodyend="49"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a482a3d629e32a1f4c1d77061ed8a926f" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::GetArgument</definition>
        <argsstring>(Expr const &amp;expr, size_t pos=0)</argsstring>
        <name>GetArgument</name>
        <qualifiedname>csl::GetArgument</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>pos</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="51" column="14" bodyfile="src/csl/interface.h" bodystart="51" bodyend="54"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a29edb0599112f8a51a4663822109ae01" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::GetCommutable</definition>
        <argsstring>(csl::Expr const &amp;expr)</argsstring>
        <name>GetCommutable</name>
        <qualifiedname>csl::GetCommutable</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="56" column="14" bodyfile="src/csl/interface.h" bodystart="56" bodyend="59"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af7e7e8980e5c268081628a2bbd2c2ba5" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::GetCommutable</definition>
        <argsstring>(csl::Expr_info expr)</argsstring>
        <name>GetCommutable</name>
        <qualifiedname>csl::GetCommutable</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">csl::Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="61" column="14" bodyfile="src/csl/interface.h" bodystart="61" bodyend="64"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa8dd7393b10cc0906bca3c425a8e2178" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::GetCommutable</definition>
        <argsstring>(csl::Abstract const &amp;expr)</argsstring>
        <name>GetCommutable</name>
        <qualifiedname>csl::GetCommutable</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">csl::Abstract</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="66" column="14" bodyfile="src/csl/interface.h" bodystart="66" bodyend="69"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1afb9758f4749012992f37a81d7e7f5ff1" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::DependsOn</definition>
        <argsstring>(Expr const &amp;init, Expr const &amp;x)</argsstring>
        <name>DependsOn</name>
        <qualifiedname>csl::DependsOn</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="75" column="14" bodyfile="src/csl/interface.h" bodystart="75" bodyend="78"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a422849a21824a75cd0fb220b8f8e4909" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::DependsExplicitlyOn</definition>
        <argsstring>(Expr const &amp;init, Expr const &amp;x)</argsstring>
        <name>DependsExplicitlyOn</name>
        <qualifiedname>csl::DependsExplicitlyOn</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="80" column="14" bodyfile="src/csl/interface.h" bodystart="80" bodyend="83"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a5083ece2c4e357494999031377e94380" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::DependsOn</definition>
        <argsstring>(Expr const &amp;init, csl::Parent const &amp;x)</argsstring>
        <name>DependsOn</name>
        <qualifiedname>csl::DependsOn</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Parent" kindref="compound">csl::Parent</ref> const &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="85" column="14" bodyfile="src/csl/interface.h" bodystart="85" bodyend="88"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a4a9147a9a8c0b92c75c945d8f05381cc" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::DependsExplicitlyOn</definition>
        <argsstring>(Expr const &amp;init, csl::Parent const &amp;x)</argsstring>
        <name>DependsExplicitlyOn</name>
        <qualifiedname>csl::DependsExplicitlyOn</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Parent" kindref="compound">csl::Parent</ref> const &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="90" column="14" bodyfile="src/csl/interface.h" bodystart="90" bodyend="94"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1afd4c329210a2483aa1eaf3f3469a3167" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::DeepExpand</definition>
        <argsstring>(Expr &amp;expression, bool inplace=false)</argsstring>
        <name>DeepExpand</name>
        <qualifiedname>csl::DeepExpand</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>inplace</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="111" column="13" bodyfile="src/csl/interface.h" bodystart="111" bodyend="114"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ac0b240c02119affaf20698ba373dba35" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::DeepExpanded</definition>
        <argsstring>(Expr const &amp;expression, bool inplace=false)</argsstring>
        <name>DeepExpanded</name>
        <qualifiedname>csl::DeepExpanded</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>inplace</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="116" column="14" bodyfile="src/csl/interface.h" bodystart="116" bodyend="120"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a82647f36d65a0c38a98a2a0fed8756c2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::DeepExpandIf</definition>
        <argsstring>(Expr &amp;expression, std::function&lt; bool(Expr const &amp;)&gt; const &amp;f, bool inplace=false)</argsstring>
        <name>DeepExpandIf</name>
        <qualifiedname>csl::DeepExpandIf</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>inplace</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="122" column="13" bodyfile="src/csl/interface.h" bodystart="122" bodyend="127"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae1254126d4d45678acf1d1ae6d37026e" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::DeepExpandedIf</definition>
        <argsstring>(Expr const &amp;expression, std::function&lt; bool(Expr const &amp;)&gt; const &amp;f, bool inplace=false)</argsstring>
        <name>DeepExpandedIf</name>
        <qualifiedname>csl::DeepExpandedIf</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>inplace</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="130" column="1" bodyfile="src/csl/interface.h" bodystart="130" bodyend="135"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a03b76b9fb6118f082652bceba66ccc49" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Factor</definition>
        <argsstring>(Expr &amp;expression, Expr const &amp;factor, bool full=false)</argsstring>
        <name>Factor</name>
        <qualifiedname>csl::Factor</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>factor</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="154" column="13" bodyfile="src/csl/interface.h" bodystart="154" bodyend="157"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1abab094de47a77da60eeca35fb8e4474d" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Factored</definition>
        <argsstring>(const Expr &amp;expression, const Expr &amp;factor, bool full=false)</argsstring>
        <name>Factored</name>
        <qualifiedname>csl::Factored</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>factor</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="165" column="1" bodyfile="src/csl/interface.h" bodystart="165" bodyend="168"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a5d2601fcd2b63899c640ccf5c7e8c112" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::DeepFactor</definition>
        <argsstring>(Expr &amp;expression)</argsstring>
        <name>DeepFactor</name>
        <qualifiedname>csl::DeepFactor</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="170" column="13" bodyfile="src/csl/interface.h" bodystart="170" bodyend="173"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a523b38f44ab1e531d991f24e2f282250" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::DeepFactor</definition>
        <argsstring>(Expr &amp;expression, Expr_info factor)</argsstring>
        <name>DeepFactor</name>
        <qualifiedname>csl::DeepFactor</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>factor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="175" column="13" bodyfile="src/csl/interface.h" bodystart="175" bodyend="178"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af341c96c577aeaf097b7b82529c6f303" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::DeepFactor</definition>
        <argsstring>(Expr &amp;expression, Expr const &amp;factor)</argsstring>
        <name>DeepFactor</name>
        <qualifiedname>csl::DeepFactor</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>factor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="180" column="13" bodyfile="src/csl/interface.h" bodystart="180" bodyend="183"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a0f27136f944537f727f7f342e9287f6c" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::DeepFactored</definition>
        <argsstring>(const Expr &amp;expression)</argsstring>
        <name>DeepFactored</name>
        <qualifiedname>csl::DeepFactored</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="185" column="14" bodyfile="src/csl/interface.h" bodystart="185" bodyend="188"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a321242441e08f7c1cab66d9552b540ad" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::DeepFactored</definition>
        <argsstring>(const Expr &amp;expression, Expr_info factor)</argsstring>
        <name>DeepFactored</name>
        <qualifiedname>csl::DeepFactored</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>factor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="190" column="14" bodyfile="src/csl/interface.h" bodystart="190" bodyend="194"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a1d747efebadc290f2f2ddb19162de1d1" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::DeepFactored</definition>
        <argsstring>(const Expr &amp;expression, const Expr &amp;factor)</argsstring>
        <name>DeepFactored</name>
        <qualifiedname>csl::DeepFactored</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>factor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="196" column="14" bodyfile="src/csl/interface.h" bodystart="196" bodyend="200"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ac18cd148f86ef78869887dd0280f5bab" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Distributed</definition>
        <argsstring>(Expr const &amp;expression, Expr const &amp;factor, bool full=false)</argsstring>
        <name>Distributed</name>
        <qualifiedname>csl::Distributed</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>factor</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="215" column="1" bodyfile="src/csl/interface.h" bodystart="215" bodyend="218"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af9688960aa80989e461d3a9315fc1daa" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Distribute</definition>
        <argsstring>(Expr &amp;expression, Expr const &amp;factor, bool full=false)</argsstring>
        <name>Distribute</name>
        <qualifiedname>csl::Distribute</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>factor</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="220" column="13" bodyfile="src/csl/interface.h" bodystart="220" bodyend="223"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a16a0a6f6486706c34707b44ee33dd5b3" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::DeepDistributed</definition>
        <argsstring>(Expr const &amp;expression, Expr_info factor)</argsstring>
        <name>DeepDistributed</name>
        <qualifiedname>csl::DeepDistributed</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>factor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="225" column="14" bodyfile="src/csl/interface.h" bodystart="225" bodyend="229"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a4f0b2d12e78277ca9316a7083d67a9da" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::DeepDistribute</definition>
        <argsstring>(Expr &amp;expression, Expr_info factor)</argsstring>
        <name>DeepDistribute</name>
        <qualifiedname>csl::DeepDistribute</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>factor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="231" column="13" bodyfile="src/csl/interface.h" bodystart="231" bodyend="234"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a452b0e919e36ed174b5d85c81465af4f" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::DeepDistributed</definition>
        <argsstring>(Expr const &amp;expression, Expr const &amp;factor)</argsstring>
        <name>DeepDistributed</name>
        <qualifiedname>csl::DeepDistributed</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>factor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="236" column="14" bodyfile="src/csl/interface.h" bodystart="236" bodyend="240"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a1c502965ecc1bf2b540c45730534df7b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::DeepDistribute</definition>
        <argsstring>(Expr &amp;expression, Expr const &amp;factor)</argsstring>
        <name>DeepDistribute</name>
        <qualifiedname>csl::DeepDistribute</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>factor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="242" column="13" bodyfile="src/csl/interface.h" bodystart="242" bodyend="245"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2da501c019889436033ebc8021234d46" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Distributed</definition>
        <argsstring>(Expr const &amp;expression, Parent const &amp;factor, bool full=false)</argsstring>
        <name>Distributed</name>
        <qualifiedname>csl::Distributed</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref> const &amp;</type>
          <declname>factor</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="253" column="1" bodyfile="src/csl/interface.h" bodystart="253" bodyend="256"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a55baea7e93f55c404d4012473b118d61" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Distribute</definition>
        <argsstring>(Expr &amp;expression, Parent const &amp;factor, bool full=false)</argsstring>
        <name>Distribute</name>
        <qualifiedname>csl::Distribute</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref> const &amp;</type>
          <declname>factor</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="259" column="1" bodyfile="src/csl/interface.h" bodystart="259" bodyend="262"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a59e0d3c266390fce166f09cd000fff91" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::DeepDistributed</definition>
        <argsstring>(Expr const &amp;expression, Parent_info factor)</argsstring>
        <name>DeepDistributed</name>
        <qualifiedname>csl::DeepDistributed</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1AbstractParent" kindref="compound">Parent_info</ref></type>
          <declname>factor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="264" column="14" bodyfile="src/csl/interface.h" bodystart="264" bodyend="268"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a226d09b96915263fb992a59a4e11c162" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::DeepDistribute</definition>
        <argsstring>(Expr &amp;expression, Parent_info factor)</argsstring>
        <name>DeepDistribute</name>
        <qualifiedname>csl::DeepDistribute</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1AbstractParent" kindref="compound">Parent_info</ref></type>
          <declname>factor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="270" column="13" bodyfile="src/csl/interface.h" bodystart="270" bodyend="273"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ac2656461b31efecdf181c684de8663b6" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::DeepDistributed</definition>
        <argsstring>(Expr const &amp;expression, Parent const &amp;factor)</argsstring>
        <name>DeepDistributed</name>
        <qualifiedname>csl::DeepDistributed</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref> const &amp;</type>
          <declname>factor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="275" column="14" bodyfile="src/csl/interface.h" bodystart="275" bodyend="279"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a3f3c31a53c12157df8b51d9f8c867e8f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::DeepDistribute</definition>
        <argsstring>(Expr &amp;expression, Parent const &amp;factor)</argsstring>
        <name>DeepDistribute</name>
        <qualifiedname>csl::DeepDistribute</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref> const &amp;</type>
          <declname>factor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="281" column="13" bodyfile="src/csl/interface.h" bodystart="281" bodyend="284"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a1943344b18e34fec6f1a10722809b446" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::DeepDistributedIf</definition>
        <argsstring>(Expr const &amp;expression, std::function&lt; bool(Expr const &amp;)&gt; f)</argsstring>
        <name>DeepDistributedIf</name>
        <qualifiedname>csl::DeepDistributedIf</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="295" column="1" bodyfile="src/csl/interface.h" bodystart="295" bodyend="298"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1abb0f01d822c3f234a96dcbb6a5722c27" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::DeepDistributeIf</definition>
        <argsstring>(Expr &amp;expression, std::function&lt; bool(Expr const &amp;)&gt; f)</argsstring>
        <name>DeepDistributeIf</name>
        <qualifiedname>csl::DeepDistributeIf</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;)&gt;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="300" column="13" bodyfile="src/csl/interface.h" bodystart="300" bodyend="304"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ad82ea078f93ac899142f931e936f5ab7" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Derived</definition>
        <argsstring>(const Expr &amp;expression, const Expr &amp;variable)</argsstring>
        <name>Derived</name>
        <qualifiedname>csl::Derived</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>variable</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="310" column="14" bodyfile="src/csl/interface.h" bodystart="310" bodyend="313"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa381b21aa4a4189d0ad2b317c303fbfb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Derive</definition>
        <argsstring>(Expr &amp;expression, Expr_info variable)</argsstring>
        <name>Derive</name>
        <qualifiedname>csl::Derive</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>variable</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="315" column="13" bodyfile="src/csl/interface.h" bodystart="315" bodyend="318"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a514cdcb2c708e825ec620bf630d42d6d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Derive</definition>
        <argsstring>(Expr &amp;expression, const Expr &amp;variable)</argsstring>
        <name>Derive</name>
        <qualifiedname>csl::Derive</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>variable</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="320" column="13" bodyfile="src/csl/interface.h" bodystart="320" bodyend="323"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a9211472bbbb158e17ae24fc9818c53d2" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::GetPolynomialTerm</definition>
        <argsstring>(const Expr &amp;expression, const Expr &amp;variable, int order)</argsstring>
        <name>GetPolynomialTerm</name>
        <qualifiedname>csl::GetPolynomialTerm</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>variable</declname>
        </param>
        <param>
          <type>int</type>
          <declname>order</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="329" column="1" bodyfile="src/csl/interface.h" bodystart="329" bodyend="332"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a92933402f5684f9ddf75af6b78f0a695" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Evaluate</definition>
        <argsstring>(Expr &amp;expr)</argsstring>
        <name>Evaluate</name>
        <qualifiedname>csl::Evaluate</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="339" column="13" bodyfile="src/csl/interface.h" bodystart="339" bodyend="342"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ab0013e5d0bcf5e7643e4a0c65d4a75a4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Evaluate</definition>
        <argsstring>(Expr &amp;expr, eval::mode user_mode)</argsstring>
        <name>Evaluate</name>
        <qualifiedname>csl::Evaluate</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>eval::mode</type>
          <declname>user_mode</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="344" column="13" bodyfile="src/csl/interface.h" bodystart="344" bodyend="347"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a85346c691f188091562545ed84088f88" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void csl::SetComplexProperty</definition>
        <argsstring>(T parent, ComplexProperty prop)</argsstring>
        <name>SetComplexProperty</name>
        <qualifiedname>csl::SetComplexProperty</qualifiedname>
        <param>
          <type>T</type>
          <declname>parent</declname>
        </param>
        <param>
          <type><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0e" kindref="member">ComplexProperty</ref></type>
          <declname>prop</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="358" column="13" bodyfile="src/csl/interface.h" bodystart="358" bodyend="362"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aef1dbfb6a20bb2ab0317b1cc91be74b1" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::GetTransposed</definition>
        <argsstring>(const Expr &amp;expression, const std::vector&lt; const Space * &gt; &amp;spaces, bool applyProp=true)</argsstring>
        <name>GetTransposed</name>
        <qualifiedname>csl::GetTransposed</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>const std::vector&lt; const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> * &gt; &amp;</type>
          <declname>spaces</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>applyProp</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="378" column="7" bodyfile="src/csl/interface.cpp" bodystart="365" bodyend="370" declfile="src/csl/interface.h" declline="378" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1adea8c0b9858cf2c236789620e16d9e95" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::GetHermitianConjugate</definition>
        <argsstring>(const Expr &amp;expression, const std::vector&lt; const Space * &gt; &amp;spaces)</argsstring>
        <name>GetHermitianConjugate</name>
        <qualifiedname>csl::GetHermitianConjugate</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>const std::vector&lt; const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> * &gt; &amp;</type>
          <declname>spaces</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="386" column="1" bodyfile="src/csl/interface.cpp" bodystart="377" bodyend="381" declfile="src/csl/interface.h" declline="386" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa2aa2a457a2d1c52d76643c0a4f1c69c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void csl::Swap</definition>
        <argsstring>(Expr &amp;expression, T const &amp;old_obj, T const &amp;new_obj)</argsstring>
        <name>Swap</name>
        <qualifiedname>csl::Swap</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>T const &amp;</type>
          <declname>old_obj</declname>
        </param>
        <param>
          <type>T const &amp;</type>
          <declname>new_obj</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="405" column="13" bodyfile="src/csl/interface.h" bodystart="405" bodyend="408"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1adcdebc6a45b5f4a79f0c3780e358a51e" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsIndexed</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsIndexed</name>
        <qualifiedname>csl::IsIndexed</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="456" column="14" bodyfile="src/csl/interface.h" bodystart="456" bodyend="459"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a7ce59c190b45bcc8a74af071c6d3fad8" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsNumerical</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsNumerical</name>
        <qualifiedname>csl::IsNumerical</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="460" column="14" bodyfile="src/csl/interface.h" bodystart="460" bodyend="463"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a95d128d954d296aac31d65ff8da1a108" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsLiteral</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsLiteral</name>
        <qualifiedname>csl::IsLiteral</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="464" column="14" bodyfile="src/csl/interface.h" bodystart="464" bodyend="467"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1afeb4d6f5489e26f2ec4109b55d88860f" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsScalarFunction</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsScalarFunction</name>
        <qualifiedname>csl::IsScalarFunction</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="468" column="14" bodyfile="src/csl/interface.h" bodystart="468" bodyend="471"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ad7222d17cb16522b99386de9f13c8d7a" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsMultiFunction</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsMultiFunction</name>
        <qualifiedname>csl::IsMultiFunction</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="472" column="14" bodyfile="src/csl/interface.h" bodystart="472" bodyend="475"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a1fa801bd8a4ed4fd370b6d501bd5e886" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsVectorial</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsVectorial</name>
        <qualifiedname>csl::IsVectorial</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="476" column="14" bodyfile="src/csl/interface.h" bodystart="476" bodyend="479"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aec4e989ba8526376f53aabc053b43a3a" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsIndicial</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsIndicial</name>
        <qualifiedname>csl::IsIndicial</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="480" column="14" bodyfile="src/csl/interface.h" bodystart="480" bodyend="483"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ad45e1e3b62dcc3fef64cf4a5956543b6" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsField</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsField</name>
        <qualifiedname>csl::IsField</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="484" column="14" bodyfile="src/csl/interface.h" bodystart="484" bodyend="487"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1abc4f041b6871d886a0533b208e13c47b" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsArbitrary</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsArbitrary</name>
        <qualifiedname>csl::IsArbitrary</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="488" column="14" bodyfile="src/csl/interface.h" bodystart="488" bodyend="491"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a710459bfd53ea481ad2e1db6838c945c" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsInteger</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsInteger</name>
        <qualifiedname>csl::IsInteger</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="493" column="14" bodyfile="src/csl/interface.h" bodystart="493" bodyend="496"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a334fa354bbfba58cb234379d2937eae2" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsFloat</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsFloat</name>
        <qualifiedname>csl::IsFloat</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="497" column="14" bodyfile="src/csl/interface.h" bodystart="497" bodyend="500"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2c3e9ec5328f36ffbc0fea1465fee6fd" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsIntFraction</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsIntFraction</name>
        <qualifiedname>csl::IsIntFraction</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="501" column="14" bodyfile="src/csl/interface.h" bodystart="501" bodyend="504"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aeb7161252442ca7268f911fb8372ee57" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsIntFactorial</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsIntFactorial</name>
        <qualifiedname>csl::IsIntFactorial</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="505" column="14" bodyfile="src/csl/interface.h" bodystart="505" bodyend="508"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a88c4d02701c0a2c62125c01e0b504ae0" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsComplex</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsComplex</name>
        <qualifiedname>csl::IsComplex</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="509" column="14" bodyfile="src/csl/interface.h" bodystart="509" bodyend="512"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa46d2aa651dff22500e8002a35dc60d5" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsNumericalEval</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsNumericalEval</name>
        <qualifiedname>csl::IsNumericalEval</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="513" column="14" bodyfile="src/csl/interface.h" bodystart="513" bodyend="516"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a7d159276ee9d2e0b18f548d121398add" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsImaginary</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsImaginary</name>
        <qualifiedname>csl::IsImaginary</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="517" column="14" bodyfile="src/csl/interface.h" bodystart="517" bodyend="520"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ac950c24421d95a69b268669d70417d7f" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsConstant</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsConstant</name>
        <qualifiedname>csl::IsConstant</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="521" column="14" bodyfile="src/csl/interface.h" bodystart="521" bodyend="524"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a96da9988f9257092883eb38d8b80682e" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsVariable</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsVariable</name>
        <qualifiedname>csl::IsVariable</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="525" column="14" bodyfile="src/csl/interface.h" bodystart="525" bodyend="528"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a7ac72d5b322559cd6689bba23c572612" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsExp</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsExp</name>
        <qualifiedname>csl::IsExp</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="529" column="14" bodyfile="src/csl/interface.h" bodystart="529" bodyend="532"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a6e2ad94e66dfbefa911129b3026d1fa2" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsLog</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsLog</name>
        <qualifiedname>csl::IsLog</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="533" column="14" bodyfile="src/csl/interface.h" bodystart="533" bodyend="536"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aeda0fe72bd886bdb32043ff72bd3cb26" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsDiracDelta</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsDiracDelta</name>
        <qualifiedname>csl::IsDiracDelta</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="537" column="14" bodyfile="src/csl/interface.h" bodystart="537" bodyend="540"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2416a821c5efdeb01e94d41458b7831a" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsAbs</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsAbs</name>
        <qualifiedname>csl::IsAbs</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="541" column="14" bodyfile="src/csl/interface.h" bodystart="541" bodyend="544"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a1ea3d0182b0e531af9e692e213462ca6" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsCos</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsCos</name>
        <qualifiedname>csl::IsCos</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="545" column="14" bodyfile="src/csl/interface.h" bodystart="545" bodyend="548"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1abb77965dbb36f49a9f19a5a6c2b561b6" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsSin</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsSin</name>
        <qualifiedname>csl::IsSin</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="549" column="14" bodyfile="src/csl/interface.h" bodystart="549" bodyend="552"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1abbb3dffea91a96130edee4dedead53c1" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsTan</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsTan</name>
        <qualifiedname>csl::IsTan</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="553" column="14" bodyfile="src/csl/interface.h" bodystart="553" bodyend="556"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ad3e11a78d9bec3070c5984dc6bef7d17" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsCosh</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsCosh</name>
        <qualifiedname>csl::IsCosh</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="557" column="14" bodyfile="src/csl/interface.h" bodystart="557" bodyend="560"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af5961b6b86af88051cedb62a61e1d70d" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsSinh</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsSinh</name>
        <qualifiedname>csl::IsSinh</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="561" column="14" bodyfile="src/csl/interface.h" bodystart="561" bodyend="564"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a5e957b735200dac17c6ce041f0ffddb8" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsTanh</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsTanh</name>
        <qualifiedname>csl::IsTanh</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="565" column="14" bodyfile="src/csl/interface.h" bodystart="565" bodyend="568"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aabc42d7d43012d09e1f26f25e25c759a" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsACos</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsACos</name>
        <qualifiedname>csl::IsACos</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="569" column="14" bodyfile="src/csl/interface.h" bodystart="569" bodyend="572"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a297062416977feccfe2d0049345a46d1" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsASin</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsASin</name>
        <qualifiedname>csl::IsASin</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="573" column="14" bodyfile="src/csl/interface.h" bodystart="573" bodyend="576"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2236666ea79e847e541266964fa599a7" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsATan</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsATan</name>
        <qualifiedname>csl::IsATan</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="577" column="14" bodyfile="src/csl/interface.h" bodystart="577" bodyend="580"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a19e3dc6e03acbe860eca4c535402ba4e" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsACosh</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsACosh</name>
        <qualifiedname>csl::IsACosh</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="581" column="14" bodyfile="src/csl/interface.h" bodystart="581" bodyend="584"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a93cc636ab347701b35eccffc259233ec" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsASinh</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsASinh</name>
        <qualifiedname>csl::IsASinh</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="585" column="14" bodyfile="src/csl/interface.h" bodystart="585" bodyend="588"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a0a539727f85b416cf83e996686757fb2" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsATanh</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsATanh</name>
        <qualifiedname>csl::IsATanh</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="589" column="14" bodyfile="src/csl/interface.h" bodystart="589" bodyend="592"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a876cbba4d3c563e504a8eb2ba4342cab" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsScalar</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsScalar</name>
        <qualifiedname>csl::IsScalar</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="593" column="14" bodyfile="src/csl/interface.h" bodystart="593" bodyend="596"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a5e61aee45db218372b0397a297f6f726" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsRealPart</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsRealPart</name>
        <qualifiedname>csl::IsRealPart</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="597" column="14" bodyfile="src/csl/interface.h" bodystart="597" bodyend="600"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a5628e6082a9900e297ff04fa273213b6" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsImaginaryPart</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsImaginaryPart</name>
        <qualifiedname>csl::IsImaginaryPart</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="601" column="14" bodyfile="src/csl/interface.h" bodystart="601" bodyend="604"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ac9e2e843891be6a1b40ca8eb87dbae42" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsITensor</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsITensor</name>
        <qualifiedname>csl::IsITensor</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="605" column="14" bodyfile="src/csl/interface.h" bodystart="605" bodyend="608"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa0500be7ecabbe4dd34715a769fbb03f" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsScalarField</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsScalarField</name>
        <qualifiedname>csl::IsScalarField</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="609" column="14" bodyfile="src/csl/interface.h" bodystart="609" bodyend="612"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a4be2947ffc58e823462aacdc020a7d78" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsTensorField</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsTensorField</name>
        <qualifiedname>csl::IsTensorField</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="613" column="14" bodyfile="src/csl/interface.h" bodystart="613" bodyend="616"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af2193785686eacaa5c8823ee8086379b" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsTensorialDerivative</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsTensorialDerivative</name>
        <qualifiedname>csl::IsTensorialDerivative</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="617" column="14" bodyfile="src/csl/interface.h" bodystart="617" bodyend="620"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa465fba90e9f3781f1ed8ea346ebf7ca" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsStandardDuo</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsStandardDuo</name>
        <qualifiedname>csl::IsStandardDuo</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="621" column="14" bodyfile="src/csl/interface.h" bodystart="621" bodyend="624"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a07f4b3bebaafcc8b8ff994f6b1487f27" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsStandardMult</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsStandardMult</name>
        <qualifiedname>csl::IsStandardMult</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="625" column="14" bodyfile="src/csl/interface.h" bodystart="625" bodyend="628"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae0ade8727691988bbbef117643c1ab0f" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsPow</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsPow</name>
        <qualifiedname>csl::IsPow</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="629" column="14" bodyfile="src/csl/interface.h" bodystart="629" bodyend="632"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1abb9ea487f51b0883293e1483933ca1fb" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsProd</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsProd</name>
        <qualifiedname>csl::IsProd</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="633" column="14" bodyfile="src/csl/interface.h" bodystart="633" bodyend="636"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2c0f93949297db79dee52dcca93e666b" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsSum</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsSum</name>
        <qualifiedname>csl::IsSum</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="637" column="14" bodyfile="src/csl/interface.h" bodystart="637" bodyend="640"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aeca47f1fc9c0f1f22fd8aeeb49008a54" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsPolynomial</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsPolynomial</name>
        <qualifiedname>csl::IsPolynomial</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="641" column="14" bodyfile="src/csl/interface.h" bodystart="641" bodyend="644"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a9223e0ed91dbf7a77b168058915d7f01" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsDerivative</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsDerivative</name>
        <qualifiedname>csl::IsDerivative</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="645" column="14" bodyfile="src/csl/interface.h" bodystart="645" bodyend="648"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2ee8eb88195d43364dfaadbfc5d69044" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsCommutator</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsCommutator</name>
        <qualifiedname>csl::IsCommutator</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="649" column="14" bodyfile="src/csl/interface.h" bodystart="649" bodyend="652"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1accda8cc479ae563e1e81d5e21447ec87" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsAngle</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsAngle</name>
        <qualifiedname>csl::IsAngle</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="653" column="14" bodyfile="src/csl/interface.h" bodystart="653" bodyend="656"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ad35abcd5f7253764ed2d15670551bd51" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsFactorial</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsFactorial</name>
        <qualifiedname>csl::IsFactorial</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="657" column="14" bodyfile="src/csl/interface.h" bodystart="657" bodyend="660"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a6df0bbf92952a6d925b4ed2d29cc1538" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsIntegral</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsIntegral</name>
        <qualifiedname>csl::IsIntegral</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="661" column="14" bodyfile="src/csl/interface.h" bodystart="661" bodyend="664"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a5732eea87d5e76e66774d8eee7ee5e53" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsScalarIntegral</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsScalarIntegral</name>
        <qualifiedname>csl::IsScalarIntegral</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="665" column="14" bodyfile="src/csl/interface.h" bodystart="665" bodyend="668"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a6b556e46550d5d20cb90d3d195240d0a" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsVectorIntegral</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsVectorIntegral</name>
        <qualifiedname>csl::IsVectorIntegral</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="669" column="14" bodyfile="src/csl/interface.h" bodystart="669" bodyend="672"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a423118242d83867ff1db9f929ed93cdd" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsVector</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsVector</name>
        <qualifiedname>csl::IsVector</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="673" column="14" bodyfile="src/csl/interface.h" bodystart="673" bodyend="676"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a47eb06fcee3a9ac1940ce563efdc006c" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsMatrix</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsMatrix</name>
        <qualifiedname>csl::IsMatrix</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="677" column="14" bodyfile="src/csl/interface.h" bodystart="677" bodyend="680"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a35d31c8e21a1b5e7cb351ec309ec1d71" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsHighDTensor</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>IsHighDTensor</name>
        <qualifiedname>csl::IsHighDTensor</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="681" column="14" bodyfile="src/csl/interface.h" bodystart="681" bodyend="684"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a1b0613b18ae95c84a405ae99d1ebaaea" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsIndexed</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsIndexed</name>
        <qualifiedname>csl::IsIndexed</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="686" column="14" bodyfile="src/csl/interface.h" bodystart="686" bodyend="689"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae16b218bb07e4e61c026e0ef1ee21ba2" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsNumerical</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsNumerical</name>
        <qualifiedname>csl::IsNumerical</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="690" column="14" bodyfile="src/csl/interface.h" bodystart="690" bodyend="693"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa5f62b4bccc65d20101d3b26e3e3926e" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsLiteral</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsLiteral</name>
        <qualifiedname>csl::IsLiteral</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="694" column="14" bodyfile="src/csl/interface.h" bodystart="694" bodyend="697"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ad33d96f4bcf6d0582b4277373fca8b54" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsScalarFunction</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsScalarFunction</name>
        <qualifiedname>csl::IsScalarFunction</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="698" column="14" bodyfile="src/csl/interface.h" bodystart="698" bodyend="701"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a17214565f959cdaa4553ee6170861cea" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsMultiFunction</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsMultiFunction</name>
        <qualifiedname>csl::IsMultiFunction</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="702" column="14" bodyfile="src/csl/interface.h" bodystart="702" bodyend="705"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a427068961aa2a431fc082db2fe838041" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsVectorial</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsVectorial</name>
        <qualifiedname>csl::IsVectorial</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="706" column="14" bodyfile="src/csl/interface.h" bodystart="706" bodyend="709"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa8f876c93d62d7f199d44e8e140ac083" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsIndicial</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsIndicial</name>
        <qualifiedname>csl::IsIndicial</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="710" column="14" bodyfile="src/csl/interface.h" bodystart="710" bodyend="713"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a44233c9cef2cffd563b91d235b9351b6" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsField</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsField</name>
        <qualifiedname>csl::IsField</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="714" column="14" bodyfile="src/csl/interface.h" bodystart="714" bodyend="717"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2844344bbf4fa33601014aa26a310262" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsArbitrary</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsArbitrary</name>
        <qualifiedname>csl::IsArbitrary</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="718" column="14" bodyfile="src/csl/interface.h" bodystart="718" bodyend="721"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a9f2fff39a2dd71b3b3aa40c614a589e4" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsInteger</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsInteger</name>
        <qualifiedname>csl::IsInteger</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="723" column="14" bodyfile="src/csl/interface.h" bodystart="723" bodyend="726"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a21e3c07e21bf99bfff307b5baafb3db8" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsFloat</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsFloat</name>
        <qualifiedname>csl::IsFloat</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="727" column="14" bodyfile="src/csl/interface.h" bodystart="727" bodyend="730"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a31de1fd017dbb1fba7d0be41aa4e7ffd" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsIntFraction</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsIntFraction</name>
        <qualifiedname>csl::IsIntFraction</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="731" column="14" bodyfile="src/csl/interface.h" bodystart="731" bodyend="734"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a10a7f9c9ac4e4567ba4b4714ad71fe36" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsIntFactorial</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsIntFactorial</name>
        <qualifiedname>csl::IsIntFactorial</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="735" column="14" bodyfile="src/csl/interface.h" bodystart="735" bodyend="738"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a065eb450f2568ff402e5d8b1b7a0dbcf" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsComplex</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsComplex</name>
        <qualifiedname>csl::IsComplex</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="739" column="14" bodyfile="src/csl/interface.h" bodystart="739" bodyend="742"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af9bc768952cfad359299c6d1d76b2ba2" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsNumericalEval</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsNumericalEval</name>
        <qualifiedname>csl::IsNumericalEval</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="743" column="14" bodyfile="src/csl/interface.h" bodystart="743" bodyend="746"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a333eefc5eef357e93df4b16d08e24c09" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsImaginary</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsImaginary</name>
        <qualifiedname>csl::IsImaginary</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="747" column="14" bodyfile="src/csl/interface.h" bodystart="747" bodyend="750"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aeb54f1a23c9696f5471e1cdd4b1e5a6b" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsConstant</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsConstant</name>
        <qualifiedname>csl::IsConstant</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="751" column="14" bodyfile="src/csl/interface.h" bodystart="751" bodyend="754"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aaf08728279011339fb8d406c4b297174" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsVariable</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsVariable</name>
        <qualifiedname>csl::IsVariable</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="755" column="14" bodyfile="src/csl/interface.h" bodystart="755" bodyend="758"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a6bc8db92414c195f688fb3cf94ff5b63" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsExp</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsExp</name>
        <qualifiedname>csl::IsExp</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="759" column="14" bodyfile="src/csl/interface.h" bodystart="759" bodyend="762"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a0513e1bfbdff5058652825ff3be0107f" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsLog</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsLog</name>
        <qualifiedname>csl::IsLog</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="763" column="14" bodyfile="src/csl/interface.h" bodystart="763" bodyend="766"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a25aacf04c1568e2a57a28610b144d71f" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsDiracDelta</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsDiracDelta</name>
        <qualifiedname>csl::IsDiracDelta</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="767" column="14" bodyfile="src/csl/interface.h" bodystart="767" bodyend="770"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af48faf443eecc89724a5a460620b2dfc" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsAbs</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsAbs</name>
        <qualifiedname>csl::IsAbs</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="771" column="14" bodyfile="src/csl/interface.h" bodystart="771" bodyend="774"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1acf343a105a87d08abc656b80bc99a7f0" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsCos</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsCos</name>
        <qualifiedname>csl::IsCos</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="775" column="14" bodyfile="src/csl/interface.h" bodystart="775" bodyend="778"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aed5749555cc4d22dad93eb1d1700ac87" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsSin</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsSin</name>
        <qualifiedname>csl::IsSin</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="779" column="14" bodyfile="src/csl/interface.h" bodystart="779" bodyend="782"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa63f05f19671a844cf8a184f1aef2206" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsTan</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsTan</name>
        <qualifiedname>csl::IsTan</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="783" column="14" bodyfile="src/csl/interface.h" bodystart="783" bodyend="786"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a720fdedbf6fb795fc84b768120074639" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsCosh</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsCosh</name>
        <qualifiedname>csl::IsCosh</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="787" column="14" bodyfile="src/csl/interface.h" bodystart="787" bodyend="790"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a331028fd8ec22818062aa898a6079d50" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsSinh</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsSinh</name>
        <qualifiedname>csl::IsSinh</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="791" column="14" bodyfile="src/csl/interface.h" bodystart="791" bodyend="794"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a07ad4c786aa9d03d7ffc60a15878ea93" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsTanh</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsTanh</name>
        <qualifiedname>csl::IsTanh</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="795" column="14" bodyfile="src/csl/interface.h" bodystart="795" bodyend="798"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2e1975dc7b698a9275626ffd4101db1f" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsACos</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsACos</name>
        <qualifiedname>csl::IsACos</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="799" column="14" bodyfile="src/csl/interface.h" bodystart="799" bodyend="802"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a4debb35e9238cf1bc3d7d75f0a365053" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsASin</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsASin</name>
        <qualifiedname>csl::IsASin</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="803" column="14" bodyfile="src/csl/interface.h" bodystart="803" bodyend="806"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a147dc80496a6f67152e662f98d51b9e1" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsATan</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsATan</name>
        <qualifiedname>csl::IsATan</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="807" column="14" bodyfile="src/csl/interface.h" bodystart="807" bodyend="810"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1adec9be26f4c25f34bac664768a3ef9e0" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsACosh</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsACosh</name>
        <qualifiedname>csl::IsACosh</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="811" column="14" bodyfile="src/csl/interface.h" bodystart="811" bodyend="814"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ab2e32028129f006371889f9a269b1dbe" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsASinh</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsASinh</name>
        <qualifiedname>csl::IsASinh</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="815" column="14" bodyfile="src/csl/interface.h" bodystart="815" bodyend="818"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a7ddfd9815a501bdd9f274957d76531bb" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsATanh</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsATanh</name>
        <qualifiedname>csl::IsATanh</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="819" column="14" bodyfile="src/csl/interface.h" bodystart="819" bodyend="822"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae47ebdf65a6c1af60b015330274fc90a" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsScalar</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsScalar</name>
        <qualifiedname>csl::IsScalar</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="823" column="14" bodyfile="src/csl/interface.h" bodystart="823" bodyend="826"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a04415f7177cdd01dfbee736d3af1ebe0" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsRealPart</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsRealPart</name>
        <qualifiedname>csl::IsRealPart</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="827" column="14" bodyfile="src/csl/interface.h" bodystart="827" bodyend="830"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a43af5bfd88aa39510319961e0a40283d" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsImaginaryPart</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsImaginaryPart</name>
        <qualifiedname>csl::IsImaginaryPart</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="831" column="14" bodyfile="src/csl/interface.h" bodystart="831" bodyend="834"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a058e76a70707cb6495e68999321eab53" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsITensor</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsITensor</name>
        <qualifiedname>csl::IsITensor</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="835" column="14" bodyfile="src/csl/interface.h" bodystart="835" bodyend="838"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ac15e71665b009e4b3f538f0283fba808" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsScalarField</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsScalarField</name>
        <qualifiedname>csl::IsScalarField</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="839" column="14" bodyfile="src/csl/interface.h" bodystart="839" bodyend="842"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a4bd3f45e45bb6470250b0345796262b9" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsTensorField</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsTensorField</name>
        <qualifiedname>csl::IsTensorField</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="843" column="14" bodyfile="src/csl/interface.h" bodystart="843" bodyend="846"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a567aee305288c0334c4302d75ab96db3" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsTensorialDerivative</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsTensorialDerivative</name>
        <qualifiedname>csl::IsTensorialDerivative</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="847" column="14" bodyfile="src/csl/interface.h" bodystart="847" bodyend="850"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a19ceba70ba5bfb0367ce25c1f0aef2d0" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsStandardDuo</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsStandardDuo</name>
        <qualifiedname>csl::IsStandardDuo</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="851" column="14" bodyfile="src/csl/interface.h" bodystart="851" bodyend="854"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a39ca8cfa9536d37bbaed82e75276b4b7" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsStandardMult</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsStandardMult</name>
        <qualifiedname>csl::IsStandardMult</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="855" column="14" bodyfile="src/csl/interface.h" bodystart="855" bodyend="858"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a5eec62ed9a54f53c6cb6184ddf7ada80" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsPow</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsPow</name>
        <qualifiedname>csl::IsPow</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="859" column="14" bodyfile="src/csl/interface.h" bodystart="859" bodyend="862"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa1233811f2a52250b0b488951f559193" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsProd</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsProd</name>
        <qualifiedname>csl::IsProd</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="863" column="14" bodyfile="src/csl/interface.h" bodystart="863" bodyend="866"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a71911fe28b7a192f255585195184cdcb" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsSum</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsSum</name>
        <qualifiedname>csl::IsSum</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="867" column="14" bodyfile="src/csl/interface.h" bodystart="867" bodyend="870"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a913e5d22d13fa7fccb0a4a667bbc1fc4" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsPolynomial</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsPolynomial</name>
        <qualifiedname>csl::IsPolynomial</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="871" column="14" bodyfile="src/csl/interface.h" bodystart="871" bodyend="874"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a567a82e8a8f5882f3473c57686128ac1" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsDerivative</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsDerivative</name>
        <qualifiedname>csl::IsDerivative</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="875" column="14" bodyfile="src/csl/interface.h" bodystart="875" bodyend="878"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a793fc1f53c48e3df00cb1c02e1391c98" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsCommutator</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsCommutator</name>
        <qualifiedname>csl::IsCommutator</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="879" column="14" bodyfile="src/csl/interface.h" bodystart="879" bodyend="882"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ad8c5c91f2b2b22f4d776c8fbcdcdde3c" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsAngle</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsAngle</name>
        <qualifiedname>csl::IsAngle</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="883" column="14" bodyfile="src/csl/interface.h" bodystart="883" bodyend="886"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a3d760de5d09daf48243e6ec09ea505af" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsFactorial</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsFactorial</name>
        <qualifiedname>csl::IsFactorial</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="887" column="14" bodyfile="src/csl/interface.h" bodystart="887" bodyend="890"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a1e82d4b4347d30ba63604ff8068042ef" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsIntegral</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsIntegral</name>
        <qualifiedname>csl::IsIntegral</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="891" column="14" bodyfile="src/csl/interface.h" bodystart="891" bodyend="894"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a8a0839acde42ca07ef0e6b7a2f00769a" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsScalarIntegral</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsScalarIntegral</name>
        <qualifiedname>csl::IsScalarIntegral</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="895" column="14" bodyfile="src/csl/interface.h" bodystart="895" bodyend="898"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a65bf984d6ebb21eaaf9e1c7bdddf3bcb" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsVectorIntegral</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsVectorIntegral</name>
        <qualifiedname>csl::IsVectorIntegral</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="899" column="14" bodyfile="src/csl/interface.h" bodystart="899" bodyend="902"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af28027af3f53a7471ceeb8fadb8dd9f0" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsVector</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsVector</name>
        <qualifiedname>csl::IsVector</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="903" column="14" bodyfile="src/csl/interface.h" bodystart="903" bodyend="906"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a8762176402b32eef3abbff6c23b93ee8" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsMatrix</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsMatrix</name>
        <qualifiedname>csl::IsMatrix</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="907" column="14" bodyfile="src/csl/interface.h" bodystart="907" bodyend="910"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a0ca50e143d0dddc1fcec29b70a0f3bfd" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::IsHighDTensor</definition>
        <argsstring>(Expr_info expr)</argsstring>
        <name>IsHighDTensor</name>
        <qualifiedname>csl::IsHighDTensor</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface.h" line="911" column="14" bodyfile="src/csl/interface.h" bodystart="911" bodyend="914"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a5166050632365ea31dd98526321fe732" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::AddProperty</definition>
        <argsstring>(csl::Tensor &amp;tensor, Expr const &amp;A, Expr const &amp;B, Expr const &amp;res)</argsstring>
        <name>AddProperty</name>
        <qualifiedname>csl::AddProperty</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref> &amp;</type>
          <declname>tensor</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>B</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>res</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface_indicial.cpp" line="25" column="6" bodyfile="src/csl/interface_indicial.cpp" bodystart="25" bodyend="31" declfile="src/csl/interface_indicial.h" declline="36" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa1e78f450ecfeca700efa0cd81919a80" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::AddProperty</definition>
        <argsstring>(csl::Tensor &amp;tensor, std::vector&lt; Expr &gt; const &amp;product, Expr const &amp;res)</argsstring>
        <name>AddProperty</name>
        <qualifiedname>csl::AddProperty</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref> &amp;</type>
          <declname>tensor</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; const &amp;</type>
          <declname>product</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>res</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface_indicial.cpp" line="33" column="6" bodyfile="src/csl/interface_indicial.cpp" bodystart="33" bodyend="38" declfile="src/csl/interface_indicial.h" declline="41" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1afa8db226a040100697d5c950bf6ec9e7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classcsl_1_1Space" kindref="compound">csl::Space</ref> *</type>
        <definition>const csl::Space * csl::GetSpace</definition>
        <argsstring>(csl::Tensor const &amp;tensor, int pos)</argsstring>
        <name>GetSpace</name>
        <qualifiedname>csl::GetSpace</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref> const &amp;</type>
          <declname>tensor</declname>
        </param>
        <param>
          <type>int</type>
          <declname>pos</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface_indicial.cpp" line="40" column="18" bodyfile="src/csl/interface_indicial.cpp" bodystart="40" bodyend="50" declfile="src/csl/interface_indicial.h" declline="45" declcolumn="18"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a6f5cd55bbf38d9628be197024dcedefb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref></type>
        <definition>csl::Index csl::GetIndex</definition>
        <argsstring>(csl::Tensor const &amp;tensor, int pos)</argsstring>
        <name>GetIndex</name>
        <qualifiedname>csl::GetIndex</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref> const &amp;</type>
          <declname>tensor</declname>
        </param>
        <param>
          <type>int</type>
          <declname>pos</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface_indicial.cpp" line="52" column="12" bodyfile="src/csl/interface_indicial.cpp" bodystart="52" bodyend="55" declfile="src/csl/interface_indicial.h" declline="47" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a8be80de8472a9225500a76b35bcfea62" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref></type>
        <definition>csl::Index csl::GetIndex</definition>
        <argsstring>(csl::Space const *space)</argsstring>
        <name>GetIndex</name>
        <qualifiedname>csl::GetIndex</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Space" kindref="compound">csl::Space</ref> const *</type>
          <declname>space</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface_indicial.cpp" line="57" column="12" bodyfile="src/csl/interface_indicial.cpp" bodystart="57" bodyend="60" declfile="src/csl/interface_indicial.h" declline="49" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af55eeea239ab6fc3827cd49b0deaed41" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref></type>
        <definition>csl::Index csl::GetIndex</definition>
        <argsstring>(csl::Space const &amp;space)</argsstring>
        <name>GetIndex</name>
        <qualifiedname>csl::GetIndex</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Space" kindref="compound">csl::Space</ref> const &amp;</type>
          <declname>space</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface_indicial.cpp" line="62" column="12" bodyfile="src/csl/interface_indicial.cpp" bodystart="62" bodyend="65" declfile="src/csl/interface_indicial.h" declline="53" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a32cf50d52b1a2f7c433892c92a9a85fe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref> &gt;</type>
        <definition>std::vector&lt; csl::Index &gt; csl::GetIndices</definition>
        <argsstring>(size_t N, csl::Tensor const &amp;tensor, int pos)</argsstring>
        <name>GetIndices</name>
        <qualifiedname>csl::GetIndices</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>N</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref> const &amp;</type>
          <declname>tensor</declname>
        </param>
        <param>
          <type>int</type>
          <declname>pos</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface_indicial.cpp" line="68" column="1" bodyfile="src/csl/interface_indicial.cpp" bodystart="68" bodyend="71" declfile="src/csl/interface_indicial.h" declline="58" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a3d73b7d4124c0a5cff5af54eb25ee275" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref> &gt;</type>
        <definition>std::vector&lt; csl::Index &gt; csl::GetIndices</definition>
        <argsstring>(size_t N, csl::Space const *space)</argsstring>
        <name>GetIndices</name>
        <qualifiedname>csl::GetIndices</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>N</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Space" kindref="compound">csl::Space</ref> const *</type>
          <declname>space</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface_indicial.cpp" line="73" column="13" bodyfile="src/csl/interface_indicial.cpp" bodystart="73" bodyend="80" declfile="src/csl/interface_indicial.h" declline="51" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2c19e712134df4d3cd72201558cb87bf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref> &gt;</type>
        <definition>std::vector&lt; csl::Index &gt; csl::GetIndices</definition>
        <argsstring>(size_t N, csl::Space const &amp;space)</argsstring>
        <name>GetIndices</name>
        <qualifiedname>csl::GetIndices</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>N</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Space" kindref="compound">csl::Space</ref> const &amp;</type>
          <declname>space</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface_indicial.cpp" line="82" column="13" bodyfile="src/csl/interface_indicial.cpp" bodystart="82" bodyend="85" declfile="src/csl/interface_indicial.h" declline="55" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ad24e93760d56e33962ca45f294238fe7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref> &gt;</type>
        <definition>std::vector&lt; csl::Index &gt; csl::GetFullSetOfIndicesFor</definition>
        <argsstring>(csl::Tensor const &amp;tensor)</argsstring>
        <name>GetFullSetOfIndicesFor</name>
        <qualifiedname>csl::GetFullSetOfIndicesFor</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref> const &amp;</type>
          <declname>tensor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface_indicial.cpp" line="87" column="13" bodyfile="src/csl/interface_indicial.cpp" bodystart="87" bodyend="96" declfile="src/csl/interface_indicial.h" declline="60" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af871808ec65d7c68d1364a40e9f7f98e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Tensor" kindref="compound">csl::Tensor</ref></type>
        <definition>Tensor csl::Unitary</definition>
        <argsstring>(std::string const &amp;name, csl::Space const *space)</argsstring>
        <name>Unitary</name>
        <qualifiedname>csl::Unitary</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Space" kindref="compound">csl::Space</ref> const *</type>
          <declname>space</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface_indicial.cpp" line="98" column="13" bodyfile="src/csl/interface_indicial.cpp" bodystart="98" bodyend="117" declfile="src/csl/interface_indicial.h" declline="62" declcolumn="8"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a6b899aa9533018b8e949ef85953ea10e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::TestIndexSanity</definition>
        <argsstring>(Expr const &amp;expr, bool verbose)</argsstring>
        <name>TestIndexSanity</name>
        <qualifiedname>csl::TestIndexSanity</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>verbose</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/interface_indicial.cpp" line="119" column="6" bodyfile="src/csl/interface_indicial.cpp" bodystart="119" bodyend="164" declfile="src/csl/interface_indicial.h" declline="64" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af8301d8df92dac9777367c7d16e91fd2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::printCallableStructure</definition>
        <argsstring>(std::ostream &amp;out)</argsstring>
        <name>printCallableStructure</name>
        <qualifiedname>csl::printCallableStructure</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/libcallable_data.h" line="21" column="13" bodyfile="src/csl/libcallable_data.h" bodystart="21" bodyend="50"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a72b004ada1a49262b69febdc3f8ac931" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::print_libcomplexop_hdata</definition>
        <argsstring>(std::ostream &amp;out)</argsstring>
        <name>print_libcomplexop_hdata</name>
        <qualifiedname>csl::print_libcomplexop_hdata</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/libcomplexop_hdata.h" line="29" column="6" bodyfile="src/csl/libcomplexop_hdata.h" bodystart="29" bodyend="485"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa8be4089a7741693c7a84ebb20b4e425" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::print_libdiagonalization_cppdata</definition>
        <argsstring>(std::ostream &amp;out)</argsstring>
        <name>print_libdiagonalization_cppdata</name>
        <qualifiedname>csl::print_libdiagonalization_cppdata</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/libdiagonalization_cppdata.h" line="29" column="6" bodyfile="src/csl/libdiagonalization_cppdata.h" bodystart="29" bodyend="375"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae1825c01d4afa2677f372c511312c37f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::print_libdiagonalization_hdata</definition>
        <argsstring>(std::ostream &amp;out)</argsstring>
        <name>print_libdiagonalization_hdata</name>
        <qualifiedname>csl::print_libdiagonalization_hdata</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/libdiagonalization_hdata.h" line="29" column="6" bodyfile="src/csl/libdiagonalization_hdata.h" bodystart="29" bodyend="178"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1adea40f7a4644fb64e77a04460ebd6288" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1IndexStructure" kindref="compound">csl::IndexStructure</ref></type>
        <definition>csl::IndexStructure csl::getFullStructure</definition>
        <argsstring>(Expr const &amp;expr)</argsstring>
        <name>getFullStructure</name>
        <qualifiedname>csl::getFullStructure</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/libraryevaluator.cpp" line="164" column="21" bodyfile="src/csl/libraryevaluator.cpp" bodystart="164" bodyend="181"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a3ea5cbedab4c45446b9ea67f165b94a2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::isTensorName</definition>
        <argsstring>(std::string_view name)</argsstring>
        <name>isTensorName</name>
        <qualifiedname>csl::isTensorName</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/libraryevaluator.cpp" line="332" column="6" bodyfile="src/csl/libraryevaluator.cpp" bodystart="332" bodyend="344"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ad2ee3d20dc0037322f07703b1daf221a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; csl::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, LibEval const &amp;eval)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>csl::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1LibEval" kindref="compound">LibEval</ref> const &amp;</type>
          <declname>eval</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/libraryevaluator.cpp" line="405" column="1" bodyfile="src/csl/libraryevaluator.cpp" bodystart="405" bodyend="409"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a3775de045bee3b252742dfced2e20e65" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1LibEval" kindref="compound">LibEval</ref></type>
        <definition>LibEval csl::findEvalDicho</definition>
        <argsstring>(int id, std::vector&lt; LibEval &gt;::const_iterator first, std::vector&lt; LibEval &gt;::const_iterator last)</argsstring>
        <name>findEvalDicho</name>
        <qualifiedname>csl::findEvalDicho</qualifiedname>
        <param>
          <type>int</type>
          <declname>id</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1LibEval" kindref="compound">LibEval</ref> &gt;::const_iterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1LibEval" kindref="compound">LibEval</ref> &gt;::const_iterator</type>
          <declname>last</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/libraryevaluator.cpp" line="489" column="9" bodyfile="src/csl/libraryevaluator.cpp" bodystart="489" bodyend="516"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a0c10276807a9348efd1d2d34e3e5da26" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1LibEval" kindref="compound">LibEval</ref></type>
        <definition>LibEval csl::exprToEval</definition>
        <argsstring>(Expr const &amp;expr, std::vector&lt; LibEval &gt; const &amp;eval)</argsstring>
        <name>exprToEval</name>
        <qualifiedname>csl::exprToEval</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1LibEval" kindref="compound">LibEval</ref> &gt; const &amp;</type>
          <declname>eval</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/libraryevaluator.cpp" line="518" column="9" bodyfile="src/csl/libraryevaluator.cpp" bodystart="518" bodyend="539"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a579164e2606cf7a43e29913d80e98a03" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::independent</definition>
        <argsstring>(LibEval const &amp;A, LibEval const &amp;B)</argsstring>
        <name>independent</name>
        <qualifiedname>csl::independent</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1LibEval" kindref="compound">LibEval</ref> const &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1LibEval" kindref="compound">LibEval</ref> const &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/libraryevaluator.cpp" line="642" column="6" bodyfile="src/csl/libraryevaluator.cpp" bodystart="642" bodyend="646"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa40c7ef62cc775c5f1fce6d8f8ced30b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t csl::getNLeafs</definition>
        <argsstring>(csl::Expr const &amp;expr)</argsstring>
        <name>getNLeafs</name>
        <qualifiedname>csl::getNLeafs</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/libraryevaluator.cpp" line="766" column="8" bodyfile="src/csl/libraryevaluator.cpp" bodystart="766" bodyend="771"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a8bec12409b9f93eeae75990bafe58112" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; csl::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, LibEvalSession::Perf perf)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>csl::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type><ref refid="structcsl_1_1LibEvalSession_1_1Perf" kindref="compound">LibEvalSession::Perf</ref></type>
          <declname>perf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/libraryevaluator.h" line="230" column="1" bodyfile="src/csl/libraryevaluator.h" bodystart="230" bodyend="237"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a22d64e2c80d73a47d1f5a9f150e1a2fd" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::operator&lt;</definition>
        <argsstring>(LibParameter const &amp;A, LibParameter const &amp;B)</argsstring>
        <name>operator&lt;</name>
        <qualifiedname>csl::operator&lt;</qualifiedname>
        <param>
          <type><ref refid="structcsl_1_1LibParameter" kindref="compound">LibParameter</ref> const &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="structcsl_1_1LibParameter" kindref="compound">LibParameter</ref> const &amp;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/libraryfunction.h" line="42" column="12" bodyfile="src/csl/libraryfunction.h" bodystart="42" bodyend="44"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae2fb979be9f3d8246d1561b4d1497240" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::pair&lt; std::vector&lt; <ref refid="structcsl_1_1LibParameter" kindref="compound">LibParameter</ref> &gt;, std::vector&lt; <ref refid="structcsl_1_1LibParameter" kindref="compound">LibParameter</ref> &gt; &gt;</type>
        <definition>static std::pair&lt; std::vector&lt; LibParameter &gt;, std::vector&lt; LibParameter &gt; &gt; csl::separateComplexParameters</definition>
        <argsstring>(std::vector&lt; LibParameter &gt; const &amp;params1, std::vector&lt; LibParameter &gt; const &amp;params2)</argsstring>
        <name>separateComplexParameters</name>
        <qualifiedname>csl::separateComplexParameters</qualifiedname>
        <param>
          <type>std::vector&lt; <ref refid="structcsl_1_1LibParameter" kindref="compound">LibParameter</ref> &gt; const &amp;</type>
          <declname>params1</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="structcsl_1_1LibParameter" kindref="compound">LibParameter</ref> &gt; const &amp;</type>
          <declname>params2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/librarygroup.cpp" line="87" column="1" bodyfile="src/csl/librarygroup.cpp" bodystart="87" bodyend="106"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a0efbc4646fdc35ab36f804e395f90ce1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::print_librarytensor_hdata</definition>
        <argsstring>(std::ostream &amp;out)</argsstring>
        <name>print_librarytensor_hdata</name>
        <qualifiedname>csl::print_librarytensor_hdata</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/librarytensor_hdata.h" line="29" column="6" bodyfile="src/csl/librarytensor_hdata.h" bodystart="29" bodyend="170"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a7fbc14af6671615ab035d1c56fdcc02a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::intfactorial_s</definition>
        <argsstring>(int value)</argsstring>
        <name>intfactorial_s</name>
        <qualifiedname>csl::intfactorial_s</qualifiedname>
        <param>
          <type>int</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para><bold>Initializer</bold> of the <ref refid="classcsl_1_1IntFactorial" kindref="compound">IntFactorial</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="namespacecsl_1ace591865c69b6315c533a1a325777312aa79046cb7e9f609ba07c4ec22f14a862" kindref="member">IntFactorial(value)</ref> if value &gt; 2 </para>
</simplesect>
<simplesect kind="return"><para>Number(value) else </para>
</simplesect>
<simplesect kind="note"><para>This function can be used to return a Symbol. The Symbol constructor Symbol::Symbol(const Expr&amp;) is implemented and allows to put the return value of this function in a Symbol. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/literal.cpp" line="691" column="6" bodyfile="src/csl/literal.cpp" bodystart="691" bodyend="701" declfile="src/csl/literal.h" declline="512" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a16ec6f7271c0d746847725aa4f898f18" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::constant_s</definition>
        <argsstring>(string const &amp;name, csl::ComplexProperty prop)</argsstring>
        <name>constant_s</name>
        <qualifiedname>csl::constant_s</qualifiedname>
        <param>
          <type>string const &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0e" kindref="member">csl::ComplexProperty</ref></type>
          <declname>prop</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/literal.cpp" line="703" column="6" bodyfile="src/csl/literal.cpp" bodystart="703" bodyend="709"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a7168fcf3a66db5c2ee45e0064421cf77" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::constant_s</definition>
        <argsstring>(string const &amp;name, long double value, csl::ComplexProperty prop)</argsstring>
        <name>constant_s</name>
        <qualifiedname>csl::constant_s</qualifiedname>
        <param>
          <type>string const &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>long double</type>
          <declname>value</declname>
        </param>
        <param>
          <type><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0e" kindref="member">csl::ComplexProperty</ref></type>
          <declname>prop</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/literal.cpp" line="711" column="6" bodyfile="src/csl/literal.cpp" bodystart="711" bodyend="720"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a08ab2d9699116b9d1d35d6b0463aaf45" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::constant_s</definition>
        <argsstring>(string const &amp;name, Expr const &amp;value, csl::ComplexProperty prop)</argsstring>
        <name>constant_s</name>
        <qualifiedname>csl::constant_s</qualifiedname>
        <param>
          <type>string const &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>value</declname>
        </param>
        <param>
          <type><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0e" kindref="member">csl::ComplexProperty</ref></type>
          <declname>prop</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/literal.cpp" line="722" column="6" bodyfile="src/csl/literal.cpp" bodystart="722" bodyend="731"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2e5f515c01394cecf90b7eb211a26375" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::variable_s</definition>
        <argsstring>(string const &amp;name, csl::ComplexProperty prop)</argsstring>
        <name>variable_s</name>
        <qualifiedname>csl::variable_s</qualifiedname>
        <param>
          <type>string const &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0e" kindref="member">csl::ComplexProperty</ref></type>
          <declname>prop</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/literal.cpp" line="733" column="6" bodyfile="src/csl/literal.cpp" bodystart="733" bodyend="739"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aab85e44956df94d5f6718bd73eaf5964" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::variable_s</definition>
        <argsstring>(string const &amp;name, long double value, csl::ComplexProperty prop)</argsstring>
        <name>variable_s</name>
        <qualifiedname>csl::variable_s</qualifiedname>
        <param>
          <type>string const &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>long double</type>
          <declname>value</declname>
        </param>
        <param>
          <type><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0e" kindref="member">csl::ComplexProperty</ref></type>
          <declname>prop</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/literal.cpp" line="741" column="6" bodyfile="src/csl/literal.cpp" bodystart="741" bodyend="750"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ab04826601497bdeef9dd0ab6abd78ac4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::variable_s</definition>
        <argsstring>(string const &amp;name, Expr const &amp;value, csl::ComplexProperty prop)</argsstring>
        <name>variable_s</name>
        <qualifiedname>csl::variable_s</qualifiedname>
        <param>
          <type>string const &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>value</declname>
        </param>
        <param>
          <type><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0e" kindref="member">csl::ComplexProperty</ref></type>
          <declname>prop</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/literal.cpp" line="752" column="6" bodyfile="src/csl/literal.cpp" bodystart="752" bodyend="761"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a02a37fce062057444eea765a004bc180" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::constant_s</definition>
        <argsstring>(std::string const &amp;name, csl::ComplexProperty prop=csl::ComplexProperty::Real)</argsstring>
        <name>constant_s</name>
        <qualifiedname>csl::constant_s</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0e" kindref="member">csl::ComplexProperty</ref></type>
          <declname>prop</declname>
          <defval><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0ea7f80fcc452c2f1ed2bb51b39d0864df1" kindref="member">csl::ComplexProperty::Real</ref></defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/literal.h" line="514" column="6" declfile="src/csl/literal.h" declline="514" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a7fa48ec0e9e78268c41f54f9e610463a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::constant_s</definition>
        <argsstring>(std::string const &amp;name, long double value, csl::ComplexProperty prop=csl::ComplexProperty::Real)</argsstring>
        <name>constant_s</name>
        <qualifiedname>csl::constant_s</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>long double</type>
          <declname>value</declname>
        </param>
        <param>
          <type><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0e" kindref="member">csl::ComplexProperty</ref></type>
          <declname>prop</declname>
          <defval><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0ea7f80fcc452c2f1ed2bb51b39d0864df1" kindref="member">csl::ComplexProperty::Real</ref></defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/literal.h" line="517" column="6" declfile="src/csl/literal.h" declline="517" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a4de4c749cd87049d977526b7897fe9e2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::constant_s</definition>
        <argsstring>(std::string const &amp;name, Expr const &amp;value, csl::ComplexProperty prop=csl::ComplexProperty::Real)</argsstring>
        <name>constant_s</name>
        <qualifiedname>csl::constant_s</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>value</declname>
        </param>
        <param>
          <type><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0e" kindref="member">csl::ComplexProperty</ref></type>
          <declname>prop</declname>
          <defval><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0ea7f80fcc452c2f1ed2bb51b39d0864df1" kindref="member">csl::ComplexProperty::Real</ref></defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/literal.h" line="521" column="6" declfile="src/csl/literal.h" declline="521" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ad650cc5bf3919186ad6fb17b67726e4a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::variable_s</definition>
        <argsstring>(std::string const &amp;name, csl::ComplexProperty prop=csl::ComplexProperty::Real)</argsstring>
        <name>variable_s</name>
        <qualifiedname>csl::variable_s</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0e" kindref="member">csl::ComplexProperty</ref></type>
          <declname>prop</declname>
          <defval><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0ea7f80fcc452c2f1ed2bb51b39d0864df1" kindref="member">csl::ComplexProperty::Real</ref></defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/literal.h" line="525" column="6" declfile="src/csl/literal.h" declline="525" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a407c534d3534059bd6bd46bbd41758ae" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::variable_s</definition>
        <argsstring>(std::string const &amp;name, long double value, csl::ComplexProperty prop=csl::ComplexProperty::Real)</argsstring>
        <name>variable_s</name>
        <qualifiedname>csl::variable_s</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>long double</type>
          <declname>value</declname>
        </param>
        <param>
          <type><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0e" kindref="member">csl::ComplexProperty</ref></type>
          <declname>prop</declname>
          <defval><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0ea7f80fcc452c2f1ed2bb51b39d0864df1" kindref="member">csl::ComplexProperty::Real</ref></defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/literal.h" line="528" column="6" declfile="src/csl/literal.h" declline="528" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1adc179d7e1cfe3178fb8bd2b8e2dbfb78" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::variable_s</definition>
        <argsstring>(std::string const &amp;name, Expr const &amp;value, csl::ComplexProperty prop=csl::ComplexProperty::Real)</argsstring>
        <name>variable_s</name>
        <qualifiedname>csl::variable_s</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>value</declname>
        </param>
        <param>
          <type><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0e" kindref="member">csl::ComplexProperty</ref></type>
          <declname>prop</declname>
          <defval><ref refid="namespacecsl_1ac54d9e79dc6697a8eacc07c754b11c0ea7f80fcc452c2f1ed2bb51b39d0864df1" kindref="member">csl::ComplexProperty::Real</ref></defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/literal.h" line="532" column="6" declfile="src/csl/literal.h" declline="532" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a5327d368e944125c5ffa58b304051751" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::abs_s</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>abs_s</name>
        <qualifiedname>csl::abs_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Creates</bold> an object of type <ref refid="classcsl_1_1Abs" kindref="compound">Abs</ref> acting on <bold>expr</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para>As all the outside-class functions, this one take into account the fact that the final object could not be an abs funtion. Then the return value is not an <ref refid="classcsl_1_1Abs" kindref="compound">Abs</ref> object but something else, so we must implement a function that will create the good object. For example abs(1) returns 1 (a Number) and not abs(1) (an <ref refid="classcsl_1_1Abs" kindref="compound">Abs</ref>).<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Argment of the <bold>abs</bold> funtion function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classcsl_1_1Abs" kindref="compound">Abs</ref> applied on expr </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/mathFunctions.cpp" line="157" column="6" bodyfile="src/csl/mathFunctions.cpp" bodystart="157" bodyend="169" declfile="src/csl/mathFunctions.h" declline="104" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a677874110c8d7d3febc7f30085273e6b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::exp_s</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>exp_s</name>
        <qualifiedname>csl::exp_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Creates</bold> an object of type <ref refid="classcsl_1_1Exp" kindref="compound">Exp</ref> acting on <bold>expr</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para>As all the outside-class functions, this one take into account the fact that the final object could not be an exponential. Then the return value is not an <ref refid="classcsl_1_1Exp" kindref="compound">Exp</ref> object but something else, so we must implement a function that will create the good object. For example exp(0) returns 1 (a Number) and not exp(0) (an <ref refid="classcsl_1_1Exp" kindref="compound">Exp</ref>).<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Argment of the <bold>exponential</bold> function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classcsl_1_1Exp" kindref="compound">Exp</ref> applied on expr </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/mathFunctions.cpp" line="307" column="6" bodyfile="src/csl/mathFunctions.cpp" bodystart="307" bodyend="327" declfile="src/csl/mathFunctions.h" declline="194" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a77a31d3871e8136ab04e15368528c846" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::log_s</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>log_s</name>
        <qualifiedname>csl::log_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Creates</bold> an object of type <ref refid="classcsl_1_1Log" kindref="compound">Log</ref> acting on <bold>expr</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para>As all the outside-class functions, this one take into account the fact that the final object could not be an logarithm. Then the return value is not an <ref refid="classcsl_1_1Log" kindref="compound">Log</ref> object but something else, so we must implement a function that will create the good object. For example log(1) returns 0 (a Number) and not log(1) (a <ref refid="classcsl_1_1Log" kindref="compound">Log</ref>).<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Argment of the <bold>logarithm</bold> function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classcsl_1_1Log" kindref="compound">Log</ref> applied on expr </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/mathFunctions.cpp" line="422" column="6" bodyfile="src/csl/mathFunctions.cpp" bodystart="422" bodyend="434" declfile="src/csl/mathFunctions.h" declline="277" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a3033bff78373155994cbf45ec3e71493" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::cos_s</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>cos_s</name>
        <qualifiedname>csl::cos_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Creates</bold> an object of type <ref refid="classcsl_1_1Cos" kindref="compound">Cos</ref> acting on <bold>expr</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para>As all the outside-class functions, this one take into account the fact that the final object could not be an cosonential. Then the return value is not an <ref refid="classcsl_1_1Cos" kindref="compound">Cos</ref> object but something else, so we must implement a function that will create the good object. For example cos(0) returns 1 (a Number) and not cos(0) (a <ref refid="classcsl_1_1Cos" kindref="compound">Cos</ref>).<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Argment of the <bold>cos</bold> function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classcsl_1_1Cos" kindref="compound">Cos</ref> applied on expr </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/mathFunctions.cpp" line="530" column="6" bodyfile="src/csl/mathFunctions.cpp" bodystart="530" bodyend="565" declfile="src/csl/mathFunctions.h" declline="360" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a5f030b62fc81f11147493796bfa30b54" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::sin_s</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>sin_s</name>
        <qualifiedname>csl::sin_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Creates</bold> an object of type <ref refid="classcsl_1_1Sin" kindref="compound">Sin</ref> acting on <bold>expr</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para>As all the outside-class functions, this one take into account the fact that the final object could not be an sin. Then the return value is not an <ref refid="classcsl_1_1Sin" kindref="compound">Sin</ref> object but something else, so we must implement a function that will create the good object. For example sin(0) returns 0 (a Number) and not sin(0) (an <ref refid="classcsl_1_1Sin" kindref="compound">Sin</ref>).<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Argment of the <bold>sin</bold> function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classcsl_1_1Sin" kindref="compound">Sin</ref> applied on expr </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/mathFunctions.cpp" line="661" column="6" bodyfile="src/csl/mathFunctions.cpp" bodystart="661" bodyend="694" declfile="src/csl/mathFunctions.h" declline="443" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1afbaab772a8fb873c65e06d079e73cd06" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::tan_s</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>tan_s</name>
        <qualifiedname>csl::tan_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Creates</bold> an object of type <ref refid="classcsl_1_1Tan" kindref="compound">Tan</ref> acting on <bold>expr</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para>As all the outside-class functions, this one take into account the fact that the final object could not be an tan. Then the return value is not an <ref refid="classcsl_1_1Tan" kindref="compound">Tan</ref> object but something else, so we must implement a function that will create the good object. For example tan(0) returns 0 (a Number) and not tan(0) (a <ref refid="classcsl_1_1Tan" kindref="compound">Tan</ref>).<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Argment of the <bold>tan</bold> function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classcsl_1_1Tan" kindref="compound">Tan</ref> applied on expr </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/mathFunctions.cpp" line="809" column="6" bodyfile="src/csl/mathFunctions.cpp" bodystart="809" bodyend="840" declfile="src/csl/mathFunctions.h" declline="526" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a51f0625e0729c8516296eaa4e82a9928" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::acos_s</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>acos_s</name>
        <qualifiedname>csl::acos_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Creates</bold> an object of type <ref refid="classcsl_1_1ACos" kindref="compound">ACos</ref> acting on <bold>expr</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para>As all the outside-class functions, this one take into account the fact that the final object could not be an acosonential. Then the return value is not an <ref refid="classcsl_1_1ACos" kindref="compound">ACos</ref> object but something else, so we must implement a function that will create the good object. For example acos(0) returns pi/2 (a Number) and not acos(0) (a <ref refid="classcsl_1_1ACos" kindref="compound">ACos</ref>).<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Argment of the <bold>acos</bold> function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classcsl_1_1ACos" kindref="compound">ACos</ref> applied on expr </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/mathFunctions.cpp" line="941" column="6" bodyfile="src/csl/mathFunctions.cpp" bodystart="941" bodyend="946" declfile="src/csl/mathFunctions.h" declline="609" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ac5fe6fa63f0b6cd80fd9edd625a715ad" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::asin_s</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>asin_s</name>
        <qualifiedname>csl::asin_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Creates</bold> an object of type <ref refid="classcsl_1_1ASin" kindref="compound">ASin</ref> acting on <bold>expr</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para>As all the outside-class functions, this one take into account the fact that the final object could not be an asin. Then the return value is not an <ref refid="classcsl_1_1ASin" kindref="compound">ASin</ref> object but something else, so we must implement a function that will create the good object. For example asin(0) returns 0 (a Number) and not asin(0) (an <ref refid="classcsl_1_1ASin" kindref="compound">ASin</ref>).<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Argment of the <bold>asin</bold> function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classcsl_1_1ASin" kindref="compound">ASin</ref> applied on expr </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/mathFunctions.cpp" line="1047" column="6" bodyfile="src/csl/mathFunctions.cpp" bodystart="1047" bodyend="1052" declfile="src/csl/mathFunctions.h" declline="692" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a55a28054aa1541d982b05e4c90e22243" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::atan_s</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>atan_s</name>
        <qualifiedname>csl::atan_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Creates</bold> an object of type <ref refid="classcsl_1_1ATan" kindref="compound">ATan</ref> acting on <bold>expr</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para>As all the outside-class functions, this one take into account the fact that the final object could not be an atan. Then the return value is not an <ref refid="classcsl_1_1ATan" kindref="compound">ATan</ref> object but something else, so we must implement a function that will create the good object. For example atan(0) returns 0 (a Number) and not atan(0) (a <ref refid="classcsl_1_1ATan" kindref="compound">ATan</ref>).<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Argment of the <bold>atan</bold> function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classcsl_1_1ATan" kindref="compound">ATan</ref> applied on expr </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/mathFunctions.cpp" line="1121" column="6" bodyfile="src/csl/mathFunctions.cpp" bodystart="1121" bodyend="1128" declfile="src/csl/mathFunctions.h" declline="767" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a9f96bc23faf2e85278c67d2e77b02430" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::cosh_s</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>cosh_s</name>
        <qualifiedname>csl::cosh_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Creates</bold> an object of type <ref refid="classcsl_1_1Cosh" kindref="compound">Cosh</ref> acting on <bold>expr</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para>As all the outside-class functions, this one take into account the fact that the final object could not be an coshonential. Then the return value is not an <ref refid="classcsl_1_1Cosh" kindref="compound">Cosh</ref> object but something else, so we must implement a function that will create the good object. For example cosh(0) returns 1 (a Number) and not cosh(0) (a <ref refid="classcsl_1_1Cosh" kindref="compound">Cosh</ref>).<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Argment of the <bold>cosh</bold> function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classcsl_1_1Cosh" kindref="compound">Cosh</ref> applied on expr </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/mathFunctions.cpp" line="1224" column="6" bodyfile="src/csl/mathFunctions.cpp" bodystart="1224" bodyend="1231" declfile="src/csl/mathFunctions.h" declline="927" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2aab7af831ac14498b23ac3daa80d1d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::sinh_s</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>sinh_s</name>
        <qualifiedname>csl::sinh_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Creates</bold> an object of type <ref refid="classcsl_1_1Sinh" kindref="compound">Sinh</ref> acting on <bold>expr</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para>As all the outside-class functions, this one take into account the fact that the final object could not be an sinh. Then the return value is not an <ref refid="classcsl_1_1Sinh" kindref="compound">Sinh</ref> object but something else, so we must implement a function that will create the good object. For example sinh(0) returns 0 (a Number) and not sinh(0) (an <ref refid="classcsl_1_1Sinh" kindref="compound">Sinh</ref>).<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Argment of the <bold>sinh</bold> function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classcsl_1_1Sinh" kindref="compound">Sinh</ref> applied on expr </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/mathFunctions.cpp" line="1327" column="6" bodyfile="src/csl/mathFunctions.cpp" bodystart="1327" bodyend="1334" declfile="src/csl/mathFunctions.h" declline="1010" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a8a0975103bcda47f0e7a335677ba8e1f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::tanh_s</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>tanh_s</name>
        <qualifiedname>csl::tanh_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Creates</bold> an object of type <ref refid="classcsl_1_1Tanh" kindref="compound">Tanh</ref> acting on <bold>expr</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para>As all the outside-class functions, this one take into account the fact that the final object could not be an tanh. Then the return value is not an <ref refid="classcsl_1_1Tanh" kindref="compound">Tanh</ref> object but something else, so we must implement a function that will create the good object. For example tanh(0) returns 0 (a Number) and not tanh(0) (a <ref refid="classcsl_1_1Tanh" kindref="compound">Tanh</ref>).<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Argment of the <bold>tanh</bold> function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classcsl_1_1Tanh" kindref="compound">Tanh</ref> applied on expr </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/mathFunctions.cpp" line="1450" column="6" bodyfile="src/csl/mathFunctions.cpp" bodystart="1450" bodyend="1457" declfile="src/csl/mathFunctions.h" declline="1093" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a832f3758b9ec7e3f52e554b949c8acf3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::acosh_s</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>acosh_s</name>
        <qualifiedname>csl::acosh_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Creates</bold> an object of type <ref refid="classcsl_1_1ACosh" kindref="compound">ACosh</ref> acting on <bold>expr</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para>As all the outside-class functions, this one take into account the fact that the final object could not be an acoshonential. Then the return value is not an <ref refid="classcsl_1_1ACosh" kindref="compound">ACosh</ref> object but something else, so we must implement a function that will create the good object. For example acosh(0) returns 1 (a Number) and not acosh(0) (a <ref refid="classcsl_1_1ACosh" kindref="compound">ACosh</ref>).<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Argment of the <bold>acosh</bold> function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classcsl_1_1ACosh" kindref="compound">ACosh</ref> applied on expr </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/mathFunctions.cpp" line="1526" column="6" bodyfile="src/csl/mathFunctions.cpp" bodystart="1526" bodyend="1533" declfile="src/csl/mathFunctions.h" declline="1168" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a6f8d17a63615e912a201b11ce163b9dd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::asinh_s</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>asinh_s</name>
        <qualifiedname>csl::asinh_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Creates</bold> an object of type <ref refid="classcsl_1_1ASinh" kindref="compound">ASinh</ref> acting on <bold>expr</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para>As all the outside-class functions, this one take into account the fact that the final object could not be an asinh. Then the return value is not an <ref refid="classcsl_1_1ASinh" kindref="compound">ASinh</ref> object but something else, so we must implement a function that will create the good object. For example asinh(0) returns 0 (a Number) and not asinh(0) (an <ref refid="classcsl_1_1ASinh" kindref="compound">ASinh</ref>).<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Argment of the <bold>asinh</bold> function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classcsl_1_1ASinh" kindref="compound">ASinh</ref> applied on expr </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/mathFunctions.cpp" line="1605" column="6" bodyfile="src/csl/mathFunctions.cpp" bodystart="1605" bodyend="1612" declfile="src/csl/mathFunctions.h" declline="1243" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ac7d65507d0aa73726a4f0969ba1134be" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::atanh_s</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>atanh_s</name>
        <qualifiedname>csl::atanh_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Creates</bold> an object of type <ref refid="classcsl_1_1ATanh" kindref="compound">ATanh</ref> acting on <bold>expr</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para>As all the outside-class functions, this one take into account the fact that the final object could not be an atanh. Then the return value is not an <ref refid="classcsl_1_1ATanh" kindref="compound">ATanh</ref> object but something else, so we must implement a function that will create the good object. For example atanh(0) returns 0 (a Number) and not atanh(0) (a <ref refid="classcsl_1_1ATanh" kindref="compound">ATanh</ref>).<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Argment of the <bold>atanh</bold> function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classcsl_1_1ATanh" kindref="compound">ATanh</ref> applied on expr </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/mathFunctions.cpp" line="1683" column="6" bodyfile="src/csl/mathFunctions.cpp" bodystart="1683" bodyend="1690" declfile="src/csl/mathFunctions.h" declline="1318" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a3a5869287cf8e8d58a895d81a9fbb126" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::angle_s</definition>
        <argsstring>(Expr const &amp;a, Expr const &amp;b)</argsstring>
        <name>angle_s</name>
        <qualifiedname>csl::angle_s</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/mathFunctions.cpp" line="1824" column="6" bodyfile="src/csl/mathFunctions.cpp" bodystart="1824" bodyend="1829" declfile="src/csl/mathFunctions.h" declline="844" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae58378a628b9b1e36084a3ca390de5a2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::factorial_s</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>factorial_s</name>
        <qualifiedname>csl::factorial_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/mathFunctions.cpp" line="1919" column="6" bodyfile="src/csl/mathFunctions.cpp" bodystart="1919" bodyend="1924" declfile="src/csl/mathFunctions.h" declline="1391" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ac4e5ad9ffda4662419bd5ca6c494cac3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::diracdelta_s</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>diracdelta_s</name>
        <qualifiedname>csl::diracdelta_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/mathFunctions.cpp" line="2090" column="6" bodyfile="src/csl/mathFunctions.cpp" bodystart="2090" bodyend="2100" declfile="src/csl/mathFunctions.h" declline="1457" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a8e81b858e74ec884420ae98f4f5f1b14" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::float_s</definition>
        <argsstring>(long double value)</argsstring>
        <name>float_s</name>
        <qualifiedname>csl::float_s</qualifiedname>
        <param>
          <type>long double</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/numerical.cpp" line="661" column="6" bodyfile="src/csl/numerical.cpp" bodystart="661" bodyend="668" declfile="src/csl/numerical.h" declline="468" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a1f6ff04727d10c4a9b975f17996bcd46" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::int_s</definition>
        <argsstring>(long long int value)</argsstring>
        <name>int_s</name>
        <qualifiedname>csl::int_s</qualifiedname>
        <param>
          <type>long long int</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/numerical.cpp" line="670" column="6" bodyfile="src/csl/numerical.cpp" bodystart="670" bodyend="683" declfile="src/csl/numerical.h" declline="470" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a6c198badb2a6d2b98b49136ddd9e8b22" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::autonumber_s</definition>
        <argsstring>(long double value)</argsstring>
        <name>autonumber_s</name>
        <qualifiedname>csl::autonumber_s</qualifiedname>
        <param>
          <type>long double</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/numerical.cpp" line="685" column="6" bodyfile="src/csl/numerical.cpp" bodystart="685" bodyend="688" declfile="src/csl/numerical.h" declline="472" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a30f5583f252a667f46719dd45c434924" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::intfraction_s</definition>
        <argsstring>(long long int num, long long int denom)</argsstring>
        <name>intfraction_s</name>
        <qualifiedname>csl::intfraction_s</qualifiedname>
        <param>
          <type>long long int</type>
          <declname>num</declname>
        </param>
        <param>
          <type>long long int</type>
          <declname>denom</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/numerical.cpp" line="690" column="6" bodyfile="src/csl/numerical.cpp" bodystart="690" bodyend="714" declfile="src/csl/numerical.h" declline="474" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a7b2284a5aa4e5ff248cbcd942f0a9e74" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::complex_s</definition>
        <argsstring>(Expr const &amp;real, Expr const &amp;imag)</argsstring>
        <name>complex_s</name>
        <qualifiedname>csl::complex_s</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>real</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>imag</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/numerical.cpp" line="945" column="6" bodyfile="src/csl/numerical.cpp" bodystart="945" bodyend="950" declfile="src/csl/numerical.h" declline="476" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1afcc3a3fc7918ecabccfd64a656c6a6f7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; csl::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;fout, const ObjectPermutation&lt; T &gt; &amp;perm)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>csl::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>fout</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1ObjectPermutation" kindref="compound">ObjectPermutation</ref>&lt; T &gt; &amp;</type>
          <declname>perm</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/objectSymmetry.h" line="340" column="1" bodyfile="src/csl/objectSymmetry.h" bodystart="340" bodyend="353"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af042296e9e8b5f481d39ee4620446475" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; csl::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;fout, const ObjectSymmetry&lt; T &gt; &amp;sym)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>csl::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>fout</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1ObjectSymmetry" kindref="compound">ObjectSymmetry</ref>&lt; T &gt; &amp;</type>
          <declname>sym</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/objectSymmetry.h" line="455" column="1" bodyfile="src/csl/objectSymmetry.h" bodystart="455" bodyend="464"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae2f834f4204183e8e656de5ad6da2040" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::testSimplificationRule</definition>
        <argsstring>(std::vector&lt; Expr &gt; const &amp;arg)</argsstring>
        <name>testSimplificationRule</name>
        <qualifiedname>csl::testSimplificationRule</qualifiedname>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; const &amp;</type>
          <declname>arg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.cpp" line="430" column="6" bodyfile="src/csl/operations.cpp" bodystart="430" bodyend="485"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a113b6a95fdf142a89734f25f30205aa5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::getExponentStructure</definition>
        <argsstring>(const Expr &amp;argument, Expr &amp;term, Expr &amp;exponent)</argsstring>
        <name>getExponentStructure</name>
        <qualifiedname>csl::getExponentStructure</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>argument</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>term</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>exponent</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.cpp" line="1499" column="6" bodyfile="src/csl/operations.cpp" bodystart="1499" bodyend="1517" declfile="src/csl/operations.h" declline="282" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1acdebee488b22c2dc74e7c6fb4e0ed0d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::applyOperator</definition>
        <argsstring>(Expr &amp;product)</argsstring>
        <name>applyOperator</name>
        <qualifiedname>csl::applyOperator</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>product</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.cpp" line="2226" column="6" bodyfile="src/csl/operations.cpp" bodystart="2226" bodyend="2269" declfile="src/csl/operations.h" declline="829" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ac510c2f73f168edd547c98bed8034e61" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::tensor_s</definition>
        <argsstring>(const std::vector&lt; int &gt; &amp;shape, const Expr &amp;filler)</argsstring>
        <name>tensor_s</name>
        <qualifiedname>csl::tensor_s</qualifiedname>
        <param>
          <type>const std::vector&lt; int &gt; &amp;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>filler</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operations.h" line="899" column="6" declfile="src/csl/operations.h" declline="899" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a4e555e3ffb0831348ca4e0635f476663" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::pullLeft</definition>
        <argsstring>(csl::vector_expr &amp;argument, size_t pos, size_t &amp;begin)</argsstring>
        <name>pullLeft</name>
        <qualifiedname>csl::pullLeft</qualifiedname>
        <param>
          <type>csl::vector_expr &amp;</type>
          <declname>argument</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>pos</declname>
        </param>
        <param>
          <type>size_t &amp;</type>
          <declname>begin</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operator.cpp" line="21" column="6" bodyfile="src/csl/operator.cpp" bodystart="21" bodyend="38" declfile="src/csl/operator.h" declline="126" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a71ca267a1d73b0df869e624c1a081d0f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::pullRight</definition>
        <argsstring>(csl::vector_expr &amp;argument, size_t &amp;pos, size_t &amp;end)</argsstring>
        <name>pullRight</name>
        <qualifiedname>csl::pullRight</qualifiedname>
        <param>
          <type>csl::vector_expr &amp;</type>
          <declname>argument</declname>
        </param>
        <param>
          <type>size_t &amp;</type>
          <declname>pos</declname>
        </param>
        <param>
          <type>size_t &amp;</type>
          <declname>end</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operator.cpp" line="40" column="6" bodyfile="src/csl/operator.cpp" bodystart="40" bodyend="58" declfile="src/csl/operator.h" declline="127" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a01860bd23e3776aff3f1a3e43e040fb4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::getParts</definition>
        <argsstring>(const csl::vector_expr &amp;argument, size_t begin, size_t end, Expr &amp;left, Expr &amp;mid, Expr &amp;right)</argsstring>
        <name>getParts</name>
        <qualifiedname>csl::getParts</qualifiedname>
        <param>
          <type>const csl::vector_expr &amp;</type>
          <declname>argument</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>begin</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>end</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>mid</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/operator.cpp" line="60" column="6" bodyfile="src/csl/operator.cpp" bodystart="60" bodyend="84" declfile="src/csl/operator.h" declline="128" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a7d08b2e05fa33edd2dcd37e6cebba555" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::pair&lt; std::string, std::string &gt;</type>
        <definition>std::pair&lt; std::string, std::string &gt; csl::getRegularAndLatexNames</definition>
        <argsstring>(std::string t_name)</argsstring>
        <name>getRegularAndLatexNames</name>
        <qualifiedname>csl::getRegularAndLatexNames</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>t_name</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/parent.cpp" line="24" column="11" bodyfile="src/csl/parent.cpp" bodystart="24" bodyend="53"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a6d459392c2ed133819be1efcff122032" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; csl::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;fout, const AbstractParent &amp;parent)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>csl::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>fout</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1AbstractParent" kindref="compound">AbstractParent</ref> &amp;</type>
          <declname>parent</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>\function std::ostream&amp; <ref refid="namespacecsl_1a6d459392c2ed133819be1efcff122032" kindref="member">operator&lt;&lt;(std::ostream&amp; fout ,
                                  const AbstractParent&amp; p)</ref> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/parent.cpp" line="512" column="1" bodyfile="src/csl/parent.cpp" bodystart="512" bodyend="519"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a90c9913d2f70c338a23882d6f83cf347" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::haveCommonIndices</definition>
        <argsstring>(csl::Expr const &amp;a, csl::Expr const &amp;b, csl::Space const *space)</argsstring>
        <name>haveCommonIndices</name>
        <qualifiedname>csl::haveCommonIndices</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Space" kindref="compound">csl::Space</ref> const *</type>
          <declname>space</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.cpp" line="28" column="6" bodyfile="src/csl/partialExpand.cpp" bodystart="28" bodyend="42" declfile="src/csl/partialExpand.h" declline="28" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a1141c4d9aa93198816311a91f03fd10f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::alreadyInChain</definition>
        <argsstring>(size_t pos, std::vector&lt; ExpansionChain &gt; const &amp;chains)</argsstring>
        <name>alreadyInChain</name>
        <qualifiedname>csl::alreadyInChain</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>pos</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="structcsl_1_1ExpansionChain" kindref="compound">ExpansionChain</ref> &gt; const &amp;</type>
          <declname>chains</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.cpp" line="44" column="6" bodyfile="src/csl/partialExpand.cpp" bodystart="44" bodyend="56"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a0dcbce2497137e65cba2c71e1c11ca24" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const *</type>
        <definition>csl::Expr const  * csl::getEmitter</definition>
        <argsstring>(csl::Expr const &amp;expr, ExpanderEmitter const &amp;isEmitter)</argsstring>
        <name>getEmitter</name>
        <qualifiedname>csl::getEmitter</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>ExpanderEmitter const &amp;</type>
          <declname>isEmitter</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.cpp" line="58" column="17" bodyfile="src/csl/partialExpand.cpp" bodystart="58" bodyend="70"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a0af17a920823f407f277d6ac9b86af82" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::any_of</definition>
        <argsstring>(csl::Expr const *emi, csl::Expr const &amp;rec, ExpanderReceiver const &amp;isReceiver)</argsstring>
        <name>any_of</name>
        <qualifiedname>csl::any_of</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const *</type>
          <declname>emi</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>rec</declname>
        </param>
        <param>
          <type>ExpanderReceiver const &amp;</type>
          <declname>isReceiver</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.cpp" line="71" column="6" bodyfile="src/csl/partialExpand.cpp" bodystart="71" bodyend="78"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a4409bd6346bf33b84350156b1db0d407" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t csl::getNTerms</definition>
        <argsstring>(csl::Expr const &amp;prod, ExpansionChain const &amp;toExpand, ExpanderReceiver const &amp;isReceiver)</argsstring>
        <name>getNTerms</name>
        <qualifiedname>csl::getNTerms</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>prod</declname>
        </param>
        <param>
          <type><ref refid="structcsl_1_1ExpansionChain" kindref="compound">ExpansionChain</ref> const &amp;</type>
          <declname>toExpand</declname>
        </param>
        <param>
          <type>ExpanderReceiver const &amp;</type>
          <declname>isReceiver</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.cpp" line="80" column="8" bodyfile="src/csl/partialExpand.cpp" bodystart="80" bodyend="105"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a10cb57f38089e99a76462277bfff9dae" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref></type>
        <definition>csl::Expr csl::applyExpansion</definition>
        <argsstring>(csl::Expr const &amp;prod, ExpansionChain const &amp;toExpand, ExpanderEmitter const &amp;isEmitter, ExpanderReceiver const &amp;isReceiver, bool applyRecursively)</argsstring>
        <name>applyExpansion</name>
        <qualifiedname>csl::applyExpansion</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>prod</declname>
        </param>
        <param>
          <type><ref refid="structcsl_1_1ExpansionChain" kindref="compound">ExpansionChain</ref> const &amp;</type>
          <declname>toExpand</declname>
        </param>
        <param>
          <type>ExpanderEmitter const &amp;</type>
          <declname>isEmitter</declname>
        </param>
        <param>
          <type>ExpanderReceiver const &amp;</type>
          <declname>isReceiver</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>applyRecursively</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.cpp" line="107" column="11" bodyfile="src/csl/partialExpand.cpp" bodystart="107" bodyend="168"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae51be1236a451fe3b7a9562fbe062437" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::hasCommonIndex</definition>
        <argsstring>(std::vector&lt; size_t &gt; const &amp;sortedA, std::vector&lt; size_t &gt; const &amp;sortedB)</argsstring>
        <name>hasCommonIndex</name>
        <qualifiedname>csl::hasCommonIndex</qualifiedname>
        <param>
          <type>std::vector&lt; size_t &gt; const &amp;</type>
          <declname>sortedA</declname>
        </param>
        <param>
          <type>std::vector&lt; size_t &gt; const &amp;</type>
          <declname>sortedB</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.cpp" line="170" column="6" bodyfile="src/csl/partialExpand.cpp" bodystart="170" bodyend="192"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae755288ca88a0a696357183959d1132f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::mergeChains</definition>
        <argsstring>(std::vector&lt; ExpansionChain &gt; &amp;toExpand)</argsstring>
        <name>mergeChains</name>
        <qualifiedname>csl::mergeChains</qualifiedname>
        <param>
          <type>std::vector&lt; <ref refid="structcsl_1_1ExpansionChain" kindref="compound">ExpansionChain</ref> &gt; &amp;</type>
          <declname>toExpand</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.cpp" line="194" column="6" bodyfile="src/csl/partialExpand.cpp" bodystart="194" bodyend="214"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a581930a9e8ef60ba4ccde160f46f8b1c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::PartialExpandImplementation</definition>
        <argsstring>(Expr &amp;prod, ExpanderEmitter const &amp;isEmitter, ExpanderReceiver const &amp;isReceiver)</argsstring>
        <name>PartialExpandImplementation</name>
        <qualifiedname>csl::PartialExpandImplementation</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>prod</declname>
        </param>
        <param>
          <type>ExpanderEmitter const &amp;</type>
          <declname>isEmitter</declname>
        </param>
        <param>
          <type>ExpanderReceiver const &amp;</type>
          <declname>isReceiver</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.cpp" line="216" column="6" bodyfile="src/csl/partialExpand.cpp" bodystart="216" bodyend="300" declfile="src/csl/partialExpand.h" declline="32" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a761409fd06a017d848cc04d4c7a7ad9c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::PartialExpandImplementation</definition>
        <argsstring>(Expr &amp;prod, ExpanderEmitter const &amp;isEmitter, ExpanderEmitter const &amp;isReceiver)</argsstring>
        <name>PartialExpandImplementation</name>
        <qualifiedname>csl::PartialExpandImplementation</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>prod</declname>
        </param>
        <param>
          <type>ExpanderEmitter const &amp;</type>
          <declname>isEmitter</declname>
        </param>
        <param>
          <type>ExpanderEmitter const &amp;</type>
          <declname>isReceiver</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.cpp" line="302" column="6" bodyfile="src/csl/partialExpand.cpp" bodystart="302" bodyend="312" declfile="src/csl/partialExpand.h" declline="36" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a828d00aa38a5cb04ac9df50cf64a0c26" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::PartialExpanded</definition>
        <argsstring>(Expr const &amp;init, ExpanderEmitter const &amp;isEmitter, ExpanderReceiver const &amp;isReceiver)</argsstring>
        <name>PartialExpanded</name>
        <qualifiedname>csl::PartialExpanded</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>ExpanderEmitter const &amp;</type>
          <declname>isEmitter</declname>
        </param>
        <param>
          <type>ExpanderReceiver const &amp;</type>
          <declname>isReceiver</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.cpp" line="314" column="6" bodyfile="src/csl/partialExpand.cpp" bodystart="314" bodyend="321" declfile="src/csl/partialExpand.h" declline="48" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae7530a412075a5a8372f298c55c2a72f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::PartialExpand</definition>
        <argsstring>(Expr &amp;init, ExpanderEmitter const &amp;isEmitter, ExpanderReceiver const &amp;isReceiver)</argsstring>
        <name>PartialExpand</name>
        <qualifiedname>csl::PartialExpand</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>ExpanderEmitter const &amp;</type>
          <declname>isEmitter</declname>
        </param>
        <param>
          <type>ExpanderReceiver const &amp;</type>
          <declname>isReceiver</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.cpp" line="322" column="6" bodyfile="src/csl/partialExpand.cpp" bodystart="322" bodyend="328" declfile="src/csl/partialExpand.h" declline="51" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1abaf22e1622a9b202a9eb06251212a918" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::DeepPartialExpanded</definition>
        <argsstring>(Expr const &amp;init, ExpanderEmitter const &amp;isEmitter, ExpanderReceiver const &amp;isReceiver)</argsstring>
        <name>DeepPartialExpanded</name>
        <qualifiedname>csl::DeepPartialExpanded</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>ExpanderEmitter const &amp;</type>
          <declname>isEmitter</declname>
        </param>
        <param>
          <type>ExpanderReceiver const &amp;</type>
          <declname>isReceiver</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.cpp" line="329" column="6" bodyfile="src/csl/partialExpand.cpp" bodystart="329" bodyend="336" declfile="src/csl/partialExpand.h" declline="54" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aac390377ac85216c687973cf55044a15" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::DeepPartialExpand</definition>
        <argsstring>(Expr &amp;init, ExpanderEmitter const &amp;isEmitter, ExpanderReceiver const &amp;isReceiver)</argsstring>
        <name>DeepPartialExpand</name>
        <qualifiedname>csl::DeepPartialExpand</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>ExpanderEmitter const &amp;</type>
          <declname>isEmitter</declname>
        </param>
        <param>
          <type>ExpanderReceiver const &amp;</type>
          <declname>isReceiver</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.cpp" line="337" column="6" bodyfile="src/csl/partialExpand.cpp" bodystart="337" bodyend="346" declfile="src/csl/partialExpand.h" declline="57" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a623c52c8d2c4930f73f68c579eb853fa" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::PartialExpandImplementation</definition>
        <argsstring>(Expr &amp;prod, ExpanderEmitter const &amp;isEmitterReceiver)</argsstring>
        <name>PartialExpandImplementation</name>
        <qualifiedname>csl::PartialExpandImplementation</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>prod</declname>
        </param>
        <param>
          <type>ExpanderEmitter const &amp;</type>
          <declname>isEmitterReceiver</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.h" line="41" column="1" bodyfile="src/csl/partialExpand.h" bodystart="41" bodyend="46"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ad51cab5644c4ea063e2dd6c6e81ec3c0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::PartialExpanded</definition>
        <argsstring>(Expr const &amp;init, ExpanderEmitter const &amp;isEmitter, ExpanderEmitter const &amp;isReceiver)</argsstring>
        <name>PartialExpanded</name>
        <qualifiedname>csl::PartialExpanded</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>ExpanderEmitter const &amp;</type>
          <declname>isEmitter</declname>
        </param>
        <param>
          <type>ExpanderEmitter const &amp;</type>
          <declname>isReceiver</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.h" line="61" column="13" bodyfile="src/csl/partialExpand.h" bodystart="61" bodyend="71"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a03b4e902bc3d08c3d8dd8656f876a356" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::PartialExpand</definition>
        <argsstring>(Expr &amp;init, ExpanderEmitter const &amp;isEmitter, ExpanderEmitter const &amp;isReceiver)</argsstring>
        <name>PartialExpand</name>
        <qualifiedname>csl::PartialExpand</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>ExpanderEmitter const &amp;</type>
          <declname>isEmitter</declname>
        </param>
        <param>
          <type>ExpanderEmitter const &amp;</type>
          <declname>isReceiver</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.h" line="72" column="13" bodyfile="src/csl/partialExpand.h" bodystart="72" bodyend="82"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a8344257ba4df866eb26909f43df213be" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::DeepPartialExpanded</definition>
        <argsstring>(Expr const &amp;init, ExpanderEmitter const &amp;isEmitter, ExpanderEmitter const &amp;isReceiver)</argsstring>
        <name>DeepPartialExpanded</name>
        <qualifiedname>csl::DeepPartialExpanded</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>ExpanderEmitter const &amp;</type>
          <declname>isEmitter</declname>
        </param>
        <param>
          <type>ExpanderEmitter const &amp;</type>
          <declname>isReceiver</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.h" line="83" column="13" bodyfile="src/csl/partialExpand.h" bodystart="83" bodyend="93"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aed32c5f631808284919014f0377cd011" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::DeepPartialExpand</definition>
        <argsstring>(Expr &amp;init, ExpanderEmitter const &amp;isEmitter, ExpanderEmitter const &amp;isReceiver)</argsstring>
        <name>DeepPartialExpand</name>
        <qualifiedname>csl::DeepPartialExpand</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>ExpanderEmitter const &amp;</type>
          <declname>isEmitter</declname>
        </param>
        <param>
          <type>ExpanderEmitter const &amp;</type>
          <declname>isReceiver</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.h" line="94" column="13" bodyfile="src/csl/partialExpand.h" bodystart="94" bodyend="104"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af05686d056ffec54b490ca1d2467bf7a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::PartialExpanded</definition>
        <argsstring>(Expr const &amp;init, ExpanderEmitter const &amp;isEmitter)</argsstring>
        <name>PartialExpanded</name>
        <qualifiedname>csl::PartialExpanded</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>ExpanderEmitter const &amp;</type>
          <declname>isEmitter</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.h" line="106" column="13" bodyfile="src/csl/partialExpand.h" bodystart="106" bodyend="109"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a1a601398238ce0f6f930b34b2b42ea1e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::PartialExpand</definition>
        <argsstring>(Expr &amp;init, ExpanderEmitter const &amp;isEmitter)</argsstring>
        <name>PartialExpand</name>
        <qualifiedname>csl::PartialExpand</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>ExpanderEmitter const &amp;</type>
          <declname>isEmitter</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.h" line="110" column="13" bodyfile="src/csl/partialExpand.h" bodystart="110" bodyend="113"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a1943ccff7f928b3bb290065b6e8e5c12" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::DeepPartialExpanded</definition>
        <argsstring>(Expr const &amp;init, ExpanderEmitter const &amp;isEmitter)</argsstring>
        <name>DeepPartialExpanded</name>
        <qualifiedname>csl::DeepPartialExpanded</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>ExpanderEmitter const &amp;</type>
          <declname>isEmitter</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.h" line="114" column="13" bodyfile="src/csl/partialExpand.h" bodystart="114" bodyend="118"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a55ca880f3db2212f1f18622aadd8e3ee" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::DeepPartialExpand</definition>
        <argsstring>(Expr &amp;init, ExpanderEmitter const &amp;isEmitter)</argsstring>
        <name>DeepPartialExpand</name>
        <qualifiedname>csl::DeepPartialExpand</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>ExpanderEmitter const &amp;</type>
          <declname>isEmitter</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/partialExpand.h" line="119" column="13" bodyfile="src/csl/partialExpand.h" bodystart="119" bodyend="122"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a650c0bbbc95c736099f3a8113ba0e915" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::suppressTerm</definition>
        <argsstring>(Expr &amp;init, Expr const &amp;term)</argsstring>
        <name>suppressTerm</name>
        <qualifiedname>csl::suppressTerm</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>term</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/pseudoIntegral.cpp" line="137" column="6" bodyfile="src/csl/pseudoIntegral.cpp" bodystart="137" bodyend="148"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a88b34c3d4a8097a6a6f7279ba9a6e6d3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::MakeScalarIntegral</definition>
        <argsstring>(Expr &amp;init)</argsstring>
        <name>MakeScalarIntegral</name>
        <qualifiedname>csl::MakeScalarIntegral</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/pseudoIntegral.cpp" line="913" column="6" bodyfile="src/csl/pseudoIntegral.cpp" bodystart="913" bodyend="943"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ad05fcc3dc932d703d52ba5889a8314c5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::MakeIntegral</definition>
        <argsstring>(Expr &amp;init)</argsstring>
        <name>MakeIntegral</name>
        <qualifiedname>csl::MakeIntegral</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/pseudoIntegral.cpp" line="945" column="6" bodyfile="src/csl/pseudoIntegral.cpp" bodystart="945" bodyend="980" declfile="src/csl/pseudoIntegral.h" declline="312" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a3cb880e44ce2aa995cf4c48b15fa2f13" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::vectorintegral_s</definition>
        <argsstring>(const Tensor &amp;variables)</argsstring>
        <name>vectorintegral_s</name>
        <qualifiedname>csl::vectorintegral_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>variables</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/pseudoIntegral.cpp" line="982" column="6" bodyfile="src/csl/pseudoIntegral.cpp" bodystart="982" bodyend="986" declfile="src/csl/pseudoIntegral.h" declline="321" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a65fb6c03f69d9150fdc5552ab3492ea7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::scalarintegral_s</definition>
        <argsstring>(Args ...args)</argsstring>
        <name>scalarintegral_s</name>
        <qualifiedname>csl::scalarintegral_s</qualifiedname>
        <param>
          <type>Args ...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/pseudoIntegral.h" line="315" column="6" bodyfile="src/csl/pseudoIntegral.h" bodystart="315" bodyend="319"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2d25b152139279dfe461c88ffe0740f8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::vectorintegral_s</definition>
        <argsstring>(const Expr &amp;operand, const Tensor &amp;variables, Args... args)</argsstring>
        <name>vectorintegral_s</name>
        <qualifiedname>csl::vectorintegral_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>operand</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>variables</declname>
        </param>
        <param>
          <type>Args...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/pseudoIntegral.h" line="324" column="6" bodyfile="src/csl/pseudoIntegral.h" bodystart="324" bodyend="330"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a6acc43ce5e5aad372bf3ba7a1e397162" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::vectorintegral_s</definition>
        <argsstring>(const Tensor &amp;variables, Args... args)</argsstring>
        <name>vectorintegral_s</name>
        <qualifiedname>csl::vectorintegral_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>variables</declname>
        </param>
        <param>
          <type>Args...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/pseudoIntegral.h" line="333" column="6" bodyfile="src/csl/pseudoIntegral.h" bodystart="333" bodyend="338"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae1945e37f740cebc9c2e43f52ef72ba9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::vectorintegral_s</definition>
        <argsstring>(const Parent &amp;variables)</argsstring>
        <name>vectorintegral_s</name>
        <qualifiedname>csl::vectorintegral_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref> &amp;</type>
          <declname>variables</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/pseudoIntegral.h" line="340" column="13" bodyfile="src/csl/pseudoIntegral.h" bodystart="340" bodyend="348"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ad36e387cbfb4da55af4853831c5ad919" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::vectorintegral_s</definition>
        <argsstring>(const Expr &amp;operand, const Parent &amp;variables, Args... args)</argsstring>
        <name>vectorintegral_s</name>
        <qualifiedname>csl::vectorintegral_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>operand</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref> &amp;</type>
          <declname>variables</declname>
        </param>
        <param>
          <type>Args...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/pseudoIntegral.h" line="351" column="6" bodyfile="src/csl/pseudoIntegral.h" bodystart="351" bodyend="360"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2031c89182609d1d769e0fd9ace2a020" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::vectorintegral_s</definition>
        <argsstring>(const Parent &amp;variables, Args... args)</argsstring>
        <name>vectorintegral_s</name>
        <qualifiedname>csl::vectorintegral_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref> &amp;</type>
          <declname>variables</declname>
        </param>
        <param>
          <type>Args...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/pseudoIntegral.h" line="363" column="6" bodyfile="src/csl/pseudoIntegral.h" bodystart="363" bodyend="371"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af19a4a894ef3884cb6cda68f5d092227" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Replace</definition>
        <argsstring>(csl::Expr &amp;expr, csl::Expr const &amp;from, csl::Expr const &amp;to)</argsstring>
        <name>Replace</name>
        <qualifiedname>csl::Replace</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.cpp" line="31" column="6" bodyfile="src/csl/replace.cpp" bodystart="31" bodyend="34" declfile="src/csl/replace.h" declline="27" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a928a62a7797c0600e507354c75bacc81" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Replace</definition>
        <argsstring>(csl::Expr &amp;expr, csl::Parent const &amp;from, csl::Parent const &amp;to)</argsstring>
        <name>Replace</name>
        <qualifiedname>csl::Replace</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Parent" kindref="compound">csl::Parent</ref> const &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Parent" kindref="compound">csl::Parent</ref> const &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.cpp" line="36" column="6" bodyfile="src/csl/replace.cpp" bodystart="36" bodyend="40" declfile="src/csl/replace.h" declline="29" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a10b3d8eec3e76056f888fbd20e78a846" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Replace</definition>
        <argsstring>(csl::Expr &amp;expr, csl::Parent const &amp;from, csl::Expr const &amp;to_init)</argsstring>
        <name>Replace</name>
        <qualifiedname>csl::Replace</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Parent" kindref="compound">csl::Parent</ref> const &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>to_init</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.cpp" line="42" column="6" bodyfile="src/csl/replace.cpp" bodystart="42" bodyend="48" declfile="src/csl/replace.h" declline="31" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a7c327742707f6732e9436b65b9c3f0f6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Replace</definition>
        <argsstring>(csl::Expr &amp;expr, std::vector&lt; csl::Parent &gt; const &amp;from, std::vector&lt; csl::Parent &gt; const &amp;to)</argsstring>
        <name>Replace</name>
        <qualifiedname>csl::Replace</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Parent" kindref="compound">csl::Parent</ref> &gt; const &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Parent" kindref="compound">csl::Parent</ref> &gt; const &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.cpp" line="50" column="6" bodyfile="src/csl/replace.cpp" bodystart="50" bodyend="66" declfile="src/csl/replace.h" declline="33" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a7799d21056038c2e6e7e8940e6a8b019" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Replace</definition>
        <argsstring>(csl::Expr &amp;expr, std::vector&lt; csl::Expr &gt; const &amp;from, std::vector&lt; csl::Expr &gt; const &amp;to)</argsstring>
        <name>Replace</name>
        <qualifiedname>csl::Replace</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt; const &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt; const &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.cpp" line="68" column="6" bodyfile="src/csl/replace.cpp" bodystart="68" bodyend="95" declfile="src/csl/replace.h" declline="37" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a64382d0f012ea0da49c04b3d5180fbf0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::ReplaceIndicial</definition>
        <argsstring>(csl::Expr &amp;expr, std::vector&lt; csl::Expr &gt; const &amp;from, std::vector&lt; csl::Expr &gt; const &amp;to)</argsstring>
        <name>ReplaceIndicial</name>
        <qualifiedname>csl::ReplaceIndicial</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt; const &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt; const &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.cpp" line="97" column="6" bodyfile="src/csl/replace.cpp" bodystart="97" bodyend="135" declfile="src/csl/replace.h" declline="41" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a924651e3621cf644fd7fa829c5a802ee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Replace</definition>
        <argsstring>(csl::Expr &amp;expr, std::vector&lt; csl::Parent &gt; const &amp;from, std::vector&lt; csl::Expr &gt; const &amp;to_init, bool refresh)</argsstring>
        <name>Replace</name>
        <qualifiedname>csl::Replace</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Parent" kindref="compound">csl::Parent</ref> &gt; const &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt; const &amp;</type>
          <declname>to_init</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>refresh</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.cpp" line="137" column="6" bodyfile="src/csl/replace.cpp" bodystart="137" bodyend="170" declfile="src/csl/replace.h" declline="45" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aad88f9d3fc900699c7f223f1c4debf98" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref></type>
        <definition>csl::Expr csl::Replaced</definition>
        <argsstring>(csl::Expr const &amp;expr, csl::Index const &amp;from, csl::Index const &amp;to, bool refresh)</argsstring>
        <name>Replaced</name>
        <qualifiedname>csl::Replaced</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref> const &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref> const &amp;</type>
          <declname>to</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>refresh</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.cpp" line="176" column="11" bodyfile="src/csl/replace.cpp" bodystart="176" bodyend="182" declfile="src/csl/replace.h" declline="90" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a516dd37780a1f2e02e9e860fd8581665" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref></type>
        <definition>csl::Expr csl::Replaced</definition>
        <argsstring>(csl::Expr const &amp;expr, std::vector&lt; csl::Index &gt; const &amp;from, std::vector&lt; csl::Index &gt; const &amp;to, bool refresh)</argsstring>
        <name>Replaced</name>
        <qualifiedname>csl::Replaced</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref> &gt; const &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref> &gt; const &amp;</type>
          <declname>to</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>refresh</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.cpp" line="184" column="11" bodyfile="src/csl/replace.cpp" bodystart="184" bodyend="205" declfile="src/csl/replace.h" declline="103" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a20d71b6e63667dd0aaa8cb7c747c4c2c" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref></type>
        <definition>csl::Expr csl::Replaced</definition>
        <argsstring>(csl::Expr const &amp;expr, csl::IndexStructure const &amp;from, csl::IndexStructure const &amp;to, bool refresh)</argsstring>
        <name>Replaced</name>
        <qualifiedname>csl::Replaced</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1IndexStructure" kindref="compound">csl::IndexStructure</ref> const &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1IndexStructure" kindref="compound">csl::IndexStructure</ref> const &amp;</type>
          <declname>to</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>refresh</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.cpp" line="207" column="11" bodyfile="src/csl/replace.cpp" bodystart="207" bodyend="213" declfile="src/csl/replace.h" declline="116" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a65b6337073b66a62d69827fd9246f092" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::hasWeakDependency</definition>
        <argsstring>(csl::Expr const &amp;expr, std::function&lt; bool(csl::Expr const &amp;)&gt; const &amp;predicate)</argsstring>
        <name>hasWeakDependency</name>
        <qualifiedname>csl::hasWeakDependency</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::function&lt; bool(<ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;)&gt; const &amp;</type>
          <declname>predicate</declname>
        </param>
        <briefdescription>
<para>Search for a true value for a given predicate in an expression, considering also sub-expressions encapsulated by abbreviations. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>The expression in which the search is done. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>predicate</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean predicate.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if on sub-expression checks the predicate. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.cpp" line="219" column="6" bodyfile="src/csl/replace.cpp" bodystart="219" bodyend="232" declfile="src/csl/replace.h" declline="172" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a178cb5ff11ecfb69f32bbdea3253712a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::applyThroughAbbreviations</definition>
        <argsstring>(csl::Expr &amp;expr, replacementRule const &amp;rule)</argsstring>
        <name>applyThroughAbbreviations</name>
        <qualifiedname>csl::applyThroughAbbreviations</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="namespacecsl_1a236c3928ac0b1760b8738490dcf82706" kindref="member">replacementRule</ref> const &amp;</type>
          <declname>rule</declname>
        </param>
        <briefdescription>
<para>Applies a replacement rule thoughout an expression, also entering abbreviations and replacing them if a replacement is found. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression in which the replacement takes place. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rule</parametername>
</parameternamelist>
<parameterdescription>
<para>Rule for the replacement. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.cpp" line="234" column="6" bodyfile="src/csl/replace.cpp" bodystart="234" bodyend="254" declfile="src/csl/replace.h" declline="183" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af1d511b748fb0264b448b6757d78846b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt;</type>
        <definition>std::optional&lt; csl::Expr &gt; csl::scalarReplacement</definition>
        <argsstring>(csl::Expr const &amp;expr, std::vector&lt; csl::Expr &gt; const &amp;from, std::vector&lt; csl::Expr &gt; const &amp;ccFrom, std::vector&lt; csl::Expr &gt; const &amp;to, bool isPredicate)</argsstring>
        <name>scalarReplacement</name>
        <qualifiedname>csl::scalarReplacement</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt; const &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt; const &amp;</type>
          <declname>ccFrom</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt; const &amp;</type>
          <declname>to</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>isPredicate</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.cpp" line="261" column="1" bodyfile="src/csl/replace.cpp" bodystart="261" bodyend="297" declfile="src/csl/replace.h" declline="190" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa9816bee914b3eb4f9183212664c505b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt;</type>
        <definition>std::optional&lt; csl::Expr &gt; csl::indicialReplacement</definition>
        <argsstring>(csl::Expr const &amp;expr, std::vector&lt; csl::Expr &gt; const &amp;from, std::vector&lt; csl::Parent_info &gt; const &amp;parentFrom, std::vector&lt; csl::Expr &gt; const &amp;to, bool isPredicate)</argsstring>
        <name>indicialReplacement</name>
        <qualifiedname>csl::indicialReplacement</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt; const &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1AbstractParent" kindref="compound">csl::Parent_info</ref> &gt; const &amp;</type>
          <declname>parentFrom</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt; const &amp;</type>
          <declname>to</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>isPredicate</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.cpp" line="300" column="1" bodyfile="src/csl/replace.cpp" bodystart="300" bodyend="335" declfile="src/csl/replace.h" declline="197" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a33a995aa2bcb8419ccb42c95baf51fa5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt;</type>
        <definition>std::optional&lt; csl::Expr &gt; csl::tensorReplacement</definition>
        <argsstring>(csl::Expr const &amp;expr, std::vector&lt; csl::Parent &gt; const &amp;from, std::vector&lt; csl::Parent &gt; const &amp;to, bool isPredicate)</argsstring>
        <name>tensorReplacement</name>
        <qualifiedname>csl::tensorReplacement</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Parent" kindref="compound">csl::Parent</ref> &gt; const &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Parent" kindref="compound">csl::Parent</ref> &gt; const &amp;</type>
          <declname>to</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>isPredicate</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.cpp" line="338" column="1" bodyfile="src/csl/replace.cpp" bodystart="338" bodyend="375" declfile="src/csl/replace.h" declline="204" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa4789033cbd37c9f98055c332e342bee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt;</type>
        <definition>std::optional&lt; csl::Expr &gt; csl::tensorExpressionReplacement</definition>
        <argsstring>(csl::Expr const &amp;expr, std::vector&lt; csl::Parent &gt; const &amp;from, std::vector&lt; csl::Expr &gt; const &amp;to, bool isPredicate)</argsstring>
        <name>tensorExpressionReplacement</name>
        <qualifiedname>csl::tensorExpressionReplacement</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Parent" kindref="compound">csl::Parent</ref> &gt; const &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt; const &amp;</type>
          <declname>to</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>isPredicate</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.cpp" line="378" column="1" bodyfile="src/csl/replace.cpp" bodystart="378" bodyend="404" declfile="src/csl/replace.h" declline="210" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aded19f239ae47cf9919876b0ba4131b7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::ResetDummyIndices</definition>
        <argsstring>(csl::Expr &amp;expr)</argsstring>
        <name>ResetDummyIndices</name>
        <qualifiedname>csl::ResetDummyIndices</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.cpp" line="410" column="6" bodyfile="src/csl/replace.cpp" bodystart="410" bodyend="423" declfile="src/csl/replace.h" declline="219" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a16f439dc79da309c3d30433725250064" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::ApplyIndices</definition>
        <argsstring>(csl::Expr &amp;expr, csl::IndexStructure const &amp;freeStructure)</argsstring>
        <name>ApplyIndices</name>
        <qualifiedname>csl::ApplyIndices</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1IndexStructure" kindref="compound">csl::IndexStructure</ref> const &amp;</type>
          <declname>freeStructure</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.cpp" line="425" column="6" bodyfile="src/csl/replace.cpp" bodystart="425" bodyend="438" declfile="src/csl/replace.h" declline="221" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1adbfe96415afe869c8e4d414099fdc4c8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::ApplyIndices</definition>
        <argsstring>(csl::Expr &amp;expr, csl::IndexStructure const &amp;from, csl::IndexStructure const &amp;to)</argsstring>
        <name>ApplyIndices</name>
        <qualifiedname>csl::ApplyIndices</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1IndexStructure" kindref="compound">csl::IndexStructure</ref> const &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1IndexStructure" kindref="compound">csl::IndexStructure</ref> const &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.cpp" line="440" column="6" bodyfile="src/csl/replace.cpp" bodystart="440" bodyend="453" declfile="src/csl/replace.h" declline="223" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a52740687b676803d51f5f2b12c66c65b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::renameIndex</definition>
        <argsstring>(csl::Index &amp;index, std::map&lt; csl::Index, csl::Index &gt; &amp;mapping)</argsstring>
        <name>renameIndex</name>
        <qualifiedname>csl::renameIndex</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref> &amp;</type>
          <declname>index</declname>
        </param>
        <param>
          <type>std::map&lt; <ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref>, <ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref> &gt; &amp;</type>
          <declname>mapping</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.cpp" line="455" column="6" bodyfile="src/csl/replace.cpp" bodystart="455" bodyend="490" declfile="src/csl/replace.h" declline="227" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a5d5cc29e454cbdff48a4ac3f365d0aad" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::RenameIndices</definition>
        <argsstring>(csl::Expr &amp;expr)</argsstring>
        <name>RenameIndices</name>
        <qualifiedname>csl::RenameIndices</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.cpp" line="492" column="6" bodyfile="src/csl/replace.cpp" bodystart="492" bodyend="505" declfile="src/csl/replace.h" declline="229" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1abe92af6e2c7997b1d37e45b56a681d8b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref></type>
        <definition>csl::Expr csl::RenamedIndices</definition>
        <argsstring>(csl::Expr const &amp;expr)</argsstring>
        <name>RenamedIndices</name>
        <qualifiedname>csl::RenamedIndices</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.cpp" line="507" column="11" bodyfile="src/csl/replace.cpp" bodystart="507" bodyend="512" declfile="src/csl/replace.h" declline="231" declcolumn="11"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a19802a4621c3cbbef15e642a0d9b0dfc" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
          <param>
            <type>class...</type>
            <declname>Params</declname>
            <defname>Params</defname>
          </param>
          <param>
            <type>typename</type>
            <defval>std::enable_if_t&lt;        !csl::canDecay_v&lt;            T,            U,            csl::                Index&gt; &amp;&amp; !csl::canDecay_v&lt;T, U, <ref refid="classcsl_1_1IndexStructure" kindref="compound">csl::IndexStructure</ref>&gt; &amp;&amp; !csl::canDecay_v&lt;T, U, std::vector&lt;<ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref>&gt;&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref></type>
        <definition>csl::Expr csl::Replaced</definition>
        <argsstring>(csl::Expr const &amp;expr, T &amp;&amp;p1, U &amp;&amp;p2, Params &amp;&amp;... params)</argsstring>
        <name>Replaced</name>
        <qualifiedname>csl::Replaced</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>T &amp;&amp;</type>
          <declname>p1</declname>
        </param>
        <param>
          <type>U &amp;&amp;</type>
          <declname>p2</declname>
        </param>
        <param>
          <type>Params &amp;&amp;...</type>
          <declname>params</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.h" line="76" column="1" bodyfile="src/csl/replace.h" bodystart="76" bodyend="84"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a4778e32b6eb23d0cebe39dcbcfdc19e8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Replace</definition>
        <argsstring>(csl::Expr &amp;expr, csl::Index const &amp;from, csl::Index const &amp;to, bool refresh=true)</argsstring>
        <name>Replace</name>
        <qualifiedname>csl::Replace</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref> const &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref> const &amp;</type>
          <declname>to</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>refresh</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.h" line="95" column="13" bodyfile="src/csl/replace.h" bodystart="95" bodyend="101"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a0e074a686822f704a46b1c3d3d31ba87" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Replace</definition>
        <argsstring>(csl::Expr &amp;expr, std::vector&lt; csl::Index &gt; const &amp;from, std::vector&lt; csl::Index &gt; const &amp;to, bool refresh=true)</argsstring>
        <name>Replace</name>
        <qualifiedname>csl::Replace</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref> &gt; const &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">csl::Index</ref> &gt; const &amp;</type>
          <declname>to</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>refresh</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.h" line="108" column="13" bodyfile="src/csl/replace.h" bodystart="108" bodyend="114"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1afea0cca96e24945e7f10fa51a6b31f55" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Replace</definition>
        <argsstring>(csl::Expr &amp;expr, csl::IndexStructure const &amp;from, csl::IndexStructure const &amp;to, bool refresh=true)</argsstring>
        <name>Replace</name>
        <qualifiedname>csl::Replace</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1IndexStructure" kindref="compound">csl::IndexStructure</ref> const &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1IndexStructure" kindref="compound">csl::IndexStructure</ref> const &amp;</type>
          <declname>to</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>refresh</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.h" line="121" column="13" bodyfile="src/csl/replace.h" bodystart="121" bodyend="127"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1abc696cee24297cc1ca72e9ce5cfae806" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>auto</type>
        <definition>auto csl::ruleToPredicate</definition>
        <argsstring>(replacementRule const &amp;rule)</argsstring>
        <name>ruleToPredicate</name>
        <qualifiedname>csl::ruleToPredicate</qualifiedname>
        <param>
          <type><ref refid="namespacecsl_1a236c3928ac0b1760b8738490dcf82706" kindref="member">replacementRule</ref> const &amp;</type>
          <declname>rule</declname>
        </param>
        <briefdescription>
<para>Converts a replacementRule into a predicate. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rule</parametername>
</parameternamelist>
<parameterdescription>
<para>The replacement rule to convert.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A lambda expression that calls the rule with a the &quot;predicate&quot; specification (meaning that the rule should not calculate the result of the replacement) and simply returns the boolean value of the returned optional. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.h" line="155" column="13" bodyfile="src/csl/replace.h" bodystart="155" bodyend="160"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a42c3c8469afcd37ca562ae8e845ff785" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ParentType</type>
          </param>
          <param>
            <type>typename</type>
            <defval>std::enable_if_t&lt;std::is_convertible_v&lt;ParentType, Parent&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void csl::Replace</definition>
        <argsstring>(Expr &amp;expr, std::vector&lt; ParentType &gt; const &amp;t_from, std::vector&lt; ParentType &gt; const &amp;t_to)</argsstring>
        <name>Replace</name>
        <qualifiedname>csl::Replace</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::vector&lt; ParentType &gt; const &amp;</type>
          <declname>t_from</declname>
        </param>
        <param>
          <type>std::vector&lt; ParentType &gt; const &amp;</type>
          <declname>t_to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.h" line="243" column="13" bodyfile="src/csl/replace.h" bodystart="243" bodyend="254"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1adc22b5410622d6421c615680536a9b68" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ParentType</type>
          </param>
          <param>
            <type>typename</type>
            <defval>std::enable_if_t&lt;std::is_convertible_v&lt;ParentType, Parent&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void csl::Replace</definition>
        <argsstring>(Expr &amp;expr, std::vector&lt; ParentType &gt; const &amp;t_from, std::vector&lt; csl::Expr &gt; const &amp;to)</argsstring>
        <name>Replace</name>
        <qualifiedname>csl::Replace</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::vector&lt; ParentType &gt; const &amp;</type>
          <declname>t_from</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">csl::Expr</ref> &gt; const &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.h" line="259" column="13" bodyfile="src/csl/replace.h" bodystart="259" bodyend="267"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1accd0f3b8e22ed56859494f753a42ffcf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Tried</definition>
        <argsstring>(const Expr &amp;expr, Args &amp;&amp;... args)</argsstring>
        <name>Tried</name>
        <qualifiedname>csl::Tried</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.h" line="276" column="6" bodyfile="src/csl/replace.h" bodystart="276" bodyend="280"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a778d540897812c073ae8eb33b0b720d9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void csl::Try</definition>
        <argsstring>(Expr &amp;expr, Args &amp;&amp;... args)</argsstring>
        <name>Try</name>
        <qualifiedname>csl::Try</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/replace.h" line="283" column="6" bodyfile="src/csl/replace.h" bodystart="283" bodyend="288"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a845ad72b9ce7fddf4d15dc6659418e81" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::convertScalarFuncType</definition>
        <argsstring>(const Abstract *expr, csl::Type &amp;type)</argsstring>
        <name>convertScalarFuncType</name>
        <qualifiedname>csl::convertScalarFuncType</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="namespacecsl_1ace591865c69b6315c533a1a325777312" kindref="member">csl::Type</ref> &amp;</type>
          <declname>type</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.cpp" line="35" column="13" bodyfile="src/csl/simplification.cpp" bodystart="35" bodyend="41"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a537de3243badcf319cf8c83b27890922" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::valueRule</definition>
        <argsstring>(const Abstract *A, const Abstract *B)</argsstring>
        <name>valueRule</name>
        <qualifiedname>csl::valueRule</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.cpp" line="43" column="13" bodyfile="src/csl/simplification.cpp" bodystart="43" bodyend="52"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a103202b75e3fdf16c3f4b7640091f00a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::complexRule</definition>
        <argsstring>(const Abstract *A, const Abstract *B)</argsstring>
        <name>complexRule</name>
        <qualifiedname>csl::complexRule</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.cpp" line="54" column="13" bodyfile="src/csl/simplification.cpp" bodystart="54" bodyend="66"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a955431f8f58a8869edbd7689a24992fe" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::evalRule</definition>
        <argsstring>(const Abstract *A, const Abstract *B)</argsstring>
        <name>evalRule</name>
        <qualifiedname>csl::evalRule</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.cpp" line="68" column="13" bodyfile="src/csl/simplification.cpp" bodystart="68" bodyend="87"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1afb30817e3d34173ae901c071c40f7cc5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::alphaRule</definition>
        <argsstring>(const Abstract *A, const Abstract *B)</argsstring>
        <name>alphaRule</name>
        <qualifiedname>csl::alphaRule</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.cpp" line="89" column="13" bodyfile="src/csl/simplification.cpp" bodystart="89" bodyend="98"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ab29d7c0bfbd2ff23a52478134913e4a0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::mathRule</definition>
        <argsstring>(const Abstract *A, const Abstract *B)</argsstring>
        <name>mathRule</name>
        <qualifiedname>csl::mathRule</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.cpp" line="100" column="13" bodyfile="src/csl/simplification.cpp" bodystart="100" bodyend="110"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2cb3cfd258f5c03e6dce5fc850ebf623" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::sumRule</definition>
        <argsstring>(const Abstract *A, const Abstract *sum)</argsstring>
        <name>sumRule</name>
        <qualifiedname>csl::sumRule</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>sum</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.cpp" line="112" column="13" bodyfile="src/csl/simplification.cpp" bodystart="112" bodyend="125"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a14793e965c9146ec7256ad3119b71cd7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::prodRule</definition>
        <argsstring>(const Abstract *A, const Abstract *prod)</argsstring>
        <name>prodRule</name>
        <qualifiedname>csl::prodRule</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>prod</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.cpp" line="127" column="13" bodyfile="src/csl/simplification.cpp" bodystart="127" bodyend="133"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa86629b5bad9861ab06ca37dae7e7cd2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::powRule</definition>
        <argsstring>(const Abstract *A, const Abstract *pow)</argsstring>
        <name>powRule</name>
        <qualifiedname>csl::powRule</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>pow</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.cpp" line="135" column="13" bodyfile="src/csl/simplification.cpp" bodystart="135" bodyend="138"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2d4cc44046b5181858ea2e92eb8cf446" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::sumRule_inverted</definition>
        <argsstring>(const Abstract *A, const Abstract *sum)</argsstring>
        <name>sumRule_inverted</name>
        <qualifiedname>csl::sumRule_inverted</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>sum</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.cpp" line="140" column="13" bodyfile="src/csl/simplification.cpp" bodystart="140" bodyend="155"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1abfe85a4826b1fb56529b277cd8b931d6" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::prodRule_inverted</definition>
        <argsstring>(const Abstract *A, const Abstract *prod)</argsstring>
        <name>prodRule_inverted</name>
        <qualifiedname>csl::prodRule_inverted</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>prod</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.cpp" line="157" column="13" bodyfile="src/csl/simplification.cpp" bodystart="157" bodyend="167"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af18f3c226c51974e35e1c18a0e032efd" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::powRule_inverted</definition>
        <argsstring>(const Abstract *A, const Abstract *pow)</argsstring>
        <name>powRule_inverted</name>
        <qualifiedname>csl::powRule_inverted</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>pow</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.cpp" line="169" column="13" bodyfile="src/csl/simplification.cpp" bodystart="169" bodyend="173"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a3e4d21c7f99966a80d224d6e7d072ef3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::vectorialRule</definition>
        <argsstring>(const Abstract *A, const Abstract *B)</argsstring>
        <name>vectorialRule</name>
        <qualifiedname>csl::vectorialRule</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.cpp" line="175" column="13" bodyfile="src/csl/simplification.cpp" bodystart="175" bodyend="190"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a61b9f49ded09ad07397c62d9a0f596a9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::ruleO1</definition>
        <argsstring>(const Abstract *A, const Abstract *B)</argsstring>
        <name>ruleO1</name>
        <qualifiedname>csl::ruleO1</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.cpp" line="192" column="13" bodyfile="src/csl/simplification.cpp" bodystart="192" bodyend="217"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ab6eff0894197faa1b49f66ea0517eb37" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::compareDuoArgs</definition>
        <argsstring>(const Expr &amp;argA0, const Expr &amp;argA1, const Expr &amp;argB0, const Expr &amp;argB1)</argsstring>
        <name>compareDuoArgs</name>
        <qualifiedname>csl::compareDuoArgs</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>argA0</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>argA1</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>argB0</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>argB1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.cpp" line="219" column="13" bodyfile="src/csl/simplification.cpp" bodystart="219" bodyend="230"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae3ec9cb647e506d83a37324aef7b02b9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::ruleO2</definition>
        <argsstring>(const Abstract *A, const Abstract *B)</argsstring>
        <name>ruleO2</name>
        <qualifiedname>csl::ruleO2</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.cpp" line="232" column="13" bodyfile="src/csl/simplification.cpp" bodystart="232" bodyend="240"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a07ef7b818be86a845c20c3c425986a61" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::ruleO2_inverted</definition>
        <argsstring>(const Abstract *A, const Abstract *B)</argsstring>
        <name>ruleO2_inverted</name>
        <qualifiedname>csl::ruleO2_inverted</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.cpp" line="242" column="13" bodyfile="src/csl/simplification.cpp" bodystart="242" bodyend="250"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2390b7f1d05f39b37dce21136b749690" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::ruleO3</definition>
        <argsstring>(const Abstract *A, const Abstract *B)</argsstring>
        <name>ruleO3</name>
        <qualifiedname>csl::ruleO3</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.cpp" line="252" column="13" bodyfile="src/csl/simplification.cpp" bodystart="252" bodyend="260"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aed70767d6c87ca58b67bdad46826c711" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::ruleO4</definition>
        <argsstring>(const Abstract *A, const Abstract *B)</argsstring>
        <name>ruleO4</name>
        <qualifiedname>csl::ruleO4</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.cpp" line="262" column="13" bodyfile="src/csl/simplification.cpp" bodystart="262" bodyend="274"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a319cb7fc01ce74daf6b31504e11582cd" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::ruleO5</definition>
        <argsstring>(const Abstract *A, const Abstract *B)</argsstring>
        <name>ruleO5</name>
        <qualifiedname>csl::ruleO5</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.cpp" line="276" column="13" bodyfile="src/csl/simplification.cpp" bodystart="276" bodyend="285"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a7adbeb8dd0fc23b6fb97fca690307385" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::ruleO6</definition>
        <argsstring>(const Abstract *A, const Abstract *B)</argsstring>
        <name>ruleO6</name>
        <qualifiedname>csl::ruleO6</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.cpp" line="287" column="13" bodyfile="src/csl/simplification.cpp" bodystart="287" bodyend="306"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a0631181c111a6baa9f3d12333cf98f54" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::ruleO7</definition>
        <argsstring>(const Abstract *A, const Abstract *B)</argsstring>
        <name>ruleO7</name>
        <qualifiedname>csl::ruleO7</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>B</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.cpp" line="308" column="13" bodyfile="src/csl/simplification.cpp" bodystart="308" bodyend="321"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aab212e3a250819d11a12e4ad019a3b7e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::printVector</definition>
        <argsstring>(const csl::vector_expr &amp;vector)</argsstring>
        <name>printVector</name>
        <qualifiedname>csl::printVector</qualifiedname>
        <param>
          <type>const csl::vector_expr &amp;</type>
          <declname>vector</declname>
        </param>
        <briefdescription>
<para>Display a vector of expressions. Useful in debug. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vector</parametername>
</parameternamelist>
<parameterdescription>
<para>std::vector of expressions to display. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.h" line="63" column="6" declfile="src/csl/simplification.h" declline="63" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae89467d6317ff64a05858dca96a08479" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::addAlternateForm</definition>
        <argsstring>(csl::vector_expr &amp;alternateForms, const Expr &amp;newAlternate, bool add_factor_expand=true)</argsstring>
        <name>addAlternateForm</name>
        <qualifiedname>csl::addAlternateForm</qualifiedname>
        <param>
          <type>csl::vector_expr &amp;</type>
          <declname>alternateForms</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>newAlternate</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>add_factor_expand</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Tried to add <bold>newAlternate</bold> in the set <bold>alternateForms</bold>. We simply test if the alternate is already present in the set <bold>newAlternate</bold> and add it if it is not the case. If <bold>add_factor_expand</bold> is set to <bold>true</bold>, we try to add the expanded and the factored forms of <bold>newAlternate</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>alternateForms</parametername>
</parameternamelist>
<parameterdescription>
<para>std::vector of expressions in which we add <bold>newAlternate</bold>.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>newAlternate</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to add.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>add_factor_expand</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean determining if we want to add also the factored and expanded versions of <bold>newAlternate</bold>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.h" line="77" column="6" declfile="src/csl/simplification.h" declline="77" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a045a1acfa56caebfe583aea20e4222ea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::reduceAlternate</definition>
        <argsstring>(csl::vector_expr &amp;alternateForms)</argsstring>
        <name>reduceAlternate</name>
        <qualifiedname>csl::reduceAlternate</qualifiedname>
        <param>
          <type>csl::vector_expr &amp;</type>
          <declname>alternateForms</declname>
        </param>
        <briefdescription>
<para>Reduces the number of elements in <bold>alternateForms</bold> to MAX_ALTERNATE_FORMS. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>alternateForms</parametername>
</parameternamelist>
<parameterdescription>
<para>std::vector of expressions to reduce. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.h" line="86" column="6" declfile="src/csl/simplification.h" declline="86" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae84f9c884b931374b8cd46405ed164bf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::clearRedundancyAlternate</definition>
        <argsstring>(csl::vector_expr &amp;alternateForms)</argsstring>
        <name>clearRedundancyAlternate</name>
        <qualifiedname>csl::clearRedundancyAlternate</qualifiedname>
        <param>
          <type>csl::vector_expr &amp;</type>
          <declname>alternateForms</declname>
        </param>
        <briefdescription>
<para>Search and remove redundancies (equal alternate forms) in <bold>alternateForms</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>alternateForms</parametername>
</parameternamelist>
<parameterdescription>
<para>std::vector of expressions to reduce. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.h" line="92" column="6" declfile="src/csl/simplification.h" declline="92" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a46d59a363192eb0486d9c16523f18fe4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>csl::vector_expr</type>
        <definition>csl::vector_expr csl::getRecursiveAlternateForms</definition>
        <argsstring>(const Expr &amp;expr, int depth=-1)</argsstring>
        <name>getRecursiveAlternateForms</name>
        <qualifiedname>csl::getRecursiveAlternateForms</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Returns the alternate forms of <bold>expr</bold> by applying recursively internalRecursiveAlternateForms() MAX_RECURSION_ALTERNATE times: take alternates, then alternates of the alternates etc. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression from which we search alternates. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>depth</parametername>
</parameternamelist>
<parameterdescription>
<para>Recursion depth transmitted to internalRecursiveAlternateForms(). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a std::vector of expressions containing alternates of <bold>expr</bold>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.h" line="103" column="18" declfile="src/csl/simplification.h" declline="103" declcolumn="18"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ad27c8d3dd60c235e3e804b97790110ab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Simplify</definition>
        <argsstring>(const Expr &amp;expr, int depth=-1)</argsstring>
        <name>Simplify</name>
        <qualifiedname>csl::Simplify</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para><bold>Simplifies</bold> <bold>expr</bold> depending on its type. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to reduce. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>depth</parametername>
</parameternamelist>
<parameterdescription>
<para>Depth of simplification. Default=1: <bold>max depth</bold>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The simplified expression. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.h" line="124" column="6" declfile="src/csl/simplification.h" declline="124" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a3c70f950e47354a4ec998afaa094c817" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int csl::numberOfMutatingNodes</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>numberOfMutatingNodes</name>
        <qualifiedname>csl::numberOfMutatingNodes</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.h" line="126" column="5" declfile="src/csl/simplification.h" declline="126" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af4336753df953d3d5c7e52694d914a9f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::insertSortMutant</definition>
        <argsstring>(csl::vector_expr &amp;vec, const Expr &amp;newExpr)</argsstring>
        <name>insertSortMutant</name>
        <qualifiedname>csl::insertSortMutant</qualifiedname>
        <param>
          <type>csl::vector_expr &amp;</type>
          <declname>vec</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>newExpr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.h" line="128" column="6" declfile="src/csl/simplification.h" declline="128" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a9a8f1cb2db822c5166d7bbfc7446c027" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::addMutants</definition>
        <argsstring>(csl::vector_expr &amp;individuals, const csl::vector_expr &amp;mutants)</argsstring>
        <name>addMutants</name>
        <qualifiedname>csl::addMutants</qualifiedname>
        <param>
          <type>csl::vector_expr &amp;</type>
          <declname>individuals</declname>
        </param>
        <param>
          <type>const csl::vector_expr &amp;</type>
          <declname>mutants</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.h" line="130" column="6" declfile="src/csl/simplification.h" declline="130" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a3253879ee0318d8744a16949355ad113" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>csl::vector_expr</type>
        <definition>csl::vector_expr csl::getRandomMutation</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>getRandomMutation</name>
        <qualifiedname>csl::getRandomMutation</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.h" line="133" column="18" declfile="src/csl/simplification.h" declline="133" declcolumn="18"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2f20ab0890fcbec5af0497c71407bb32" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::naturalSelection</definition>
        <argsstring>(csl::vector_expr &amp;individuals)</argsstring>
        <name>naturalSelection</name>
        <qualifiedname>csl::naturalSelection</qualifiedname>
        <param>
          <type>csl::vector_expr &amp;</type>
          <declname>individuals</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.h" line="135" column="6" declfile="src/csl/simplification.h" declline="135" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ada67d3f7198eeae4549c3fd938721343" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::evolve</definition>
        <argsstring>(const Expr &amp;baseIndividual)</argsstring>
        <name>evolve</name>
        <qualifiedname>csl::evolve</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>baseIndividual</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/simplification.h" line="137" column="6" declfile="src/csl/simplification.h" declline="137" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae67aef8589845a645064fb527a7ef27b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::selectionSort</definition>
        <argsstring>(iterator first, iterator last)</argsstring>
        <name>selectionSort</name>
        <qualifiedname>csl::selectionSort</qualifiedname>
        <param>
          <type>iterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>iterator</type>
          <declname>last</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/sort.cpp" line="22" column="6" bodyfile="src/csl/sort.cpp" bodystart="22" bodyend="36"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1adcde11ad745cfee42e9efa83d145031a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::selectionSort</definition>
        <argsstring>(std::vector&lt; Expr &gt; &amp;argument)</argsstring>
        <name>selectionSort</name>
        <qualifiedname>csl::selectionSort</qualifiedname>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; &amp;</type>
          <declname>argument</declname>
        </param>
        <briefdescription>
<para>Applies the selection sort algorithm <formula id="39">$ \mathcal{O}(N^2) $</formula> on a container. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>argument</parametername>
</parameternamelist>
<parameterdescription>
<para>Container to sort. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/sort.cpp" line="37" column="6" bodyfile="src/csl/sort.cpp" bodystart="37" bodyend="40" declfile="src/csl/sort.h" declline="68" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a564414111f8015fa162787af0da95019" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void csl::insert</definition>
        <argsstring>(iterator a1_first, iterator a1_last, iterator a2_first, iterator a2_last, iterator b_first)</argsstring>
        <name>insert</name>
        <qualifiedname>csl::insert</qualifiedname>
        <param>
          <type>iterator</type>
          <declname>a1_first</declname>
        </param>
        <param>
          <type>iterator</type>
          <declname>a1_last</declname>
        </param>
        <param>
          <type>iterator</type>
          <declname>a2_first</declname>
        </param>
        <param>
          <type>iterator</type>
          <declname>a2_last</declname>
        </param>
        <param>
          <type>iterator</type>
          <declname>b_first</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/sort.cpp" line="42" column="13" bodyfile="src/csl/sort.cpp" bodystart="42" bodyend="62"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a4b5017162c0a32dbc3584f521b1f1177" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void csl::mergeSort</definition>
        <argsstring>(iterator a_first, iterator a_last, iterator b_first, iterator b_last)</argsstring>
        <name>mergeSort</name>
        <qualifiedname>csl::mergeSort</qualifiedname>
        <param>
          <type>iterator</type>
          <declname>a_first</declname>
        </param>
        <param>
          <type>iterator</type>
          <declname>a_last</declname>
        </param>
        <param>
          <type>iterator</type>
          <declname>b_first</declname>
        </param>
        <param>
          <type>iterator</type>
          <declname>b_last</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/sort.cpp" line="65" column="1" bodyfile="src/csl/sort.cpp" bodystart="65" bodyend="78"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a30af37876f8c6102a9a0ffcb83c78f13" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::sort</definition>
        <argsstring>(std::vector&lt; Expr &gt; &amp;argument)</argsstring>
        <name>sort</name>
        <qualifiedname>csl::sort</qualifiedname>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; &amp;</type>
          <declname>argument</declname>
        </param>
        <briefdescription>
<para>Sorts a container using mergeSort(). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>argument</parametername>
</parameternamelist>
<parameterdescription>
<para>Container to sort. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/sort.cpp" line="80" column="6" bodyfile="src/csl/sort.cpp" bodystart="80" bodyend="83" declfile="src/csl/sort.h" declline="53" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1abab59f41cbf13cde6cb88928db331af6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::sort</definition>
        <argsstring>(iterator first, iterator last)</argsstring>
        <name>sort</name>
        <qualifiedname>csl::sort</qualifiedname>
        <param>
          <type>iterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>iterator</type>
          <declname>last</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/sort.cpp" line="85" column="6" bodyfile="src/csl/sort.cpp" bodystart="85" bodyend="91"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a1c48c85e78f6b663a82bd7e100ad68d0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::mergeSort</definition>
        <argsstring>(std::vector&lt; Expr &gt; &amp;argument)</argsstring>
        <name>mergeSort</name>
        <qualifiedname>csl::mergeSort</qualifiedname>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; &amp;</type>
          <declname>argument</declname>
        </param>
        <briefdescription>
<para>Applies the merge sort algorithm <formula id="40">$ \mathcal{O}(N\log N) $</formula> on a container. </para>
        </briefdescription>
        <detaileddescription>
<para>This function is recursive, calling a merge sort on parts of the container. Once the size of these parts are bellow <ref refid="namespacecsl_1ab3885c426f3cbbc274fe4ce33aae739b" kindref="member">minMergeSize</ref>, selectionSort() is called instead. For <ref refid="classstd_1_1shared__ptr" kindref="compound">std::shared_ptr</ref> (the case for the <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> type) the optimal size is around 10. This means that with less than 10 elements, selectionSort() is still faster that mergeSort(). Above, the <formula id="40">$ \mathcal{O}(N\log N) $</formula> complexity of mergeSort() is of course better and better with large <formula id="41">$ N $</formula>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>argument</parametername>
</parameternamelist>
<parameterdescription>
<para>Container to sort. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/sort.cpp" line="93" column="6" bodyfile="src/csl/sort.cpp" bodystart="93" bodyend="96" declfile="src/csl/sort.h" declline="93" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ab1a22c3d3c9ec01a082d2e01e5cdd75e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::mergeSort</definition>
        <argsstring>(iterator first, iterator last)</argsstring>
        <name>mergeSort</name>
        <qualifiedname>csl::mergeSort</qualifiedname>
        <param>
          <type>iterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>iterator</type>
          <declname>last</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/sort.cpp" line="98" column="6" bodyfile="src/csl/sort.cpp" bodystart="98" bodyend="101"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a038131f4648d3a85d7f66956b9a052f9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::sort</definition>
        <argsstring>(std::vector&lt; Expr &gt;::iterator first, std::vector&lt; Expr &gt;::iterator last)</argsstring>
        <name>sort</name>
        <qualifiedname>csl::sort</qualifiedname>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;::iterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;::iterator</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>Sorts a container using mergeSort(). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator pointing to the first element (.begin()). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator pointing to the last element (.end()). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/sort.h" line="60" column="6" declfile="src/csl/sort.h" declline="60" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aaa60374eb375314f6f7c661a35c01e67" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::selectionSort</definition>
        <argsstring>(std::vector&lt; Expr &gt;::iterator first, std::vector&lt; Expr &gt;::iterator last)</argsstring>
        <name>selectionSort</name>
        <qualifiedname>csl::selectionSort</qualifiedname>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;::iterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;::iterator</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>Applies the selection sort algorithm <formula id="39">$ \mathcal{O}(N^2) $</formula> on a container. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator pointing to the first element (.begin()). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator pointing to the last element (.end()). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/sort.h" line="76" column="6" declfile="src/csl/sort.h" declline="76" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af4d5f0bc5267d581906fe5a40f3dcce1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::mergeSort</definition>
        <argsstring>(std::vector&lt; Expr &gt;::iterator first, std::vector&lt; Expr &gt;::iterator last)</argsstring>
        <name>mergeSort</name>
        <qualifiedname>csl::mergeSort</qualifiedname>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;::iterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;::iterator</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>Applies the merge sort algorithm <formula id="40">$ \mathcal{O}(N\log N) $</formula> on a container. </para>
        </briefdescription>
        <detaileddescription>
<para>This function is recursive, calling a merge sort on parts of the container. Once the size of these parts are bellow <ref refid="namespacecsl_1ab3885c426f3cbbc274fe4ce33aae739b" kindref="member">minMergeSize</ref>, selectionSort() is called instead. For <ref refid="classstd_1_1shared__ptr" kindref="compound">std::shared_ptr</ref> (the case for the <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> type) the optimal size is around 10. This means that with less than 10 elements, selectionSort() is still faster that mergeSort(). Above, the <formula id="40">$ \mathcal{O}(N\log N) $</formula> complexity of mergeSort() is of course better and better with large <formula id="41">$ N $</formula>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator pointing to the first element (.begin()). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator pointing to the last element (.end()). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/sort.h" line="109" column="6" declfile="src/csl/sort.h" declline="109" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ab6abd3ab4cdc44a414beaee90e01e5a6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::fillEpsilonTensor</definition>
        <argsstring>(Expr &amp;tensor, int dim)</argsstring>
        <name>fillEpsilonTensor</name>
        <qualifiedname>csl::fillEpsilonTensor</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>tensor</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dim</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/space.cpp" line="322" column="6" bodyfile="src/csl/space.cpp" bodystart="322" bodyend="335" declfile="src/csl/space.h" declline="425" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a77623bc149b2f895dbdab3607cfc8025" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename G</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::pair&lt; T, G &gt; &gt;::iterator</type>
        <definition>std::vector&lt; std::pair&lt; T, G &gt; &gt;::iterator csl::findFirstInPair</definition>
        <argsstring>(std::vector&lt; std::pair&lt; T, G &gt; &gt; &amp;v, const T &amp;element)</argsstring>
        <name>findFirstInPair</name>
        <qualifiedname>csl::findFirstInPair</qualifiedname>
        <param>
          <type>std::vector&lt; std::pair&lt; T, G &gt; &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>element</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/space.h" line="35" column="1" bodyfile="src/csl/space.h" bodystart="35" bodyend="42"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1acd13ae2d4b7146577dfa4994660d9fba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename G</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::pair&lt; T, G &gt; &gt;::iterator</type>
        <definition>std::vector&lt; std::pair&lt; T, G &gt; &gt;::iterator csl::findSecondInPair</definition>
        <argsstring>(std::vector&lt; std::pair&lt; T, G &gt; &gt; &amp;v, const G &amp;element)</argsstring>
        <name>findSecondInPair</name>
        <qualifiedname>csl::findSecondInPair</qualifiedname>
        <param>
          <type>std::vector&lt; std::pair&lt; T, G &gt; &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type>const G &amp;</type>
          <declname>element</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/space.h" line="46" column="1" bodyfile="src/csl/space.h" bodystart="46" bodyend="53"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a28b314d75af186fa098e21d9e93cd261" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> &amp;</type>
        <definition>const Space &amp; csl::buildMinkowski</definition>
        <argsstring>()</argsstring>
        <name>buildMinkowski</name>
        <qualifiedname>csl::buildMinkowski</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/space.h" line="406" column="20" bodyfile="src/csl/space.h" bodystart="406" bodyend="420"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1adc609bb5307e2707f433fd90847da159" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref></type>
        <definition>const Space csl::Euclid_R2</definition>
        <argsstring>(&quot;R2&quot;, 2)</argsstring>
        <name>Euclid_R2</name>
        <qualifiedname>csl::Euclid_R2</qualifiedname>
        <param>
          <type>&quot;R2&quot;</type>
        </param>
        <param>
          <type>2</type>
        </param>
        <briefdescription>
<para><ref refid="classcsl_1_1Space" kindref="compound">Space</ref> <formula id="42">$ R^2 $</formula>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/space.h" line="430" column="20" declfile="src/csl/space.h" declline="430" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae2032bf9b522dae416eb0c7f66642e89" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref></type>
        <definition>const Space csl::Euclid_R3</definition>
        <argsstring>(&quot;R3&quot;, 3)</argsstring>
        <name>Euclid_R3</name>
        <qualifiedname>csl::Euclid_R3</qualifiedname>
        <param>
          <type>&quot;R3&quot;</type>
        </param>
        <param>
          <type>3</type>
        </param>
        <briefdescription>
<para><ref refid="classcsl_1_1Space" kindref="compound">Space</ref> <formula id="43">$ R^3 $</formula>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/space.h" line="435" column="20" declfile="src/csl/space.h" declline="435" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a8d1d8eb1cfa212c44e0ef199e78db957" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref></type>
        <definition>const Space csl::Euclid_R4</definition>
        <argsstring>(&quot;R4&quot;, 4)</argsstring>
        <name>Euclid_R4</name>
        <qualifiedname>csl::Euclid_R4</qualifiedname>
        <param>
          <type>&quot;R4&quot;</type>
        </param>
        <param>
          <type>4</type>
        </param>
        <briefdescription>
<para><ref refid="classcsl_1_1Space" kindref="compound">Space</ref> <formula id="44">$ R^4 $</formula>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/space.h" line="440" column="20" declfile="src/csl/space.h" declline="440" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a8c9bbef2158b7cb97a7d45e8739e01d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int csl::PGCD</definition>
        <argsstring>(double a, double b)</argsstring>
        <name>PGCD</name>
        <qualifiedname>csl::PGCD</qualifiedname>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <param>
          <type>double</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Returns the PGCD of a and b. </para>
        </briefdescription>
        <detaileddescription>
<para>If <emphasis>a</emphasis> and <emphasis>b</emphasis> are integers ( <emphasis>a</emphasis> == floor(<emphasis>a</emphasis>) and also for <emphasis>b</emphasis>) this function calls PGCD(int a, int b).<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
</parameterdescription>
</parameteritem>
</parameterlist>
param b <simplesect kind="return"><para>PGCD(a,b) if <emphasis>a</emphasis> and <emphasis>b</emphasis> are integers. </para>
</simplesect>
<simplesect kind="return"><para><bold>1</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/support.cpp" line="23" column="5" bodyfile="src/csl/support.cpp" bodystart="23" bodyend="26" declfile="src/csl/support.h" declline="50" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a6f23566569705a22bd8d9dcb8b46642a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int csl::PGCD</definition>
        <argsstring>(int a, int b)</argsstring>
        <name>PGCD</name>
        <qualifiedname>csl::PGCD</qualifiedname>
        <param>
          <type>int</type>
          <declname>a</declname>
        </param>
        <param>
          <type>int</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/support.cpp" line="28" column="5" bodyfile="src/csl/support.cpp" bodystart="28" bodyend="31" declfile="src/csl/support.h" declline="60" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a293f777248d9b27ff737fef8d51bb544" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>long long int</type>
        <definition>long long int csl::PGCD</definition>
        <argsstring>(long long int a, long long int b)</argsstring>
        <name>PGCD</name>
        <qualifiedname>csl::PGCD</qualifiedname>
        <param>
          <type>long long int</type>
          <declname>a</declname>
        </param>
        <param>
          <type>long long int</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Returns the PGCD of a and b. </para>
        </briefdescription>
        <detaileddescription>
<para>Proceeds to verifications on <emphasis>a</emphasis> and <emphasis>b</emphasis> (sign, non zero, etc) and calls internal_PGCD(int a, int b) if everythiong is Ok.<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
</parameterdescription>
</parameteritem>
</parameterlist>
param b <simplesect kind="return"><para>PGCD(a,b) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/support.cpp" line="33" column="15" bodyfile="src/csl/support.cpp" bodystart="33" bodyend="48" declfile="src/csl/support.h" declline="58" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a62ae14b0bc1a6b3f7e9138421b2b8360" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>long long int</type>
        <definition>long long int csl::sgn</definition>
        <argsstring>(long long int a)</argsstring>
        <name>sgn</name>
        <qualifiedname>csl::sgn</qualifiedname>
        <param>
          <type>long long int</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns the sign of a. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>sign(a) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/support.cpp" line="60" column="15" bodyfile="src/csl/support.cpp" bodystart="60" bodyend="63" declfile="src/csl/support.h" declline="81" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2d2da16ddbb46010b9d40d87308a834b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int csl::sgn</definition>
        <argsstring>(int a)</argsstring>
        <name>sgn</name>
        <qualifiedname>csl::sgn</qualifiedname>
        <param>
          <type>int</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/support.cpp" line="64" column="5" bodyfile="src/csl/support.cpp" bodystart="64" bodyend="67" declfile="src/csl/support.h" declline="83" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a36cdda72e72136f4b0afec1d865361c5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int csl::sgn</definition>
        <argsstring>(double a)</argsstring>
        <name>sgn</name>
        <qualifiedname>csl::sgn</qualifiedname>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Returns the sign of a. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>sign(a) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/support.cpp" line="68" column="5" bodyfile="src/csl/support.cpp" bodystart="68" bodyend="71" declfile="src/csl/support.h" declline="90" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a5bd20a50cf5cdfbe57e3b896b980179e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double csl::factorial</definition>
        <argsstring>(int n)</argsstring>
        <name>factorial</name>
        <qualifiedname>csl::factorial</qualifiedname>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>Returns the factorial of a. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>a!</bold> </para>
</simplesect>
<xrefsect id="bug_1_bug000003"><xreftitle>Bug</xreftitle><xrefdescription><para>The factorial function returns a double for now and so is quickly out of bounds for exact numerical precision. The limit is between 20! and 25!. </para>
</xrefdescription></xrefsect></para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/support.cpp" line="73" column="8" bodyfile="src/csl/support.cpp" bodystart="73" bodyend="82" declfile="src/csl/support.h" declline="100" declcolumn="8"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ab30e74a9d2862583f2b165768309fc85" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int csl::compare</definition>
        <argsstring>(string_view a, string_view b)</argsstring>
        <name>compare</name>
        <qualifiedname>csl::compare</qualifiedname>
        <param>
          <type>string_view</type>
          <declname>a</declname>
        </param>
        <param>
          <type>string_view</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/support.cpp" line="91" column="5" bodyfile="src/csl/support.cpp" bodystart="91" bodyend="113"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a4ecdcdbc474dfbd6b1e62bdc54b6c22a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::operator&gt;</definition>
        <argsstring>(const string &amp;a, const string &amp;b)</argsstring>
        <name>operator&gt;</name>
        <qualifiedname>csl::operator&gt;</qualifiedname>
        <param>
          <type>const string &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const string &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/support.cpp" line="115" column="6" bodyfile="src/csl/support.cpp" bodystart="115" bodyend="118"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a146702a236fc5f684b8f02e2870f64e3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::operator&lt;</definition>
        <argsstring>(const string &amp;a, const string &amp;b)</argsstring>
        <name>operator&lt;</name>
        <qualifiedname>csl::operator&lt;</qualifiedname>
        <param>
          <type>const string &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const string &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/support.cpp" line="120" column="1" bodyfile="src/csl/support.cpp" bodystart="120" bodyend="123"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a84d36e4ea4e90adc4dc7a9241ef6ff60" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::operator&gt;=</definition>
        <argsstring>(const string &amp;a, const string &amp;b)</argsstring>
        <name>operator&gt;=</name>
        <qualifiedname>csl::operator&gt;=</qualifiedname>
        <param>
          <type>const string &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const string &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/support.cpp" line="125" column="6" bodyfile="src/csl/support.cpp" bodystart="125" bodyend="128"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1afb13be470dde2d01c86b286f634408b4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::operator&lt;=</definition>
        <argsstring>(const string &amp;a, const string &amp;b)</argsstring>
        <name>operator&lt;=</name>
        <qualifiedname>csl::operator&lt;=</qualifiedname>
        <param>
          <type>const string &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const string &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/support.cpp" line="130" column="1" bodyfile="src/csl/support.cpp" bodystart="130" bodyend="133"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ab7d540f69d4272bfe86773a5a9d44b64" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>vector&lt; size_t &gt;</type>
        <definition>std::vector&lt; size_t &gt; csl::range</definition>
        <argsstring>(size_t n)</argsstring>
        <name>range</name>
        <qualifiedname>csl::range</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/support.cpp" line="135" column="8" bodyfile="src/csl/support.cpp" bodystart="135" bodyend="138" declfile="src/csl/support.h" declline="119" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a245d0cc018193c83be276cc8bbe80be0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>vector&lt; size_t &gt;</type>
        <definition>std::vector&lt; size_t &gt; csl::range</definition>
        <argsstring>(size_t i, size_t n)</argsstring>
        <name>range</name>
        <qualifiedname>csl::range</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>i</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/support.cpp" line="140" column="8" bodyfile="src/csl/support.cpp" bodystart="140" bodyend="143" declfile="src/csl/support.h" declline="121" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1adfb285513638fa75831e846b50d504b5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>vector&lt; size_t &gt;</type>
        <definition>std::vector&lt; size_t &gt; csl::range</definition>
        <argsstring>(size_t i, size_t n, size_t step)</argsstring>
        <name>range</name>
        <qualifiedname>csl::range</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>i</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>n</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>step</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/support.cpp" line="145" column="8" bodyfile="src/csl/support.cpp" bodystart="145" bodyend="154" declfile="src/csl/support.h" declline="123" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ada7aff37dd08901e65dde87ba433b78f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int csl::compare</definition>
        <argsstring>(std::string_view a, std::string_view b)</argsstring>
        <name>compare</name>
        <qualifiedname>csl::compare</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>a</declname>
        </param>
        <param>
          <type>std::string_view</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/support.h" line="109" column="5" declfile="src/csl/support.h" declline="109" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a77369a9f7c5fb4ded000b726bd8029d3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::operator&gt;</definition>
        <argsstring>(const std::string &amp;a, const std::string &amp;b)</argsstring>
        <name>operator&gt;</name>
        <qualifiedname>csl::operator&gt;</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/support.h" line="111" column="6" declfile="src/csl/support.h" declline="111" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1afbb6e8d6680cfdef7171a59ef2410452" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::operator&lt;</definition>
        <argsstring>(const std::string &amp;a, const std::string &amp;b)</argsstring>
        <name>operator&lt;</name>
        <qualifiedname>csl::operator&lt;</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/support.h" line="113" column="1" declfile="src/csl/support.h" declline="113" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a6ba402137e9956fe44de388ced3964bd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::operator&gt;=</definition>
        <argsstring>(const std::string &amp;a, const std::string &amp;b)</argsstring>
        <name>operator&gt;=</name>
        <qualifiedname>csl::operator&gt;=</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/support.h" line="115" column="6" declfile="src/csl/support.h" declline="115" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a5d0b767ed145d9ceb68ef355e35c714a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::operator&lt;=</definition>
        <argsstring>(const std::string &amp;a, const std::string &amp;b)</argsstring>
        <name>operator&lt;=</name>
        <qualifiedname>csl::operator&lt;=</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/support.h" line="117" column="1" declfile="src/csl/support.h" declline="117" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a31f687274fba7d8f4dc865a21a1901ac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool csl::comparePlaceIndependant</definition>
        <argsstring>(std::vector&lt; T &gt; A, std::vector&lt; T &gt; B)</argsstring>
        <name>comparePlaceIndependant</name>
        <qualifiedname>csl::comparePlaceIndependant</qualifiedname>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
<para>Template function that compares the elements in two vectors <bold>A</bold> and <bold>B</bold>, independently on their order. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of data, must have a well-defined operator==. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>Left hand side. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>Right hand side.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if all elements in <bold>A</bold> (no more no less) are present in \B, independently on their order. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/support.h" line="137" column="6" bodyfile="src/csl/support.h" bodystart="137" bodyend="161"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ad90b89dc5d8450e4ce9538431f80925b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool csl::partialComparePlaceIndependant</definition>
        <argsstring>(std::vector&lt; T &gt; A, std::vector&lt; T &gt; B)</argsstring>
        <name>partialComparePlaceIndependant</name>
        <qualifiedname>csl::partialComparePlaceIndependant</qualifiedname>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>B</declname>
        </param>
        <briefdescription>
<para>Template function that compares the elements in two vectors <bold>A</bold> and <bold>B</bold>, independently on their order, <bold>A</bold> can be bigger, this function determines if all elements in <bold>B</bold> are present in <bold>A</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of data, must have a well-defined operator==. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>Left hand side. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>Right hand side.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if all elements in <bold>B</bold> (and possibly more) are present in <bold>A</bold> independently on their order. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/support.h" line="176" column="6" bodyfile="src/csl/support.h" bodystart="176" bodyend="195"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a270d71fbe3af3d981d56ca77d31e32f5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; csl::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;fout, const Permutation &amp;permutation)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>csl::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>fout</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Permutation" kindref="compound">Permutation</ref> &amp;</type>
          <declname>permutation</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fout</parametername>
</parameternamelist>
<parameterdescription>
<para>Output flux. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>permutation</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Permutation" kindref="compound">Permutation</ref> to diplay.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A reference to the modified flux <bold>fout</bold>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/symmetry.cpp" line="220" column="1" bodyfile="src/csl/symmetry.cpp" bodystart="220" bodyend="227"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a52fb17326061ae01d08c4c9cde010938" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>vector&lt; vector&lt; int &gt; &gt;</type>
        <definition>vector&lt; vector&lt; int &gt; &gt; csl::permutations</definition>
        <argsstring>(vector&lt; int &gt; init)</argsstring>
        <name>permutations</name>
        <qualifiedname>csl::permutations</qualifiedname>
        <param>
          <type>std::vector&lt; int &gt;</type>
          <declname>init</declname>
        </param>
        <briefdescription>
<para>Gets all permutations (int the form of vectors of integers) of n elements, n beeing the size of <bold>init</bold>. The vector <bold>init</bold> must contain all integers between 0 and n-1. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Initial set of n integers.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>All the permutations of n elements in simple vectors of integers. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/symmetry.cpp" line="238" column="8" bodyfile="src/csl/symmetry.cpp" bodystart="238" bodyend="282"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a35c72686b5438eec934374e4d151e4fc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>vector&lt; <ref refid="classcsl_1_1Permutation" kindref="compound">Permutation</ref> &gt;</type>
        <definition>std::vector&lt; Permutation &gt; csl::permutations</definition>
        <argsstring>(const Permutation &amp;init)</argsstring>
        <name>permutations</name>
        <qualifiedname>csl::permutations</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Permutation" kindref="compound">Permutation</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <briefdescription>
<para>Gets all permutations (int the form of <ref refid="classcsl_1_1Permutation" kindref="compound">Permutation</ref> objects) of n elements, n beeing the size of <bold>init</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Initial <ref refid="classcsl_1_1Permutation" kindref="compound">Permutation</ref> of n elements, can be identity.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>All the permutations of n elements in <ref refid="classcsl_1_1Permutation" kindref="compound">Permutation</ref> objects. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/symmetry.cpp" line="284" column="8" bodyfile="src/csl/symmetry.cpp" bodystart="284" bodyend="295" declfile="src/csl/symmetry.h" declline="236" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ad292d5ba73b91dee12de72e4c96996b3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::reducePermutation</definition>
        <argsstring>(std::vector&lt; Permutation &gt; &amp;permutation)</argsstring>
        <name>reducePermutation</name>
        <qualifiedname>csl::reducePermutation</qualifiedname>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Permutation" kindref="compound">Permutation</ref> &gt; &amp;</type>
          <declname>permutation</declname>
        </param>
        <briefdescription>
<para>Takes a vector of <ref refid="classcsl_1_1Permutation" kindref="compound">Permutation</ref> objects and erase the redundant ones, i.e. the permutations present several times in the vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>permutation</parametername>
</parameternamelist>
<parameterdescription>
<para>std::vector of <ref refid="classcsl_1_1Permutation" kindref="compound">Permutation</ref> to reduce (modified during the call of the function). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/symmetry.cpp" line="298" column="6" bodyfile="src/csl/symmetry.cpp" bodystart="298" bodyend="306" declfile="src/csl/symmetry.h" declline="245" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a6fe98d1ad16fa3c08f8a35317438fcb1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcsl_1_1Permutation" kindref="compound">Permutation</ref> &gt;</type>
        <definition>std::vector&lt; Permutation &gt; csl::getSpan</definition>
        <argsstring>(const std::vector&lt; Permutation &gt; &amp;init)</argsstring>
        <name>getSpan</name>
        <qualifiedname>csl::getSpan</qualifiedname>
        <param>
          <type>const std::vector&lt; <ref refid="classcsl_1_1Permutation" kindref="compound">Permutation</ref> &gt; &amp;</type>
          <declname>init</declname>
        </param>
        <briefdescription>
<para>Calculates all permutations spanned by an ensemble of initial Permutations <bold>init</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Initial permutations in a std::vector of <ref refid="classcsl_1_1Permutation" kindref="compound">Permutation</ref>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>All permutations spanned by the initial vector <bold>Init</bold> in the form of a another vector of <ref refid="classcsl_1_1Permutation" kindref="compound">Permutation</ref> objects. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/symmetry.cpp" line="309" column="13" bodyfile="src/csl/symmetry.cpp" bodystart="309" bodyend="334" declfile="src/csl/symmetry.h" declline="256" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a67a9246a8bb37b33f7117f1e1eb571f9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::getSpan</definition>
        <argsstring>(std::vector&lt; Permutation &gt; &amp;spanned, const Permutation &amp;element)</argsstring>
        <name>getSpan</name>
        <qualifiedname>csl::getSpan</qualifiedname>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Permutation" kindref="compound">Permutation</ref> &gt; &amp;</type>
          <declname>spanned</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Permutation" kindref="compound">Permutation</ref> &amp;</type>
          <declname>element</declname>
        </param>
        <briefdescription>
<para>This function adds an element in an already complete set of permutations. It assumes that the std::vector <bold>spanned</bold> is already complete by itself and modifies it by adding all the permutations spanned by itself and the new permutation <bold>element</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>spanned</parametername>
</parameternamelist>
<parameterdescription>
<para>Initial set of <ref refid="classcsl_1_1Permutation" kindref="compound">Permutation</ref> objects, must be already complete. It is modified during the call of the function. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>element</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Permutation" kindref="compound">Permutation</ref> to add. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/symmetry.cpp" line="338" column="6" bodyfile="src/csl/symmetry.cpp" bodystart="338" bodyend="355" declfile="src/csl/symmetry.h" declline="268" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aed6bc22d8289737231eee276f19805ea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; csl::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;fout, const Symmetry &amp;symmetry)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>csl::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>fout</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Symmetry" kindref="compound">Symmetry</ref> &amp;</type>
          <declname>symmetry</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fout</parametername>
</parameternamelist>
<parameterdescription>
<para>Output flux. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>permutation</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Symmetry" kindref="compound">Symmetry</ref> to diplay.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A reference to the modified flux <bold>fout</bold>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/symmetry.cpp" line="526" column="1" bodyfile="src/csl/symmetry.cpp" bodystart="526" bodyend="540"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af15e916c12785aebdcfcd83fefeb8ae7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ostream &amp;</type>
        <definition>ostream &amp; csl::operator&lt;&lt;</definition>
        <argsstring>(ostream &amp;fout, const IndexedSymmetry &amp;sym)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>csl::operator&lt;&lt;</qualifiedname>
        <param>
          <type>ostream &amp;</type>
          <declname>fout</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1IndexedSymmetry" kindref="compound">IndexedSymmetry</ref> &amp;</type>
          <declname>sym</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/symmetry.cpp" line="705" column="1" bodyfile="src/csl/symmetry.cpp" bodystart="705" bodyend="716"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a73fe828b8f127c959a7d92e3cddee5f4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::vector&lt; int &gt; &gt;</type>
        <definition>std::vector&lt; std::vector&lt; int &gt; &gt; csl::permutations</definition>
        <argsstring>(std::vector&lt; int &gt; init)</argsstring>
        <name>permutations</name>
        <qualifiedname>csl::permutations</qualifiedname>
        <param>
          <type>std::vector&lt; int &gt;</type>
          <declname>init</declname>
        </param>
        <briefdescription>
<para>Gets all permutations (int the form of vectors of integers) of n elements, n beeing the size of <bold>init</bold>. The vector <bold>init</bold> must contain all integers between 0 and n-1. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>Initial set of n integers.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>All the permutations of n elements in simple vectors of integers. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/symmetry.h" line="226" column="13" bodyfile="src/csl/symmetry.cpp" bodystart="238" bodyend="282" declfile="src/csl/symmetry.h" declline="226" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1add650e6936860d1cca4620b846810c94" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classstd_1_1shared__ptr" kindref="compound">std::shared_ptr</ref>&lt; <ref refid="classcsl_1_1TensorFieldParent" kindref="compound">TensorFieldParent</ref> &gt;</type>
        <definition>std::shared_ptr&lt; TensorFieldParent &gt; csl::tensorfield_s</definition>
        <argsstring>(Args &amp;&amp;... args)</argsstring>
        <name>tensorfield_s</name>
        <qualifiedname>csl::tensorfield_s</qualifiedname>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="115" column="21" bodyfile="src/csl/tensorField.h" bodystart="115" bodyend="120"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a2a104a173ead2cd1caffd2f705322f4c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classstd_1_1shared__ptr" kindref="compound">std::shared_ptr</ref>&lt; <ref refid="classcsl_1_1TensorFieldParent" kindref="compound">TensorFieldParent</ref> &gt;</type>
        <definition>std::shared_ptr&lt; TensorFieldParent &gt; csl::tensorfield_s</definition>
        <argsstring>(std::string const &amp;name, csl::Space const *spaceField, std::vector&lt; const Space * &gt; const &amp;indices, Args &amp;&amp;... args)</argsstring>
        <name>tensorfield_s</name>
        <qualifiedname>csl::tensorfield_s</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Space" kindref="compound">csl::Space</ref> const *</type>
          <declname>spaceField</declname>
        </param>
        <param>
          <type>std::vector&lt; const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> * &gt; const &amp;</type>
          <declname>indices</declname>
        </param>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="123" column="21" bodyfile="src/csl/tensorField.h" bodystart="123" bodyend="135"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a1eb678edd6c0d0b61c5fb9fdaa1610ab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::tensorfieldelement_s</definition>
        <argsstring>(Args &amp;&amp;... args)</argsstring>
        <name>tensorfieldelement_s</name>
        <qualifiedname>csl::tensorfieldelement_s</qualifiedname>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="256" column="6" bodyfile="src/csl/tensorField.h" bodystart="256" bodyend="260"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ad1b0aadb45beae343b387da308a7ca4f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::tderivativeelement_s</definition>
        <argsstring>(const Tensor &amp;t_vector, const Parent &amp;t_parent, const Index &amp;t_index)</argsstring>
        <name>tderivativeelement_s</name>
        <qualifiedname>csl::tderivativeelement_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>t_vector</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref> &amp;</type>
          <declname>t_parent</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>t_index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="419" column="6" bodyfile="src/csl/tensorField.h" bodystart="399" bodyend="405" declfile="src/csl/tensorField.h" declline="419" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ab8317f47490f0af4700f1456c76e395c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::tderivativeelement_s</definition>
        <argsstring>(const Tensor &amp;t_vector, const Parent &amp;t_parent, const Index &amp;t_index, const Expr &amp;t_operand, bool t_empty)</argsstring>
        <name>tderivativeelement_s</name>
        <qualifiedname>csl::tderivativeelement_s</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>t_vector</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref> &amp;</type>
          <declname>t_parent</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>t_index</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>t_operand</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>t_empty</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="423" column="6" bodyfile="src/csl/tensorField.h" bodystart="408" bodyend="416" declfile="src/csl/tensorField.h" declline="423" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af9f64f049cd60c9e25e789bee5f7c4e9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classstd_1_1shared__ptr" kindref="compound">std::shared_ptr</ref>&lt; <ref refid="classcsl_1_1TDerivativeParent" kindref="compound">TDerivativeParent</ref> &gt;</type>
        <definition>std::shared_ptr&lt; TDerivativeParent &gt; csl::tderivative_s</definition>
        <argsstring>(Args &amp;&amp;... args)</argsstring>
        <name>tderivative_s</name>
        <qualifiedname>csl::tderivative_s</qualifiedname>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/tensorField.h" line="457" column="21" bodyfile="src/csl/tensorField.h" bodystart="457" bodyend="461"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a943b563ec0e6a248ee95788d037060d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>std::vector&lt; Expr &gt; csl::InverseTaylorExpand</definition>
        <argsstring>(Expr const &amp;init, Expr const &amp;big, size_t order)</argsstring>
        <name>InverseTaylorExpand</name>
        <qualifiedname>csl::InverseTaylorExpand</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>big</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>order</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/utils.cpp" line="34" column="1" bodyfile="src/csl/utils.cpp" bodystart="34" bodyend="43" declfile="src/csl/utils.h" declline="32" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a64d7a74167743977634628632789f105" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>std::vector&lt; Expr &gt; csl::TaylorExpand</definition>
        <argsstring>(Expr const &amp;init, Expr const &amp;eps, size_t order)</argsstring>
        <name>TaylorExpand</name>
        <qualifiedname>csl::TaylorExpand</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> const &amp;</type>
          <declname>eps</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>order</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/utils.cpp" line="45" column="13" bodyfile="src/csl/utils.cpp" bodystart="45" bodyend="62" declfile="src/csl/utils.h" declline="35" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ac1b3a6d198d62535c5eaf5bc008bc69f" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::CopySelf</definition>
        <argsstring>(Abstract *expr)</argsstring>
        <name>CopySelf</name>
        <qualifiedname>csl::CopySelf</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/utils.cpp" line="84" column="6" bodyfile="src/csl/utils.cpp" bodystart="84" bodyend="87" declfile="src/csl/utils.h" declline="47" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ab7420e1ff6f6a7d9f069bca1c6ac16f5" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Copy</definition>
        <argsstring>(const Abstract *expr)</argsstring>
        <name>Copy</name>
        <qualifiedname>csl::Copy</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>See <ref refid="namespacecsl_1ab074eed4bd06ee44010c91e2d1dd05cb" kindref="member">Copy(const Expr&amp; expr)</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>With the apparition of shared_from_this(), this function should be removed soon. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/utils.cpp" line="89" column="6" bodyfile="src/csl/utils.cpp" bodystart="89" bodyend="92" declfile="src/csl/utils.h" declline="45" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ab074eed4bd06ee44010c91e2d1dd05cb" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Copy</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>Copy</name>
        <qualifiedname>csl::Copy</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Copy</bold> an <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> to depth 1. </para>
        </briefdescription>
        <detaileddescription>
<para><bold>Copy</bold> the depth 0 structure. For example the copy of cos(x+exp(y)) creates another cos function but take a reference to x+exp(y). Note that copy a <bold><ref refid="classcsl_1_1Variable" kindref="compound">Variable</ref></bold> will create another with the same name. It could create misunderstanding in the following operations.<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> to copy. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The copy. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/utils.cpp" line="94" column="6" bodyfile="src/csl/utils.cpp" bodystart="94" bodyend="97" declfile="src/csl/utils.h" declline="57" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af1e310aad90377d99f591def8b30336c" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::DeepCopy</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>DeepCopy</name>
        <qualifiedname>csl::DeepCopy</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Copy</bold> an <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> to the <bold>maximum</bold> depth. </para>
        </briefdescription>
        <detaileddescription>
<para><bold>Copy</bold> <bold>recursively</bold> the entire <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> to copy. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The deepCopy. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/utils.cpp" line="99" column="6" bodyfile="src/csl/utils.cpp" bodystart="99" bodyend="102" declfile="src/csl/utils.h" declline="72" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a40f0cf1575083e98534941e8aee6cfad" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::DeepCopy</definition>
        <argsstring>(const Abstract *expr)</argsstring>
        <name>DeepCopy</name>
        <qualifiedname>csl::DeepCopy</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>See <ref refid="namespacecsl_1af1e310aad90377d99f591def8b30336c" kindref="member">DeepCopy(const Expr&amp; expr)</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>With the apparition of shared_from_this(), this function should be removed soon. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/utils.cpp" line="104" column="6" bodyfile="src/csl/utils.cpp" bodystart="104" bodyend="107" declfile="src/csl/utils.h" declline="64" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a967916919ea8ffd29f798cbf06f1b2cd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::WeakDeepCopy</definition>
        <argsstring>(Expr &amp;expr)</argsstring>
        <name>WeakDeepCopy</name>
        <qualifiedname>csl::WeakDeepCopy</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/utils.cpp" line="109" column="6" bodyfile="src/csl/utils.cpp" bodystart="109" bodyend="118" declfile="src/csl/utils.h" declline="74" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a9c5e3c2f5f4c6533ac74d150d29f931d" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Refreshed</definition>
        <argsstring>(const Abstract *expr)</argsstring>
        <name>Refreshed</name>
        <qualifiedname>csl::Refreshed</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>See <ref refid="namespacecsl_1a90a30db275050c669fbe24152402c28e" kindref="member">Refreshed(const Expr&amp; expr)</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>With the apparition of shared_from_this(), this function should be removed soon. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/utils.cpp" line="120" column="6" bodyfile="src/csl/utils.cpp" bodystart="120" bodyend="123" declfile="src/csl/utils.h" declline="81" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a90a30db275050c669fbe24152402c28e" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::Refreshed</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>Refreshed</name>
        <qualifiedname>csl::Refreshed</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Refreshed</bold> an <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> and apply basic simplifications. </para>
        </briefdescription>
        <detaileddescription>
<para>Apply all simplifications that take place normally at the creation of an <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. For example, a sum with only one term gives just the term in question. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> to refresh. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The refreshed <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/utils.cpp" line="125" column="6" bodyfile="src/csl/utils.cpp" bodystart="125" bodyend="128" declfile="src/csl/utils.h" declline="91" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae95bf5940e1dda061d2d9fbdd1a9fff8" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::DeepRefreshed</definition>
        <argsstring>(const Expr &amp;expr)</argsstring>
        <name>DeepRefreshed</name>
        <qualifiedname>csl::DeepRefreshed</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Refreshed</bold> recursively an <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> and apply basic simplifications. </para>
        </briefdescription>
        <detaileddescription>
<para>Apply all simplifications that take place normally at the creation of an <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. For example, a sum with only one term gives just the term in question. The refresh is resursive. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> to refresh. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The refreshed <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/utils.cpp" line="130" column="6" bodyfile="src/csl/utils.cpp" bodystart="130" bodyend="133" declfile="src/csl/utils.h" declline="101" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a9a930df32b60f9efb6a85fdad911cafc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::Refresh</definition>
        <argsstring>(Expr &amp;expr)</argsstring>
        <name>Refresh</name>
        <qualifiedname>csl::Refresh</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/utils.h" line="103" column="13" bodyfile="src/csl/utils.h" bodystart="103" bodyend="106"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af9dd32dc21f4e74403a931a696ccebc8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void csl::DeepRefresh</definition>
        <argsstring>(Expr &amp;expr)</argsstring>
        <name>DeepRefresh</name>
        <qualifiedname>csl::DeepRefresh</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/utils.h" line="108" column="13" bodyfile="src/csl/utils.h" bodystart="108" bodyend="111"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a98f4fab54e137f2b5676abadd7d52cf0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>vector&lt; list&lt; int &gt; &gt;</type>
        <definition>vector&lt; list&lt; int &gt; &gt; csl::getNonZeroElements_impl</definition>
        <argsstring>(Expr_info vec)</argsstring>
        <name>getNonZeroElements_impl</name>
        <qualifiedname>csl::getNonZeroElements_impl</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>vec</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.cpp" line="836" column="8" bodyfile="src/csl/vector.cpp" bodystart="836" bodyend="857"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a221683358d931a3b850adbac2c3b2ad7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>vector&lt; vector&lt; int &gt; &gt;</type>
        <definition>vector&lt; vector&lt; int &gt; &gt; csl::getNonZeroElements</definition>
        <argsstring>(Expr_info vec)</argsstring>
        <name>getNonZeroElements</name>
        <qualifiedname>csl::getNonZeroElements</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>vec</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.cpp" line="859" column="8" bodyfile="src/csl/vector.cpp" bodystart="859" bodyend="869"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a38e476ad740e7d1d261d2a380bbf10f8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int csl::sort_keep_sign</definition>
        <argsstring>(typename std::vector&lt; int &gt;::iterator begin, typename std::vector&lt; int &gt;::iterator end)</argsstring>
        <name>sort_keep_sign</name>
        <qualifiedname>csl::sort_keep_sign</qualifiedname>
        <param>
          <type>typename std::vector&lt; int &gt;::iterator</type>
          <declname>begin</declname>
        </param>
        <param>
          <type>typename std::vector&lt; int &gt;::iterator</type>
          <declname>end</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.cpp" line="891" column="5" bodyfile="src/csl/vector.cpp" bodystart="891" bodyend="911"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a8981c713ceaf99402a0b498ca11cd4ac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::vector_s</definition>
        <argsstring>(int t_nElements)</argsstring>
        <name>vector_s</name>
        <qualifiedname>csl::vector_s</qualifiedname>
        <param>
          <type>int</type>
          <declname>t_nElements</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.cpp" line="1099" column="6" bodyfile="src/csl/vector.cpp" bodystart="1099" bodyend="1102" declfile="src/csl/vector.h" declline="217" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa8ca7db78024cb9bb6324233565dbe71" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::vector_s</definition>
        <argsstring>(int t_nElements, const Expr &amp;expr, const Expr &amp;index)</argsstring>
        <name>vector_s</name>
        <qualifiedname>csl::vector_s</qualifiedname>
        <param>
          <type>int</type>
          <declname>t_nElements</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.cpp" line="1104" column="6" bodyfile="src/csl/vector.cpp" bodystart="1104" bodyend="1107" declfile="src/csl/vector.h" declline="221" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae10b12231ae2ec3d31e0e8f0439c68a4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::vector_s</definition>
        <argsstring>(int t_nElements, const Expr &amp;expr)</argsstring>
        <name>vector_s</name>
        <qualifiedname>csl::vector_s</qualifiedname>
        <param>
          <type>int</type>
          <declname>t_nElements</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.cpp" line="1109" column="6" bodyfile="src/csl/vector.cpp" bodystart="1109" bodyend="1112" declfile="src/csl/vector.h" declline="219" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1adee87590bd3efee965483b9d94c30e75" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::vector_s</definition>
        <argsstring>(const csl::vector_expr &amp;t_argument)</argsstring>
        <name>vector_s</name>
        <qualifiedname>csl::vector_s</qualifiedname>
        <param>
          <type>const csl::vector_expr &amp;</type>
          <declname>t_argument</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.cpp" line="1114" column="6" bodyfile="src/csl/vector.cpp" bodystart="1114" bodyend="1117" declfile="src/csl/vector.h" declline="223" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a5a1e580422f80dd19c9d838c98dc41e3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::vector_s</definition>
        <argsstring>(const std::initializer_list&lt; Expr &gt; &amp;t_argument)</argsstring>
        <name>vector_s</name>
        <qualifiedname>csl::vector_s</qualifiedname>
        <param>
          <type>const std::initializer_list&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; &amp;</type>
          <declname>t_argument</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.cpp" line="1119" column="6" bodyfile="src/csl/vector.cpp" bodystart="1119" bodyend="1123" declfile="src/csl/vector.h" declline="225" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ad1568f00f9e8ce25159f550cb8b34f2a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::matrix_s</definition>
        <argsstring>(int t_nArgs)</argsstring>
        <name>matrix_s</name>
        <qualifiedname>csl::matrix_s</qualifiedname>
        <param>
          <type>int</type>
          <declname>t_nArgs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.cpp" line="1415" column="6" bodyfile="src/csl/vector.cpp" bodystart="1415" bodyend="1418" declfile="src/csl/vector.h" declline="274" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aea9687b3d3c8d28554d2b78206c2cf6b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::matrix_s</definition>
        <argsstring>(int t_x_nArgs, int t_y_nArgs)</argsstring>
        <name>matrix_s</name>
        <qualifiedname>csl::matrix_s</qualifiedname>
        <param>
          <type>int</type>
          <declname>t_x_nArgs</declname>
        </param>
        <param>
          <type>int</type>
          <declname>t_y_nArgs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.cpp" line="1420" column="6" bodyfile="src/csl/vector.cpp" bodystart="1420" bodyend="1423" declfile="src/csl/vector.h" declline="276" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae2db82502d8e742a2ec089982a9dc4f0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::matrix_s</definition>
        <argsstring>(int t_x_nArgs, int t_y_nArgs, const Expr &amp;expr, const Expr &amp;index_x, const Expr &amp;index_y)</argsstring>
        <name>matrix_s</name>
        <qualifiedname>csl::matrix_s</qualifiedname>
        <param>
          <type>int</type>
          <declname>t_x_nArgs</declname>
        </param>
        <param>
          <type>int</type>
          <declname>t_y_nArgs</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>index_x</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>index_y</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.cpp" line="1425" column="6" bodyfile="src/csl/vector.cpp" bodystart="1425" bodyend="1433" declfile="src/csl/vector.h" declline="278" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ab40b15582ed5c1b108ef5d6123c3d921" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::matrix_s</definition>
        <argsstring>(int t_x_nArgs, int t_y_nArgs, const Expr &amp;expr)</argsstring>
        <name>matrix_s</name>
        <qualifiedname>csl::matrix_s</qualifiedname>
        <param>
          <type>int</type>
          <declname>t_x_nArgs</declname>
        </param>
        <param>
          <type>int</type>
          <declname>t_y_nArgs</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.cpp" line="1435" column="6" bodyfile="src/csl/vector.cpp" bodystart="1435" bodyend="1438" declfile="src/csl/vector.h" declline="282" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a6eb43475d2e407f4dfc57db06a23f737" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::matrix_s</definition>
        <argsstring>(const csl::vector_expr &amp;t_argument)</argsstring>
        <name>matrix_s</name>
        <qualifiedname>csl::matrix_s</qualifiedname>
        <param>
          <type>const csl::vector_expr &amp;</type>
          <declname>t_argument</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.cpp" line="1440" column="6" bodyfile="src/csl/vector.cpp" bodystart="1440" bodyend="1443" declfile="src/csl/vector.h" declline="285" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af537d5bf9aef49d6b819b8ad3e9463b5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::matrix_s</definition>
        <argsstring>(const initializer_list&lt; initializer_list&lt; Expr &gt; &gt; &amp;t_matrix)</argsstring>
        <name>matrix_s</name>
        <qualifiedname>csl::matrix_s</qualifiedname>
        <param>
          <type>const initializer_list&lt; initializer_list&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; &gt; &amp;</type>
          <declname>t_matrix</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.cpp" line="1445" column="6" bodyfile="src/csl/vector.cpp" bodystart="1445" bodyend="1452"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ada127901f34826845607c80fc0503674" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::diagonal_s</definition>
        <argsstring>(const csl::vector_expr &amp;diag)</argsstring>
        <name>diagonal_s</name>
        <qualifiedname>csl::diagonal_s</qualifiedname>
        <param>
          <type>const csl::vector_expr &amp;</type>
          <declname>diag</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.cpp" line="1454" column="6" bodyfile="src/csl/vector.cpp" bodystart="1454" bodyend="1461" declfile="src/csl/vector.h" declline="290" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae4e47d1c292116d12bb275fcafbe0d1a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::identity_s</definition>
        <argsstring>(int dim)</argsstring>
        <name>identity_s</name>
        <qualifiedname>csl::identity_s</qualifiedname>
        <param>
          <type>int</type>
          <declname>dim</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.cpp" line="1463" column="6" bodyfile="src/csl/vector.cpp" bodystart="1463" bodyend="1470" declfile="src/csl/vector.h" declline="292" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1af226f60d4468e187a080af93d1cae2f1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::highdtensor_s</definition>
        <argsstring>(const vector&lt; int &gt; &amp;shape)</argsstring>
        <name>highdtensor_s</name>
        <qualifiedname>csl::highdtensor_s</qualifiedname>
        <param>
          <type>const vector&lt; int &gt; &amp;</type>
          <declname>shape</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.cpp" line="1548" column="6" bodyfile="src/csl/vector.cpp" bodystart="1548" bodyend="1557"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a46e8c1e3c3fb7eeab12f8f9982e71fd4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::highdtensor_s</definition>
        <argsstring>(const vector&lt; int &gt; &amp;shape, const Expr &amp;filler)</argsstring>
        <name>highdtensor_s</name>
        <qualifiedname>csl::highdtensor_s</qualifiedname>
        <param>
          <type>const vector&lt; int &gt; &amp;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>filler</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.cpp" line="1559" column="6" bodyfile="src/csl/vector.cpp" bodystart="1559" bodyend="1568"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa0cdba2e21f0e536f59d3d6efa41107a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::highdtensor_from_args_s</definition>
        <argsstring>(const csl::vector_expr &amp;t_argument)</argsstring>
        <name>highdtensor_from_args_s</name>
        <qualifiedname>csl::highdtensor_from_args_s</qualifiedname>
        <param>
          <type>const csl::vector_expr &amp;</type>
          <declname>t_argument</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.cpp" line="1570" column="6" bodyfile="src/csl/vector.cpp" bodystart="1570" bodyend="1587"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae70d81c7dc91e29f2e181729dca8aa28" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::vectorialtensor_s</definition>
        <argsstring>(const std::vector&lt; int &gt; &amp;shape)</argsstring>
        <name>vectorialtensor_s</name>
        <qualifiedname>csl::vectorialtensor_s</qualifiedname>
        <param>
          <type>const std::vector&lt; int &gt; &amp;</type>
          <declname>shape</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.cpp" line="1589" column="6" bodyfile="src/csl/vector.cpp" bodystart="1589" bodyend="1607" declfile="src/csl/vector.h" declline="323" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1acd056968db6fcc45d41d89a83fdb9e2f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::vectorialtensor_s</definition>
        <argsstring>(const std::vector&lt; int &gt; &amp;shape, const Expr &amp;filler)</argsstring>
        <name>vectorialtensor_s</name>
        <qualifiedname>csl::vectorialtensor_s</qualifiedname>
        <param>
          <type>const std::vector&lt; int &gt; &amp;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>filler</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.cpp" line="1609" column="6" bodyfile="src/csl/vector.cpp" bodystart="1609" bodyend="1627" declfile="src/csl/vector.h" declline="325" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1aa227ac35150f5c67ff1b58a50091852c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::highdtensor_s</definition>
        <argsstring>(const initializer_list&lt; initializer_list&lt; initializer_list&lt; Expr &gt; &gt; &gt; &amp;t_tensor)</argsstring>
        <name>highdtensor_s</name>
        <qualifiedname>csl::highdtensor_s</qualifiedname>
        <param>
          <type>const initializer_list&lt; initializer_list&lt; initializer_list&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; &gt; &gt; &amp;</type>
          <declname>t_tensor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.cpp" line="1629" column="6" bodyfile="src/csl/vector.cpp" bodystart="1629" bodyend="1637"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1acd9c00b937944256df75e3d70805f079" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::matrix_s</definition>
        <argsstring>(const std::initializer_list&lt; std::initializer_list&lt; Expr &gt; &gt; &amp;t_matrix)</argsstring>
        <name>matrix_s</name>
        <qualifiedname>csl::matrix_s</qualifiedname>
        <param>
          <type>const std::initializer_list&lt; std::initializer_list&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; &gt; &amp;</type>
          <declname>t_matrix</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.h" line="287" column="6" declfile="src/csl/vector.h" declline="287" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a1e5d02b73a3a5f3f0a331eb18b073e06" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::highdtensor_s</definition>
        <argsstring>(const std::vector&lt; int &gt; &amp;shape)</argsstring>
        <name>highdtensor_s</name>
        <qualifiedname>csl::highdtensor_s</qualifiedname>
        <param>
          <type>const std::vector&lt; int &gt; &amp;</type>
          <declname>shape</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.h" line="314" column="6" bodyfile="src/csl/vector.cpp" bodystart="1548" bodyend="1557" declfile="src/csl/vector.h" declline="314" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a20fa0837c6659c2b4971c120b3b0579e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::highdtensor_s</definition>
        <argsstring>(const std::vector&lt; int &gt; &amp;shape, const Expr &amp;filler)</argsstring>
        <name>highdtensor_s</name>
        <qualifiedname>csl::highdtensor_s</qualifiedname>
        <param>
          <type>const std::vector&lt; int &gt; &amp;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>filler</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.h" line="316" column="6" bodyfile="src/csl/vector.cpp" bodystart="1559" bodyend="1568" declfile="src/csl/vector.h" declline="316" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1a31f1e283c714e9b89494aaa003f77df8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::highdtensor_s</definition>
        <argsstring>(const std::initializer_list&lt; std::initializer_list&lt; std::initializer_list&lt; Expr &gt; &gt; &gt; &amp;t_tensor)</argsstring>
        <name>highdtensor_s</name>
        <qualifiedname>csl::highdtensor_s</qualifiedname>
        <param>
          <type>const std::initializer_list&lt; std::initializer_list&lt; std::initializer_list&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; &gt; &gt; &amp;</type>
          <declname>t_tensor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.h" line="318" column="6" declfile="src/csl/vector.h" declline="318" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacecsl_1ae292ffd8c883f3144ffbde88867d7df0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::highdtensor_from_args_s</definition>
        <argsstring>(const std::vector&lt; Expr &gt; &amp;args)</argsstring>
        <name>highdtensor_from_args_s</name>
        <qualifiedname>csl::highdtensor_from_args_s</qualifiedname>
        <param>
          <type>const std::vector&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt; &amp;</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/vector.h" line="321" column="6" declfile="src/csl/vector.h" declline="321" declcolumn="6"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>Namespace for csl library. </para>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="src/csl/abreviation.cpp" line="29" column="1"/>
  </compounddef>
</doxygen>
