<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.12.0" xml:lang="en-US">
  <compounddef id="classcsl_1_1TensorElement" kind="class" language="C++" prot="public">
    <compoundname>csl::TensorElement</compoundname>
    <basecompoundref refid="classcsl_1_1AbstractElement" prot="public" virt="non-virtual">csl::AbstractElement</basecompoundref>
    <derivedcompoundref refid="classcsl_1_1TensorFieldElement" prot="public" virt="non-virtual">csl::TensorFieldElement</derivedcompoundref>
    <derivedcompoundref refid="classmty_1_1GeneratorElement" prot="public" virt="non-virtual">mty::GeneratorElement</derivedcompoundref>
    <includes refid="indicial_8h" local="no">indicial.h</includes>
    <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="classcsl_1_1TensorElement_1a7f7b50e1bbd4157e8b2797740aa31b89" prot="protected" static="no" mutable="no">
        <type><ref refid="classcsl_1_1IndexStructure" kindref="compound">IndexStructure</ref></type>
        <definition>IndexStructure csl::TensorElement::index</definition>
        <argsstring></argsstring>
        <name>index</name>
        <qualifiedname>csl::TensorElement::index</qualifiedname>
        <briefdescription>
<para><ref refid="classcsl_1_1IndexStructure" kindref="compound">IndexStructure</ref> of the tensor. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="704" column="20" bodyfile="src/csl/indicial.h" bodystart="704" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="classcsl_1_1TensorElement_1ae0b7c09c0acd3173ba66669d797192c0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>csl::TensorElement::TensorElement</definition>
        <argsstring>()=default</argsstring>
        <name>TensorElement</name>
        <qualifiedname>csl::TensorElement::TensorElement</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="707" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a1b29839ab99dd106e336ce900023d18a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>csl::TensorElement::TensorElement</definition>
        <argsstring>(const Index &amp;t_index, const Parent &amp;t_parent)</argsstring>
        <name>TensorElement</name>
        <qualifiedname>csl::TensorElement::TensorElement</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>t_index</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref> &amp;</type>
          <declname>t_parent</declname>
        </param>
        <briefdescription>
<para>Constructor called by an <ref refid="classcsl_1_1TensorParent" kindref="compound">TensorParent</ref>, for a tensor with one index. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t_index</parametername>
</parameternamelist>
<parameterdescription>
<para>(Only) index of the tensor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>t_parent</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the <ref refid="classcsl_1_1TensorParent" kindref="compound">TensorParent</ref> creating the tensor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="715" column="5" bodyfile="src/csl/indicial.cpp" bodystart="2188" bodyend="2192"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1ac2169c4eabe165be2f0c455f658a0036" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>csl::TensorElement::TensorElement</definition>
        <argsstring>(const std::vector&lt; Index &gt; &amp;indices, const Parent &amp;t_parent)</argsstring>
        <name>TensorElement</name>
        <qualifiedname>csl::TensorElement::TensorElement</qualifiedname>
        <param>
          <type>const std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &gt; &amp;</type>
          <declname>indices</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref> &amp;</type>
          <declname>t_parent</declname>
        </param>
        <briefdescription>
<para>Constructor called by an <ref refid="classcsl_1_1TensorParent" kindref="compound">TensorParent</ref>, for a tensor with several indices. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t_index</parametername>
</parameternamelist>
<parameterdescription>
<para>List of indices for the tensor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>t_parent</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the <ref refid="classcsl_1_1TensorParent" kindref="compound">TensorParent</ref> creating the tensor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="724" column="5" bodyfile="src/csl/indicial.cpp" bodystart="2194" bodyend="2199"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a3bba3e8ce7e864a2921ad91e4019454c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>csl::TensorElement::TensorElement</definition>
        <argsstring>(const IndexStructure &amp;indices, const Parent &amp;t_parent)</argsstring>
        <name>TensorElement</name>
        <qualifiedname>csl::TensorElement::TensorElement</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1IndexStructure" kindref="compound">IndexStructure</ref> &amp;</type>
          <declname>indices</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref> &amp;</type>
          <declname>t_parent</declname>
        </param>
        <briefdescription>
<para>Constructor called by an <ref refid="classcsl_1_1TensorParent" kindref="compound">TensorParent</ref>, for a tensor with several indices. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t_index</parametername>
</parameternamelist>
<parameterdescription>
<para>List of indices for the tensor in the form of an already created <ref refid="classcsl_1_1IndexStructure" kindref="compound">IndexStructure</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>t_parent</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the <ref refid="classcsl_1_1TensorParent" kindref="compound">TensorParent</ref> creating the tensor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="734" column="5" bodyfile="src/csl/indicial.cpp" bodystart="2201" bodyend="2206"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a4d45c8d308213ea65d46f9aeab883d9f" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>csl::TensorElement::TensorElement</definition>
        <argsstring>(const Abstract *&amp;expression)</argsstring>
        <name>TensorElement</name>
        <qualifiedname>csl::TensorElement::TensorElement</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *&amp;</type>
          <declname>expression</declname>
        </param>
        <briefdescription>
<para>Copy constructor from an Abstract*. Works only if the pointer points to another <ref refid="classcsl_1_1TensorElement" kindref="compound">TensorElement</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expression</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="743" column="14" bodyfile="src/csl/indicial.cpp" bodystart="2209" bodyend="2213"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a4f78788e311f00a646e933b102fe365c" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>csl::TensorElement::TensorElement</definition>
        <argsstring>(const Expr &amp;expression)</argsstring>
        <name>TensorElement</name>
        <qualifiedname>csl::TensorElement::TensorElement</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expression</declname>
        </param>
        <briefdescription>
<para>Copy constructor from an <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref>. Works only if the pointer points to another <ref refid="classcsl_1_1TensorElement" kindref="compound">TensorElement</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expression</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="751" column="14" bodyfile="src/csl/indicial.cpp" bodystart="2216" bodyend="2222"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a1c246057031fbc18868bac66d13be37c" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type><ref refid="namespacecsl_1a70046459ec0082db8cb97005c13c9a54" kindref="member">csl::PrimaryType</ref></type>
        <definition>csl::PrimaryType csl::TensorElement::getPrimaryType</definition>
        <argsstring>() const override</argsstring>
        <name>getPrimaryType</name>
        <qualifiedname>csl::TensorElement::getPrimaryType</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a8ab79682cdff4c7d7b52c2e70ac23d85">getPrimaryType</reimplements>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1aab050fd18460d4842d8972a990363b0c">getPrimaryType</reimplementedby>
        <briefdescription>
<para>Gives the <bold>primary</bold> <bold>type</bold> of <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>In the program this function is very often called. It allows different functions to know what type of expr they are manipulating (single number, scalar function with one argument, with multiple argumments, a <ref refid="classcsl_1_1Vector" kindref="compound">Vector</ref>, etc) in order to do special treatments or simplifications. <simplesect kind="return"><para>type (a non memorized integer corresponding to the type of abstract) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="763" column="22" bodyfile="src/csl/indicial.h" bodystart="763" bodyend="766"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1ae7a6d8fc44218dcade0332e215f4b653" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>size_t</type>
        <definition>size_t csl::TensorElement::memoryOverhead</definition>
        <argsstring>() const override</argsstring>
        <name>memoryOverhead</name>
        <qualifiedname>csl::TensorElement::memoryOverhead</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1ac3978c71035bf1cda50f5b9031d631af">memoryOverhead</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="768" column="12" bodyfile="src/csl/indicial.cpp" bodystart="2224" bodyend="2227"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1acc36470e69d6edf43f6dd7b6db0365d2" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>bool</type>
        <definition>bool csl::TensorElement::isIndexed</definition>
        <argsstring>() const override</argsstring>
        <name>isIndexed</name>
        <qualifiedname>csl::TensorElement::isIndexed</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a216b7bd3930fbf047e5bf8f69e9b964c">isIndexed</reimplements>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1a9bc54de57d7301838f673c014ed9d79f">isIndexed</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><bold>True</bold> if the expression is indexed. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="770" column="10" bodyfile="src/csl/indicial.h" bodystart="770" bodyend="773"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a5ddd03efb94ea0017def76cd6777f745" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>int</type>
        <definition>int csl::TensorElement::getNIndices</definition>
        <argsstring>() const override</argsstring>
        <name>getNIndices</name>
        <qualifiedname>csl::TensorElement::getNIndices</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1add364193f7a78ac28f7001c7f4036453">getNIndices</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The number of indices of an <bold>Indicial</bold> expression. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="775" column="9" bodyfile="src/csl/indicial.h" bodystart="775" bodyend="778"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a1ca07618e533c2ca4b4cc3646195a64d" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::TensorElement::resetIndexStructure</definition>
        <argsstring>() override</argsstring>
        <name>resetIndexStructure</name>
        <qualifiedname>csl::TensorElement::resetIndexStructure</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1af0d95f3edc0562b1d75d60b670119842">resetIndexStructure</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="780" column="10" bodyfile="src/csl/indicial.cpp" bodystart="2617" bodyend="2620"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a3dc05ca45a03e8a7f8459812e07b85f6" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type><ref refid="classcsl_1_1IndexStructure" kindref="compound">IndexStructure</ref></type>
        <definition>IndexStructure csl::TensorElement::getIndexStructure</definition>
        <argsstring>() const override</argsstring>
        <name>getIndexStructure</name>
        <qualifiedname>csl::TensorElement::getIndexStructure</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1ae125a32b6f3d0368b6055d4e58c1ff3f">getIndexStructure</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The index structure of the <bold>Indicial</bold> expression </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="782" column="20" bodyfile="src/csl/indicial.h" bodystart="782" bodyend="785"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1abe312de6a76204dfcdc98cf4711bf353" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>const <ref refid="classcsl_1_1IndexStructure" kindref="compound">IndexStructure</ref> &amp;</type>
        <definition>const IndexStructure &amp; csl::TensorElement::getIndexStructureView</definition>
        <argsstring>() const override</argsstring>
        <name>getIndexStructureView</name>
        <qualifiedname>csl::TensorElement::getIndexStructureView</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1addb848bf4cdea207484a71e9b1006ead">getIndexStructureView</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="787" column="26" bodyfile="src/csl/indicial.h" bodystart="787" bodyend="790"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a15b5b8ef2a249fda36f7491b634270fb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="virtual">
        <type><ref refid="classcsl_1_1IndexStructure" kindref="compound">IndexStructure</ref> &amp;</type>
        <definition>IndexStructure &amp; csl::TensorElement::getIndexStructureView</definition>
        <argsstring>() override</argsstring>
        <name>getIndexStructureView</name>
        <qualifiedname>csl::TensorElement::getIndexStructureView</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a632e28530a68539fadacd7ab7ffc8be1">getIndexStructureView</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="792" column="20" bodyfile="src/csl/indicial.h" bodystart="792" bodyend="795"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1acd1ac409b891dd033c1792f5473d8d10" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::TensorElement::compareWithDummy</definition>
        <argsstring>(Expr_info expr, std::map&lt; Index, Index &gt; &amp;constraints, bool keepAllCosntraints=false) const override</argsstring>
        <name>compareWithDummy</name>
        <qualifiedname>csl::TensorElement::compareWithDummy</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a7caee12abb451168149779a668dfc59e">compareWithDummy</reimplements>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1a7568ac709f768fc70a4797731b7d9e7a">compareWithDummy</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::map&lt; <ref refid="classcsl_1_1Index" kindref="compound">Index</ref>, <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &gt; &amp;</type>
          <declname>constraints</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>keepAllCosntraints</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Comparison disregarding name of dummy indices, i.e. the two expressions * are equals even if dummy indices have not the same names in *this and * expr. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to compare.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>constraints</parametername>
</parameternamelist>
<parameterdescription>
<para>List of existing constraints between indices (it is modified in the function).</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if expr == *this taking constraints into account. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="797" column="10" bodyfile="src/csl/indicial.cpp" bodystart="2376" bodyend="2395"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a7b99f83fdff13fb508ea8e671d4dc834" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type><ref refid="namespacecsl_1ace591865c69b6315c533a1a325777312" kindref="member">csl::Type</ref></type>
        <definition>csl::Type csl::TensorElement::getType</definition>
        <argsstring>() const override</argsstring>
        <name>getType</name>
        <qualifiedname>csl::TensorElement::getType</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aa781456c3f801b37ce169c83514c51c1">getType</reimplements>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1ab78b88ff1b49707ee98aee3211214044">getType</reimplementedby>
        <briefdescription>
<para>Gives the <bold>type</bold> of <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>In the program this function is very often called. It allows different functions to know what type of expr they are manipulating (cos, product, number, etc) in order to do special treatments or simplifications. <simplesect kind="return"><para>type (a non memorized integer corresponding to the type of abstract) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="801" column="15" bodyfile="src/csl/indicial.h" bodystart="801" bodyend="804"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a684ed9584f9bbe4ffc1e842b84a05ed0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::TensorElement::getComplexConjugate</definition>
        <argsstring>() const override</argsstring>
        <name>getComplexConjugate</name>
        <qualifiedname>csl::TensorElement::getComplexConjugate</qualifiedname>
        <reimplements refid="classcsl_1_1Complexified_1a9d3fec789b00de1625df53232da4cf30">getComplexConjugate</reimplements>
        <briefdescription>
<para>Calculates and returns the complex conjugate of the expression. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>\bar{*this}. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="806" column="19" bodyfile="src/csl/indicial.cpp" bodystart="2263" bodyend="2269"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1ab38b54f3efd6b9950b6d3334a224caa1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::TensorElement::getHermitianConjugate</definition>
        <argsstring>(const Space *space) const override</argsstring>
        <name>getHermitianConjugate</name>
        <qualifiedname>csl::TensorElement::getHermitianConjugate</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aa5b707a5efdaef7c7945cbd921c3f526">getHermitianConjugate</reimplements>
        <param>
          <type>const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> *</type>
          <declname>space</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="809" column="5" bodyfile="src/csl/indicial.cpp" bodystart="2271" bodyend="2284"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1ac1596174400a2ccd49d56b736fa8114a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::TensorElement::getHermitianConjugate</definition>
        <argsstring>(const std::vector&lt; const Space * &gt; &amp;spaces) const override</argsstring>
        <name>getHermitianConjugate</name>
        <qualifiedname>csl::TensorElement::getHermitianConjugate</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aff5cca2b2c8190e59f6e34cb1e383d36">getHermitianConjugate</reimplements>
        <param>
          <type>const std::vector&lt; const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> * &gt; &amp;</type>
          <declname>spaces</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="811" column="19" bodyfile="src/csl/indicial.cpp" bodystart="2286" bodyend="2302"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1ae47bc7e79e284964b2a8447bf917f48f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::TensorElement::getTransposed</definition>
        <argsstring>(const Space *space, bool applyProp=true) const override</argsstring>
        <name>getTransposed</name>
        <qualifiedname>csl::TensorElement::getTransposed</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a404c5e89a3aad8a8dabcb56d4120c0fe">getTransposed</reimplements>
        <param>
          <type>const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> *</type>
          <declname>space</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>applyProp</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="814" column="19" bodyfile="src/csl/indicial.cpp" bodystart="2304" bodyend="2341"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a7cc7fb9e1f39bcebc90170e8dd526d43" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::TensorElement::getTransposed</definition>
        <argsstring>(const std::vector&lt; const Space * &gt; &amp;t_spaces, bool applyProp=true) const override</argsstring>
        <name>getTransposed</name>
        <qualifiedname>csl::TensorElement::getTransposed</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aca3debb143668fd3ab75a27a47dd0c13">getTransposed</reimplements>
        <param>
          <type>const std::vector&lt; const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> * &gt; &amp;</type>
          <declname>t_spaces</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>applyProp</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="818" column="5" bodyfile="src/csl/indicial.cpp" bodystart="2344" bodyend="2359"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a029c4358822daed54f4f775032896790" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Index" kindref="compound">Index</ref></type>
        <definition>Index csl::TensorElement::getIndex</definition>
        <argsstring>(int i) const override</argsstring>
        <name>getIndex</name>
        <qualifiedname>csl::TensorElement::getIndex</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a3234ce243f6a2e11950be42f10100943">getIndex</reimplements>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>i</parametername>
</parameternamelist>
<parameterdescription>
<para>Spot of the index to get. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the i^{th} index of an <bold>Indicial</bold> expression. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="821" column="11" bodyfile="src/csl/indicial.cpp" bodystart="2229" bodyend="2235"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a6ec375934423dbb60f6d00ea13ec7f80" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::TensorElement::askTerm</definition>
        <argsstring>(Expr_info expr, bool exact=false) const override</argsstring>
        <name>askTerm</name>
        <qualifiedname>csl::TensorElement::askTerm</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a27ad666bf7d533607da9675b0c645ee9">askTerm</reimplements>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>exact</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Determines if the term <bold>expr</bold> can be factorized out from the <ref refid="classcsl_1_1TensorElement" kindref="compound">TensorElement</ref>, i.e. if <bold>expr</bold> is equal to the tensor to (may be) a renaming of index. </para>
        </briefdescription>
        <detaileddescription>
<para>If <bold>exact</bold> is set to <bold>true</bold>, the function returns <bold>true</bold> if the <ref refid="classcsl_1_1IndexStructure" kindref="compound">IndexStructure</ref> matches exactly. Else, the <ref refid="classcsl_1_1Comparator_1ab82c75000df87b5832f77e034d064656" kindref="member">Comparator::freeIndexComparison()</ref> function is called.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Term to compare. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>exact</parametername>
</parameternamelist>
<parameterdescription>
<para>Tells if the comparison must be exact regarding indices.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if <bold>expr</bold> can be factorized out. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="836" column="10" bodyfile="src/csl/indicial.cpp" bodystart="2237" bodyend="2243"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a14ad4f8a47af9ea009bcea3385e45bc3" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::TensorElement::dependsOn</definition>
        <argsstring>(Expr_info expr) const override</argsstring>
        <name>dependsOn</name>
        <qualifiedname>csl::TensorElement::dependsOn</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a40fe2ccf376dadd21b2d7a0f134d86c6">dependsOn</reimplements>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1ab452e8d298be5e58e28e92aa6eca1c25">dependsOn</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Check recursively if the expression depends on <bold>expr</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to search. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if a dependency in <bold>expr</bold> is found. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="838" column="10" bodyfile="src/csl/indicial.cpp" bodystart="2361" bodyend="2364"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a016485a4c1fe60991263a4dea94eed6e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::TensorElement::dependsOn</definition>
        <argsstring>(Parent_info t_parent) const override</argsstring>
        <name>dependsOn</name>
        <qualifiedname>csl::TensorElement::dependsOn</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a9d7d8586a0df66ba8da33528d6400e66">dependsOn</reimplements>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1aeb70122164b2685fc291090258f59b9b">dependsOn</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1AbstractParent" kindref="compound">Parent_info</ref></type>
          <declname>t_parent</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="840" column="10" bodyfile="src/csl/indicial.cpp" bodystart="2366" bodyend="2369"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a22a5c9686859930af78f51a85b31160d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::TensorElement::dependsExplicitlyOn</definition>
        <argsstring>(Expr_info expr) const override</argsstring>
        <name>dependsExplicitlyOn</name>
        <qualifiedname>csl::TensorElement::dependsExplicitlyOn</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1ac3c9887977249e4d71ea36c6377b3581">dependsExplicitlyOn</reimplements>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1a43644a7030777b98a28cbaa15f229bfa">dependsExplicitlyOn</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Check recursively if <bold>expr</bold> is present in the expression. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression to search. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if <bold>expr</bold> is found. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="842" column="10" bodyfile="src/csl/indicial.cpp" bodystart="2371" bodyend="2374"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1ad9d1474eb8d1c53835ffb3891e01b020" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::TensorElement::checkIndexStructure</definition>
        <argsstring>(const std::vector&lt; Index &gt; &amp;t_index) const override</argsstring>
        <name>checkIndexStructure</name>
        <qualifiedname>csl::TensorElement::checkIndexStructure</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1afd9d0336808e8adf4ccdccb51587ed8c">checkIndexStructure</reimplements>
        <param>
          <type>const std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &gt; &amp;</type>
          <declname>t_index</declname>
        </param>
        <briefdescription>
<para>Checks the compatibility of the index structure of an <bold>Indicial</bold> expression with another. In a sum, two terms must have exaclty the same index structure. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t_index</parametername>
</parameternamelist>
<parameterdescription>
<para>A std::vector of <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> to compare. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if the two structures match. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="844" column="10" bodyfile="src/csl/indicial.cpp" bodystart="2397" bodyend="2422"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1ab0c7c1c3fb0105a70a1c73db895e0317" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::TensorElement::selfCheckIndexStructure</definition>
        <argsstring>()</argsstring>
        <name>selfCheckIndexStructure</name>
        <qualifiedname>csl::TensorElement::selfCheckIndexStructure</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="846" column="10" bodyfile="src/csl/indicial.cpp" bodystart="2424" bodyend="2432"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a02fe69a766b8eade9d5de6cbea8054a6" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::TensorElement::replaceIndex</definition>
        <argsstring>(const Index &amp;indexToReplace, const Index &amp;newIndex, bool refresh=true) const override</argsstring>
        <name>replaceIndex</name>
        <qualifiedname>csl::TensorElement::replaceIndex</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1acc0eb077e25c9a67d15269cf8d5f0511">replaceIndex</reimplements>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>indexToReplace</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &amp;</type>
          <declname>newIndex</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>refresh</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>For indicial expressions, this function searches <bold>indexToContract</bold> and replaces it with newIndex. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>indexToContract</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> that is newly contracted. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>newIndex</parametername>
</parameternamelist>
<parameterdescription>
<para>Dummy new index that replaces <bold>indexToContract</bold> in the expression. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if the index has been found. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="848" column="19" bodyfile="src/csl/indicial.cpp" bodystart="2458" bodyend="2478"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a9ad3c1eabb60fb445f9054699f9d949d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::TensorElement::replaceIndices</definition>
        <argsstring>(std::vector&lt; Index &gt; const &amp;indexToReplace, std::vector&lt; Index &gt; const &amp;newIndex, bool refresh=true, bool flipped=false) const override</argsstring>
        <name>replaceIndices</name>
        <qualifiedname>csl::TensorElement::replaceIndices</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1ac9e54a236015d14af42b0bcde41953f3">replaceIndices</reimplements>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &gt; const &amp;</type>
          <declname>indexToReplace</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &gt; const &amp;</type>
          <declname>newIndex</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>refresh</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>flipped</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="853" column="5" bodyfile="src/csl/indicial.cpp" bodystart="2481" bodyend="2511"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a16558db6dbbfcf52c37b52f8a883b5a6" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::TensorElement::replaceIndexInPlace</definition>
        <argsstring>(Index const &amp;oldIndex, Index const &amp;newIndex) override</argsstring>
        <name>replaceIndexInPlace</name>
        <qualifiedname>csl::TensorElement::replaceIndexInPlace</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a9372ddd521fa661c5d3371e0d8d4dfc3">replaceIndexInPlace</reimplements>
        <param>
          <type><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> const &amp;</type>
          <declname>oldIndex</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Index" kindref="compound">Index</ref> const &amp;</type>
          <declname>newIndex</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="858" column="10" bodyfile="src/csl/indicial.cpp" bodystart="2447" bodyend="2456"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1aafc27871bb78f0a07df8aa097d3d8a0e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>csl::vector_expr</type>
        <definition>csl::vector_expr csl::TensorElement::breakSpace</definition>
        <argsstring>(const Space *brokenSpace, const std::vector&lt; const Space * &gt; &amp;newSpaces, const std::vector&lt; std::string &gt; &amp;indexNames) const override</argsstring>
        <name>breakSpace</name>
        <qualifiedname>csl::TensorElement::breakSpace</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1af0f40b77914e45f56bf87839d00211d7">breakSpace</reimplements>
        <param>
          <type>const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> *</type>
          <declname>brokenSpace</declname>
        </param>
        <param>
          <type>const std::vector&lt; const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> * &gt; &amp;</type>
          <declname>newSpaces</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::string &gt; &amp;</type>
          <declname>indexNames</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="862" column="5" bodyfile="src/csl/indicial.cpp" bodystart="2596" bodyend="2615"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a387f69126ae40d711755945ef023de92" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::TensorElement::setIndexStructure</definition>
        <argsstring>(const IndexStructure &amp;t_index) override</argsstring>
        <name>setIndexStructure</name>
        <qualifiedname>csl::TensorElement::setIndexStructure</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a70f946f9c59df045ef7416320ade89c7">setIndexStructure</reimplements>
        <param>
          <type>const <ref refid="classcsl_1_1IndexStructure" kindref="compound">IndexStructure</ref> &amp;</type>
          <declname>t_index</declname>
        </param>
        <briefdescription>
<para>Replaces the index structure of the object, that must be an <bold>Indicial</bold> expression. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t_index</parametername>
</parameternamelist>
<parameterdescription>
<para>A std::vector of <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> which takes the place of the structure index. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="866" column="10" bodyfile="src/csl/indicial.cpp" bodystart="2622" bodyend="2631"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a511992d33dc54c1fb8d0c4c17afa5f8c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::TensorElement::hasContractionProperty</definition>
        <argsstring>(Expr_info B) const override</argsstring>
        <name>hasContractionProperty</name>
        <qualifiedname>csl::TensorElement::hasContractionProperty</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aa31e08c251d96b8ea8ec8d385895c1ff">hasContractionProperty</reimplements>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>B</declname>
        </param>
        <briefdescription>
<para>Tells (for an Indicial type) if there is a special contraction property with <bold>B</bold>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression with which we test if there is a special contraction. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if there is a contraction. </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="868" column="10" bodyfile="src/csl/indicial.cpp" bodystart="2633" bodyend="2636"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a5f1b1ae7f3655cccd70bf09a60075b7b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::vector&lt; <ref refid="classcsl_1_1ContractionChain" kindref="compound">ContractionChain</ref> &gt;</type>
        <definition>vector&lt; ContractionChain &gt; csl::TensorElement::getContractionProperties</definition>
        <argsstring>() const override</argsstring>
        <name>getContractionProperties</name>
        <qualifiedname>csl::TensorElement::getContractionProperties</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aec707d949f0f98e08ab4642c93dd9eb5">getContractionProperties</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="870" column="17" bodyfile="src/csl/indicial.cpp" bodystart="2638" bodyend="2641"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a2a301cd1beb0eecde2b83c1ca6167c59" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::TensorElement::contraction</definition>
        <argsstring>(Expr_info B) const override</argsstring>
        <name>contraction</name>
        <qualifiedname>csl::TensorElement::contraction</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1ad874fc858295a737e6ce884530f1109b">contraction</reimplements>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>B</declname>
        </param>
        <briefdescription>
<para>Applies a special contraction of indices. Before calling this function we must check that there is indeed a contraction by calling the function <ref refid="classcsl_1_1TensorElement_1a511992d33dc54c1fb8d0c4c17afa5f8c" kindref="member">hasContractionProperty()</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression with which <bold>*this</bold> contracts. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The result of the contraction. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="872" column="10" bodyfile="src/csl/indicial.cpp" bodystart="2643" bodyend="2646"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1acb6f22178e26a8cc694ae2ffc01c2075" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::TensorElement::hasChainContractionProperty</definition>
        <argsstring>() const override</argsstring>
        <name>hasChainContractionProperty</name>
        <qualifiedname>csl::TensorElement::hasChainContractionProperty</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a94bf1455397fdd2df8dbbc3b41c2f3f4">hasChainContractionProperty</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="874" column="10" bodyfile="src/csl/indicial.cpp" bodystart="2648" bodyend="2656"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1ad6f100f8c15bee5c29d97d40549a6e18" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::TensorElement::applyPermutation</definition>
        <argsstring>(const Permutation &amp;permutations) const</argsstring>
        <name>applyPermutation</name>
        <qualifiedname>csl::TensorElement::applyPermutation</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Permutation" kindref="compound">Permutation</ref> &amp;</type>
          <declname>permutations</declname>
        </param>
        <briefdescription>
<para>Applies a permutation of the indices on a copy of the <ref refid="classcsl_1_1TensorElement" kindref="compound">TensorElement</ref>, and returns it. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>permutations</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Permutation" kindref="compound">Permutation</ref> to apply on the new <ref refid="classcsl_1_1TensorElement" kindref="compound">TensorElement</ref>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="884" column="10" bodyfile="src/csl/indicial.cpp" bodystart="2658" bodyend="2674"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1aa0f1ab4f63aa28f3c759a666fb15636a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>csl::vector_expr</type>
        <definition>csl::vector_expr csl::TensorElement::getPermutations</definition>
        <argsstring>(bool optimize=true) const override</argsstring>
        <name>getPermutations</name>
        <qualifiedname>csl::TensorElement::getPermutations</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a946d175d946da102c5f4cc91840703cb">getPermutations</reimplements>
        <param>
          <type>bool</type>
          <declname>optimize</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Returns a std::vector of all possible permutations of an <bold>Indicial</bold> expression. The possible permutations are determined from the posible symmetries and anti-symmetries of the object. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A std::vector containing all possible permutations of the tensor. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="886" column="22" bodyfile="src/csl/indicial.cpp" bodystart="2676" bodyend="2737"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1ad6f8f7e5b89936e1fa39661b1975c3ce" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::TensorElement::getCanonicalPermutation</definition>
        <argsstring>() const override</argsstring>
        <name>getCanonicalPermutation</name>
        <qualifiedname>csl::TensorElement::getCanonicalPermutation</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1afeb26e1382411448ce3c65d50fefd8bb">getCanonicalPermutation</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="888" column="10" bodyfile="src/csl/indicial.cpp" bodystart="2761" bodyend="2779"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a0b5baffa4b563fd8e2e8ec4ee00446b1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::TensorElement::print</definition>
        <argsstring>(int mode=0, std::ostream &amp;out=std::cout, LibraryMode libMode=LibraryMode::NoLib) const override</argsstring>
        <name>print</name>
        <qualifiedname>csl::TensorElement::print</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aed56cb85894209a9bbc9b8bdada5e6ab">print</reimplements>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1afac7a7dd245d9d1bc5f52700e2a6acb8">print</reimplementedby>
        <param>
          <type>int</type>
          <declname>mode</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
          <defval>std::cout</defval>
        </param>
        <param>
          <type>LibraryMode</type>
          <declname>libMode</declname>
          <defval>LibraryMode::NoLib</defval>
        </param>
        <briefdescription>
<para>Displays the abstract in standard output. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>Tells if the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> is printed alone (default) or in another expr. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="890" column="10" bodyfile="src/csl/indicial.cpp" bodystart="2781" bodyend="2792"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a8c28c7b5335fef612bce15a2a3e64a0c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void csl::TensorElement::printCode</definition>
        <argsstring>(int mode=0, std::ostream &amp;out=std::cout) const override</argsstring>
        <name>printCode</name>
        <qualifiedname>csl::TensorElement::printCode</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a2910dd30d90915c11d48c01cab618dda">printCode</reimplements>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1a6d2cb1f66c717a35f4c447952720817c">printCode</reimplementedby>
        <param>
          <type>int</type>
          <declname>mode</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
          <defval>std::cout</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="894" column="10" bodyfile="src/csl/indicial.cpp" bodystart="2794" bodyend="2824"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a5e4794abc02ba5d8f80f76f64e9cab9c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::string</type>
        <definition>string csl::TensorElement::printLaTeX</definition>
        <argsstring>(int mode=0) const override</argsstring>
        <name>printLaTeX</name>
        <qualifiedname>csl::TensorElement::printLaTeX</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aa067d4a97135bfe2052a7e21c28f75be">printLaTeX</reimplements>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1ac36fad3d18e46c353b4d961867d257cf">printLaTeX</reimplementedby>
        <param>
          <type>int</type>
          <declname>mode</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Creates a LaTeX output for the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>Tells if the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> is printed alone (default) or in another expr. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The string corresponding to the LaTeX output. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="896" column="17" bodyfile="src/csl/indicial.cpp" bodystart="2826" bodyend="2840"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1af028569513793f435ffbf644c0cd363f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::vector&lt; <ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref> &gt;</type>
        <definition>std::vector&lt; Parent &gt; csl::TensorElement::getSubSymbols</definition>
        <argsstring>() const override</argsstring>
        <name>getSubSymbols</name>
        <qualifiedname>csl::TensorElement::getSubSymbols</qualifiedname>
        <reimplements refid="classcsl_1_1AbstractElement_1a680ab53340473533609d65060d8457b8">getSubSymbols</reimplements>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1aa9049a79ee6b2dfd50dbfae7d48560c9">getSubSymbols</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="898" column="17" bodyfile="src/csl/indicial.cpp" bodystart="2842" bodyend="2854"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a7a1fc7737cce9da527d3796d2fd711d8" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::TensorElement::derive</definition>
        <argsstring>(Expr_info expr) const override</argsstring>
        <name>derive</name>
        <qualifiedname>csl::TensorElement::derive</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aecab8c872023a2d0771e7e4f83bb05f8">derive</reimplements>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Calculates the derivative of the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> wrt another. </para>
        </briefdescription>
        <detaileddescription>
<para>It is possible to derive wrt any complicated expr. In this case however, the calculation is <bold>not</bold> <bold>always</bold> <bold>mathematically</bold> <bold>correct</bold>. The program just searches for equal <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> or <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> with the same name. In particular dx/d(exp(x))=0. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>Expression wrt which we derive. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The derivative. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="900" column="19" bodyfile="src/csl/indicial.cpp" bodystart="2856" bodyend="2867"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1aaaa0e8d228945bad2ef6a8474a6df0c0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::optional&lt; <ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>optional&lt; Expr &gt; csl::TensorElement::evaluate</definition>
        <argsstring>(csl::eval::mode user_mode=csl::eval::base) const override</argsstring>
        <name>evaluate</name>
        <qualifiedname>csl::TensorElement::evaluate</qualifiedname>
        <reimplements refid="classcsl_1_1AbstractElement_1ad0583927014b475eb57853429c91df20">evaluate</reimplements>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1a55ad56ca57e69bdcb5b77e6d0bf254c7">evaluate</reimplementedby>
        <param>
          <type>csl::eval::mode</type>
          <declname>user_mode</declname>
          <defval>csl::eval::base</defval>
        </param>
        <briefdescription>
<para><bold>Evaluates</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>Replaces all variables by their value and evaluating. This function must be used instead of <ref refid="classcsl_1_1Abstract_1a543d5a4f0432e166b492ad28a860a65f" kindref="member">evaluateScalar()</ref> when treating not only real scalars.* In particular (x=2, y=3) x+iy evaluates to 3+ 3i whereas <ref refid="classcsl_1_1Abstract_1a543d5a4f0432e166b492ad28a860a65f" kindref="member">evaluateScalar()</ref> would return 3. <simplesect kind="return"><para>The abstract result of the evaluation. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="902" column="19" bodyfile="src/csl/indicial.cpp" bodystart="2869" bodyend="2900"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a089c8106691497aa93d1c1f684752110" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>unique_Expr</type>
        <definition>unique_Expr csl::TensorElement::copy_unique</definition>
        <argsstring>() const override</argsstring>
        <name>copy_unique</name>
        <qualifiedname>csl::TensorElement::copy_unique</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aaa996819710adc3b7529c74a628be623">copy_unique</reimplements>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1a2fd246ff5dd8ac7e1d1e474ac03b6a57">copy_unique</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="905" column="17" bodyfile="src/csl/indicial.cpp" bodystart="2902" bodyend="2908"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1aaddb4d5269b0b77fa8a9361ec0ecd281" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::TensorElement::refresh</definition>
        <argsstring>() const override</argsstring>
        <name>refresh</name>
        <qualifiedname>csl::TensorElement::refresh</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1aaeab3809e91989adbdf29c3f56d905b6">refresh</reimplements>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1a61c01a40bd7efdaa5d20e70a74efa215">refresh</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="907" column="10" bodyfile="src/csl/indicial.cpp" bodystart="2910" bodyend="2921"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1ad0dbe5ebe94a2c21e0a8a195730820c4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr csl::TensorElement::deepRefresh</definition>
        <argsstring>() const override</argsstring>
        <name>deepRefresh</name>
        <qualifiedname>csl::TensorElement::deepRefresh</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a10358c33402ed520dc5888b25bb26af3">deepRefresh</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="909" column="10" bodyfile="src/csl/indicial.cpp" bodystart="2923" bodyend="2926"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a6ada509cc19d2040553f8f40621914db" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool csl::TensorElement::operator==</definition>
        <argsstring>(Expr_info expr) const override</argsstring>
        <name>operator==</name>
        <qualifiedname>csl::TensorElement::operator==</qualifiedname>
        <reimplements refid="classcsl_1_1Complexified_1a10b02cb2da960264c19926a76a859488">operator==</reimplements>
        <reimplementedby refid="classcsl_1_1TensorFieldElement_1af7cde5cfd23cb3b4ca4ddbdbcf717db9">operator==</reimplementedby>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para><bold>Compares</bold> the <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> with another. </para>
        </briefdescription>
        <detaileddescription>
<para>Here if two Abstracts have the same name, the function will return <bold>true</bold> even if they are <bold>not</bold> <bold>mathematically</bold> <bold>equal</bold>. So beware not to name different things the same way. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> to compare. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><bold>True</bold> if the two Abstracts are the same (or have the same name). </para>
</simplesect>
<simplesect kind="return"><para><bold>False</bold> else. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="911" column="10" bodyfile="src/csl/indicial.cpp" bodystart="2928" bodyend="2947"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a154adda009ceab9ade7bce56d7907728" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::TensorElement::operator&lt;</definition>
        <argsstring>(const Abstract *expr) const override</argsstring>
        <name>operator&lt;</name>
        <qualifiedname>csl::TensorElement::operator&lt;</qualifiedname>
        <param>
          <type>const <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> *</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="913" column="5" bodyfile="src/csl/simplification.cpp" bodystart="1057" bodyend="1087"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="friend">
      <memberdef kind="friend" id="classcsl_1_1TensorElement_1ac30dc569c23395720a742624af02b4ba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref></type>
        <definition>Expr tensorelement_s</definition>
        <argsstring>(Args &amp;&amp;... args)</argsstring>
        <name>tensorelement_s</name>
        <qualifiedname>csl::TensorElement::tensorelement_s</qualifiedname>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="754" column="17" bodyfile="src/csl/indicial.h" bodystart="936" bodyend="941"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="protected-func">
      <memberdef kind="function" id="classcsl_1_1TensorElement_1ad78eb0b8122b22db79ea59b4af50f7c7" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool csl::TensorElement::comparePermutations</definition>
        <argsstring>(Expr_info perm1, Expr_info perm2) const</argsstring>
        <name>comparePermutations</name>
        <qualifiedname>csl::TensorElement::comparePermutations</qualifiedname>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>perm1</declname>
        </param>
        <param>
          <type><ref refid="classcsl_1_1Abstract" kindref="compound">Expr_info</ref></type>
          <declname>perm2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="916" column="10" bodyfile="src/csl/indicial.cpp" bodystart="2739" bodyend="2759"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a44cf39f1c6deadcb0191a78d32c3b441" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::TensorElement::selfCheckAutoIndices</definition>
        <argsstring>()</argsstring>
        <name>selfCheckAutoIndices</name>
        <qualifiedname>csl::TensorElement::selfCheckAutoIndices</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="918" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1afbfaf24db5ee68ab64a2378248fdf7e4" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
        <definition>Expr &amp; csl::TensorElement::applySelfStructureOn</definition>
        <argsstring>(Expr &amp;expr) const override</argsstring>
        <name>applySelfStructureOn</name>
        <qualifiedname>csl::TensorElement::applySelfStructureOn</qualifiedname>
        <reimplements refid="classcsl_1_1Abstract_1a6305ce90c795bfb416d8e958c62f905c">applySelfStructureOn</reimplements>
        <param>
          <type><ref refid="classcsl_1_1Expr" kindref="compound">Expr</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="920" column="10" bodyfile="src/csl/indicial.cpp" bodystart="2245" bodyend="2261"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1aa2605b68051617e35fc2a443c2b38a2c" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void csl::TensorElement::adjustMetricDeltaParent</definition>
        <argsstring>()</argsstring>
        <name>adjustMetricDeltaParent</name>
        <qualifiedname>csl::TensorElement::adjustMetricDeltaParent</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="922" column="10" bodyfile="src/csl/indicial.cpp" bodystart="2434" bodyend="2445"/>
      </memberdef>
      <memberdef kind="function" id="classcsl_1_1TensorElement_1a02db643378663eb5f17011937c5c9557" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>csl::vector_expr</type>
        <definition>csl::vector_expr csl::TensorElement::applyBrokenIndices</definition>
        <argsstring>(std::vector&lt; Parent &gt; &amp;brokenParents, const Space *broken, const std::vector&lt; const Space * &gt; &amp;newSpaces, const std::vector&lt; Index &gt; &amp;indices) const</argsstring>
        <name>applyBrokenIndices</name>
        <qualifiedname>csl::TensorElement::applyBrokenIndices</qualifiedname>
        <param>
          <type>std::vector&lt; <ref refid="classcsl_1_1Parent" kindref="compound">Parent</ref> &gt; &amp;</type>
          <declname>brokenParents</declname>
        </param>
        <param>
          <type>const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> *</type>
          <declname>broken</declname>
        </param>
        <param>
          <type>const std::vector&lt; const <ref refid="classcsl_1_1Space" kindref="compound">Space</ref> * &gt; &amp;</type>
          <declname>newSpaces</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="classcsl_1_1Index" kindref="compound">Index</ref> &gt; &amp;</type>
          <declname>indices</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/csl/indicial.h" line="925" column="5" bodyfile="src/csl/indicial.cpp" bodystart="2542" bodyend="2593"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>Specialization of <ref refid="classcsl_1_1Abstract" kindref="compound">Abstract</ref> for Indicial tensor. Building block carrying indices, and respecting Einstein&apos;s summation convention. </para>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <inheritancegraph>
      <node id="5">
        <label>csl::Abstract</label>
        <link refid="classcsl_1_1Abstract"/>
      </node>
      <node id="4">
        <label>csl::AbstractBuildingBlock</label>
        <link refid="classcsl_1_1AbstractBuildingBlock"/>
        <childnode refid="5" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>csl::AbstractElement</label>
        <link refid="classcsl_1_1AbstractElement"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
      <node id="3">
        <label>csl::Complexified</label>
        <link refid="classcsl_1_1Complexified"/>
        <childnode refid="4" relation="public-inheritance">
        </childnode>
      </node>
      <node id="7">
        <label>csl::Operator&lt; TensorFieldElement &gt;</label>
        <link refid="classcsl_1_1Operator"/>
        <childnode refid="6" relation="public-inheritance">
        </childnode>
      </node>
      <node id="8">
        <label>csl::TDerivativeElement</label>
        <link refid="classcsl_1_1TDerivativeElement"/>
        <childnode refid="7" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1">
        <label>csl::TensorElement</label>
        <link refid="classcsl_1_1TensorElement"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="6">
        <label>csl::TensorFieldElement</label>
        <link refid="classcsl_1_1TensorFieldElement"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="11">
        <label>mty::GeneratorElement</label>
        <link refid="classmty_1_1GeneratorElement"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="10">
        <label>mty::PolarizationField</label>
        <link refid="classmty_1_1PolarizationField"/>
        <childnode refid="9" relation="public-inheritance">
        </childnode>
      </node>
      <node id="9">
        <label>mty::QuantumField</label>
        <link refid="classmty_1_1QuantumField"/>
        <childnode refid="6" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="5">
        <label>csl::Abstract</label>
        <link refid="classcsl_1_1Abstract"/>
      </node>
      <node id="4">
        <label>csl::AbstractBuildingBlock</label>
        <link refid="classcsl_1_1AbstractBuildingBlock"/>
        <childnode refid="5" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>csl::AbstractElement</label>
        <link refid="classcsl_1_1AbstractElement"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
        <childnode refid="6" relation="usage">
          <edgelabel>parent</edgelabel>
        </childnode>
      </node>
      <node id="3">
        <label>csl::Complexified</label>
        <link refid="classcsl_1_1Complexified"/>
        <childnode refid="4" relation="public-inheritance">
        </childnode>
      </node>
      <node id="7">
        <label>csl::IndexStructure</label>
        <link refid="classcsl_1_1IndexStructure"/>
      </node>
      <node id="1">
        <label>csl::TensorElement</label>
        <link refid="classcsl_1_1TensorElement"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
        <childnode refid="7" relation="usage">
          <edgelabel>index</edgelabel>
        </childnode>
      </node>
      <node id="6">
        <label>std::shared_ptr&lt; csl::AbstractParent &gt;</label>
        <link refid="classstd_1_1shared__ptr"/>
      </node>
    </collaborationgraph>
    <location file="src/csl/indicial.h" line="700" column="1" bodyfile="src/csl/indicial.h" bodystart="700" bodyend="929"/>
    <listofallmembers>
      <member refid="classcsl_1_1Abstract_1ad5fee68c1f3dcbda0e936926fed17616" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>Abstract</name></member>
      <member refid="classcsl_1_1AbstractBuildingBlock_1a64aaa989689a7e8c262e6d9fceaff10f" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>AbstractBuildingBlock</name></member>
      <member refid="classcsl_1_1AbstractElement_1a12ebb2cd662c44ca2e60106d630dbc48" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>AbstractElement</name></member>
      <member refid="classcsl_1_1AbstractElement_1a90b37b4752b24ab6cb0a29dc3329eea4" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>AbstractElement</name></member>
      <member refid="classcsl_1_1Abstract_1a5549ac0c186b3c6febf332245a25a82c" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>addAntiSymmetry</name></member>
      <member refid="classcsl_1_1Abstract_1abbab11282e5c6ac46b018642ff129f47" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>addDependency</name></member>
      <member refid="classcsl_1_1Abstract_1a101219973341a39cf15f07e5e1aa388f" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>addition_own</name></member>
      <member refid="classcsl_1_1Abstract_1ad431770faa4291116a50175193a11a88" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>addSymmetry</name></member>
      <member refid="classcsl_1_1TensorElement_1aa2605b68051617e35fc2a443c2b38a2c" prot="protected" virt="non-virtual"><scope>csl::TensorElement</scope><name>adjustMetricDeltaParent</name></member>
      <member refid="classcsl_1_1Abstract_1acd972aed8326d4c13534594e061ee6da" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>antisymmetrise</name></member>
      <member refid="classcsl_1_1TensorElement_1a02db643378663eb5f17011937c5c9557" prot="protected" virt="non-virtual"><scope>csl::TensorElement</scope><name>applyBrokenIndices</name></member>
      <member refid="classcsl_1_1Complexified_1ac8174f246df45364467fffd925027808" prot="protected" virt="non-virtual"><scope>csl::TensorElement</scope><name>applyComplexPropertiesOn</name></member>
      <member refid="classcsl_1_1Complexified_1a7b2b037721656af10cb29a077a567b30" prot="protected" virt="non-virtual"><scope>csl::TensorElement</scope><name>applyComplexPropertiesOn</name></member>
      <member refid="classcsl_1_1Abstract_1a61d3ab932182226f4670a62bbb22af4e" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>applyDiracDelta</name></member>
      <member refid="classcsl_1_1Abstract_1a316956fea77627a716500a2bbfc1f3b7" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>applyOperator</name></member>
      <member refid="classcsl_1_1TensorElement_1ad6f100f8c15bee5c29d97d40549a6e18" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>applyPermutation</name></member>
      <member refid="classcsl_1_1TensorElement_1afbfaf24db5ee68ab64a2378248fdf7e4" prot="protected" virt="virtual"><scope>csl::TensorElement</scope><name>applySelfStructureOn</name></member>
      <member refid="classcsl_1_1TensorElement_1a6ec375934423dbb60f6d00ea13ec7f80" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>askTerm</name></member>
      <member refid="classcsl_1_1Abstract_1aad54ed41b2ce9bad3364fe30ad1a0d71" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>begin</name></member>
      <member refid="classcsl_1_1Abstract_1adff373df9477d4e38581d09cc6d2fee4" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>begin</name></member>
      <member refid="classcsl_1_1TensorElement_1aafc27871bb78f0a07df8aa097d3d8a0e" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>breakSpace</name></member>
      <member refid="classcsl_1_1Abstract_1aa4cba37520821432f37e212fefbc2534" prot="public" virt="non-virtual" ambiguityscope="csl::AbstractElement::"><scope>csl::TensorElement</scope><name>breakSpace</name></member>
      <member refid="classcsl_1_1TensorElement_1ad9d1474eb8d1c53835ffb3891e01b020" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>checkIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1a1ebd84082bb93418408cc0babe2dffe2" prot="public" virt="virtual" ambiguityscope="csl::AbstractElement::"><scope>csl::TensorElement</scope><name>checkIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1ab3746f1d3667846824ea51b8a2e00d31" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>collect</name></member>
      <member refid="classcsl_1_1AbstractBuildingBlock_1add4dd8d4ed4ea0d8817fdd79abd744cc" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>commutesWith</name></member>
      <member refid="classcsl_1_1TensorElement_1ad78eb0b8122b22db79ea59b4af50f7c7" prot="protected" virt="non-virtual"><scope>csl::TensorElement</scope><name>comparePermutations</name></member>
      <member refid="classcsl_1_1TensorElement_1acd1ac409b891dd033c1792f5473d8d10" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>compareWithDummy</name></member>
      <member refid="classcsl_1_1Abstract_1a0f16fda9fe72a89c61ece36101a11d95" prot="public" virt="non-virtual" ambiguityscope="csl::AbstractElement::"><scope>csl::TensorElement</scope><name>compareWithDummy</name></member>
      <member refid="classcsl_1_1Complexified_1a6333b0f548411b1712301806c21c2261" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>Complexified</name></member>
      <member refid="classcsl_1_1Complexified_1a785754f2eac5813fcf8aa87cc0b456bf" prot="protected" virt="non-virtual"><scope>csl::TensorElement</scope><name>conjugated</name></member>
      <member refid="classcsl_1_1Abstract_1aed79d20a0821205e6430c80a474117d3" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>contractIndex</name></member>
      <member refid="classcsl_1_1TensorElement_1a2a301cd1beb0eecde2b83c1ca6167c59" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>contraction</name></member>
      <member refid="classcsl_1_1Abstract_1abd35096982e92b669ea55d960c5f44be" prot="public" virt="virtual" ambiguityscope="csl::AbstractElement::"><scope>csl::TensorElement</scope><name>contraction</name></member>
      <member refid="classcsl_1_1Abstract_1af29c2898c5d3ba96de8018a0838c402c" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>copy</name></member>
      <member refid="classcsl_1_1TensorElement_1a089c8106691497aa93d1c1f684752110" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>copy_unique</name></member>
      <member refid="classcsl_1_1Abstract_1a09648782dcf2e81abb5b864f476cc410" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>deepCopy</name></member>
      <member refid="classcsl_1_1TensorElement_1ad0dbe5ebe94a2c21e0a8a195730820c4" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>deepRefresh</name></member>
      <member refid="classcsl_1_1TensorElement_1a22a5c9686859930af78f51a85b31160d" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>dependsExplicitlyOn</name></member>
      <member refid="classcsl_1_1Abstract_1a0b26ad7a44e497af296318287bac539a" prot="public" virt="virtual" ambiguityscope="csl::AbstractElement::"><scope>csl::TensorElement</scope><name>dependsExplicitlyOn</name></member>
      <member refid="classcsl_1_1TensorElement_1a14ad4f8a47af9ea009bcea3385e45bc3" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>dependsOn</name></member>
      <member refid="classcsl_1_1TensorElement_1a016485a4c1fe60991263a4dea94eed6e" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>dependsOn</name></member>
      <member refid="classcsl_1_1TensorElement_1a7a1fc7737cce9da527d3796d2fd711d8" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>derive</name></member>
      <member refid="classcsl_1_1Abstract_1aeb08811cf370616477a92075e4a218ee" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>determinant</name></member>
      <member refid="classcsl_1_1Abstract_1a1578c74aee1050b806a67e7a81a67f5c" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>division_own</name></member>
      <member refid="classcsl_1_1Abstract_1a4cc7a46deaa3eaa7593909d74e76d4af" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>dot</name></member>
      <member refid="classcsl_1_1Abstract_1a0c3c3fe5010f24e8a8765ea06415c003" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>empty</name></member>
      <member refid="classcsl_1_1Abstract_1a61e4e80d998a888a1a74d9ea3e10c0f1" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>end</name></member>
      <member refid="classcsl_1_1Abstract_1ae2761d54f13310e13f5076d565edd7ef" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>end</name></member>
      <member refid="classcsl_1_1TensorElement_1aaaa0e8d228945bad2ef6a8474a6df0c0" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>evaluate</name></member>
      <member refid="classcsl_1_1Abstract_1a543d5a4f0432e166b492ad28a860a65f" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>evaluateScalar</name></member>
      <member refid="classcsl_1_1AbstractBuildingBlock_1a7cbbd2edd75a84057f1622826c1efd3a" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>expand</name></member>
      <member refid="classcsl_1_1Abstract_1aeb48aaaa856582b6359037fe94d2419b" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>expand_if</name></member>
      <member refid="classcsl_1_1Abstract_1aa2696a0feb43766ef54e1e3dd3d6d134" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>exponentiation_own</name></member>
      <member refid="classcsl_1_1AbstractBuildingBlock_1a2f12cede626ece5382c9869d32c32146" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>factor</name></member>
      <member refid="classcsl_1_1AbstractBuildingBlock_1a447f940bf0a08d13297fde0b50b4cb84" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>factor</name></member>
      <member refid="classcsl_1_1AbstractBuildingBlock_1a4000d3f204c1957f5cffc0677dd754c0" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>findSubExpression</name></member>
      <member refid="classcsl_1_1Abstract_1a021946e84d8c1a019908cac578b16fe8" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getAllDependencies</name></member>
      <member refid="classcsl_1_1Abstract_1ac33a42309d629d47bfdbede4e152414e" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a06f542034e95744148f4fce5a4893e63" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a898d6cf2a7f348feacab189447bee1eb" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getArgument</name></member>
      <member refid="classcsl_1_1Abstract_1aa689fb64eecb86edbde6c745d1ce756b" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getArgument</name></member>
      <member refid="classcsl_1_1TensorElement_1ad6f8f7e5b89936e1fa39661b1975c3ce" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getCanonicalPermutation</name></member>
      <member refid="classcsl_1_1AbstractElement_1ab3418bd6d3548316885c8bda0a7464b8" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getCommutable</name></member>
      <member refid="classcsl_1_1Complexified_1ab70d880a6d5eaf52b7d365c9d0c29f86" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getComplexArgument</name></member>
      <member refid="classcsl_1_1TensorElement_1a684ed9584f9bbe4ffc1e842b84a05ed0" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getComplexConjugate</name></member>
      <member refid="classcsl_1_1Complexified_1a05b65b2f6cdbc13a1d757a3f90ae7c0c" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getComplexModulus</name></member>
      <member refid="classcsl_1_1AbstractElement_1a0b2c014c2c35cad27d9df5240bfb8548" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getComplexProperty</name></member>
      <member refid="classcsl_1_1Abstract_1af04c0e4426f0bf9df365afe0148d59df" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getContractedPair</name></member>
      <member refid="classcsl_1_1TensorElement_1a5f1b1ae7f3655cccd70bf09a60075b7b" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getContractionProperties</name></member>
      <member refid="classcsl_1_1Abstract_1aa22f0e4c9c91f43b5cd61cbb873869eb" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getDeltaMinus</name></member>
      <member refid="classcsl_1_1Abstract_1a69a657baf1c35ed581e9db2c47a71c99" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getDeltaPlus</name></member>
      <member refid="classcsl_1_1Abstract_1a9531d78d67c82e288c0130da5b1ba80b" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getDenom</name></member>
      <member refid="classcsl_1_1Abstract_1a5856c3d55a6d1406970f3656e61efe8e" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getDim</name></member>
      <member refid="classcsl_1_1Abstract_1a77e067fc57c0c2e70d141079455fdbd7" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getElementary</name></member>
      <member refid="classcsl_1_1Abstract_1ac513c930caa9939c2b9557f36a34ee69" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getExponents</name></member>
      <member refid="classcsl_1_1Abstract_1ac34c9c6f05e692faeed2f030514787ad" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getFactors</name></member>
      <member refid="classcsl_1_1Abstract_1aa4136dc23f1fba4bf897b54c8592ccfc" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getFreeIndexStructure</name></member>
      <member refid="classcsl_1_1TensorElement_1ab38b54f3efd6b9950b6d3334a224caa1" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getHermitianConjugate</name></member>
      <member refid="classcsl_1_1TensorElement_1ac1596174400a2ccd49d56b736fa8114a" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getHermitianConjugate</name></member>
      <member refid="classcsl_1_1Complexified_1a11702661de0ea3b9c59b1f23af0ca0c0" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getImaginaryPart</name></member>
      <member refid="classcsl_1_1TensorElement_1a029c4358822daed54f4f775032896790" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getIndex</name></member>
      <member refid="classcsl_1_1TensorElement_1a3dc05ca45a03e8a7f8459812e07b85f6" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1ae6a9a9ef3efd6bb83b62c0a353742d25" prot="public" virt="non-virtual" ambiguityscope="csl::AbstractElement::"><scope>csl::TensorElement</scope><name>getIndexStructure</name></member>
      <member refid="classcsl_1_1TensorElement_1abe312de6a76204dfcdc98cf4711bf353" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getIndexStructureView</name></member>
      <member refid="classcsl_1_1TensorElement_1a15b5b8ef2a249fda36f7491b634270fb" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getIndexStructureView</name></member>
      <member refid="classcsl_1_1Abstract_1a3d6b1e294cf24dea17c3c4361226138b" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getInfBoundary</name></member>
      <member refid="classcsl_1_1AbstractElement_1ad8d4ceaa06fb30861b1ce4336a465f54" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getLatexName</name></member>
      <member refid="classcsl_1_1Abstract_1a652101e34b2efa43114150e9af3c79d5" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getLibDependency</name></member>
      <member refid="classcsl_1_1AbstractElement_1ae80699e259632a43c4f69a125b64ae30" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getName</name></member>
      <member refid="classcsl_1_1Abstract_1aa034448201c9e7998bbbb5e409636b30" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getNArgs</name></member>
      <member refid="classcsl_1_1Abstract_1a42125e9765a771c47819548d342b0b28" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getNContractedPairs</name></member>
      <member refid="classcsl_1_1Abstract_1a204dbd37b63432cb08932b995f49d3f4" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getNFactor</name></member>
      <member refid="classcsl_1_1TensorElement_1a5ddd03efb94ea0017def76cd6777f745" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getNIndices</name></member>
      <member refid="classcsl_1_1Abstract_1a6aa6bcc7cb8ee1574f29dc6ab6c6f0ed" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getNum</name></member>
      <member refid="classcsl_1_1Abstract_1aad25c117c8dfc4d9718ba41e8d3f33a6" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getNumericalFactor</name></member>
      <member refid="classcsl_1_1Abstract_1a9c3ec3dfe1fbd8ead5c8d9aca421a863" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getOperand</name></member>
      <member refid="classcsl_1_1Abstract_1a9500a21d75d03c695ec0c76493600b38" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getOrder</name></member>
      <member refid="classcsl_1_1Abstract_1ae89eb7b1a9e0259a60154563f3315907" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getOrderOf</name></member>
      <member refid="classcsl_1_1AbstractElement_1a9e50d48ea0ee472c5c07f3985cc6c641" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getParent</name></member>
      <member refid="classcsl_1_1AbstractElement_1acde43ab4cab544c3c0aa0d695e67b4ad" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getParent_info</name></member>
      <member refid="classcsl_1_1Abstract_1aea8459b3206eb3a2297eeea7688e9520" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getParity</name></member>
      <member refid="classcsl_1_1TensorElement_1aa0f1ab4f63aa28f3c759a666fb15636a" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getPermutations</name></member>
      <member refid="classcsl_1_1Abstract_1a06b32036fea6a2583f506a6ef9508d74" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getPoint</name></member>
      <member refid="classcsl_1_1AbstractElement_1a028ecff66278c1e385280b761388b929" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getPolynomialTerm</name></member>
      <member refid="classcsl_1_1TensorElement_1a1c246057031fbc18868bac66d13be37c" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getPrimaryType</name></member>
      <member refid="classcsl_1_1Abstract_1a07489d0569bc983718796d21c73f34b3" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getProduct</name></member>
      <member refid="classcsl_1_1Complexified_1a5de9b50162c5af5177a928e855e6b71b" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getRealPart</name></member>
      <member refid="classcsl_1_1Abstract_1a5b77f008f4b95030641224877004f06c" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getRegularExpression</name></member>
      <member refid="classcsl_1_1Abstract_1a625efe55a17b97a1c0f085bdbf3a962a" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getShape</name></member>
      <member refid="classcsl_1_1Abstract_1aa83df1d9dc202457113e5b38bd694fae" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getSign</name></member>
      <member refid="classcsl_1_1TensorElement_1af028569513793f435ffbf644c0cd363f" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getSubSymbols</name></member>
      <member refid="classcsl_1_1Abstract_1a7dcdc11b64c8c515933882168d0792ef" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1a413c50b2663f57d38c1d3ec3cfeaa3ce" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1a26a0854bca4c47e84a1da36a3de8c49f" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1a29261a946b3398b6129237620754a8b9" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1a8a067b70756c4eef758aa88076a95162" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getSubVectorial</name></member>
      <member refid="classcsl_1_1Abstract_1aeaf8154e39ff211b12e6382e675ccaad" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getSum</name></member>
      <member refid="classcsl_1_1Abstract_1a2fcc223dbf5d880e923c07df142df5c8" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getSupBoundary</name></member>
      <member refid="classcsl_1_1AbstractBuildingBlock_1a58c627e31c2a42adec4caf39030123aa" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getTerm</name></member>
      <member refid="classcsl_1_1TensorElement_1ae47bc7e79e284964b2a8447bf917f48f" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getTransposed</name></member>
      <member refid="classcsl_1_1TensorElement_1a7cc7fb9e1f39bcebc90170e8dd526d43" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getTransposed</name></member>
      <member refid="classcsl_1_1TensorElement_1a7b99f83fdff13fb508ea8e671d4dc834" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getType</name></member>
      <member refid="classcsl_1_1Abstract_1a78f98ba06476e464e3fd2fce0d1f8243" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getValue</name></member>
      <member refid="classcsl_1_1Abstract_1a628563238145f3a9acc331f1a89ce32f" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getValued</name></member>
      <member refid="classcsl_1_1Abstract_1ae85f810bbadbc792210c958e8f1b2ffb" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getVariable</name></member>
      <member refid="classcsl_1_1Abstract_1ac83c44ae1e5315a38083bdb7acd8f3fa" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getVectorArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a0188b049736016c970a2513ed9f6931f" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>getVectorialModulus</name></member>
      <member refid="classcsl_1_1TensorElement_1acb6f22178e26a8cc694ae2ffc01c2075" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>hasChainContractionProperty</name></member>
      <member refid="classcsl_1_1TensorElement_1a511992d33dc54c1fb8d0c4c17afa5f8c" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>hasContractionProperty</name></member>
      <member refid="classcsl_1_1Abstract_1a8c42723e8bc6334c99f00898cc1d59d7" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>hermitian</name></member>
      <member refid="classcsl_1_1TensorElement_1a7f7b50e1bbd4157e8b2797740aa31b89" prot="protected" virt="non-virtual"><scope>csl::TensorElement</scope><name>index</name></member>
      <member refid="classcsl_1_1Abstract_1a5437e7f685edf8549e6d3b34572343f8" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>insert</name></member>
      <member refid="classcsl_1_1Abstract_1a1b68943aa7ecf60a63af0f2f368eef8f" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>inverseMatrix</name></member>
      <member refid="classcsl_1_1Abstract_1a9347e75b0cd0b75e0f0a38db93b29d83" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>isAnOperator</name></member>
      <member refid="classcsl_1_1Abstract_1ac09992d147b39388c8936b3bff648930" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>isArbitrary</name></member>
      <member refid="classcsl_1_1AbstractBuildingBlock_1aee083330a4490359012cf0e656758a44" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>isBuildingBlock</name></member>
      <member refid="classcsl_1_1Complexified_1a3f583f018b34b63b321976a8bcedf430" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>isComplexConjugate</name></member>
      <member refid="classcsl_1_1Abstract_1a464f4f0613db9b4b0a4efe26a3a03d60" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>isEmpty</name></member>
      <member refid="classcsl_1_1Abstract_1af2ce38838e35c5785f92373a1d830668" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>isHermitianConjugate</name></member>
      <member refid="classcsl_1_1TensorElement_1acc36470e69d6edf43f6dd7b6db0365d2" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>isIndexed</name></member>
      <member refid="classcsl_1_1Abstract_1a9a014bfd266b5f8471f23580e271979b" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>isInteger</name></member>
      <member refid="classcsl_1_1AbstractElement_1a9f3e30eeaace6c5c21cda6895daa2de9" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>isPolynomial</name></member>
      <member refid="classcsl_1_1Complexified_1aa3de4cb73eb624830da28f07ef0fa4d4" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>isPurelyImaginary</name></member>
      <member refid="classcsl_1_1Complexified_1a4c69b308c3d305cfa532eb5c653072a0" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>isReal</name></member>
      <member refid="classcsl_1_1Abstract_1ab79c1d8df9e6b1a3eca66958f7dc489d" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>matchShape</name></member>
      <member refid="classcsl_1_1TensorElement_1ae7a6d8fc44218dcade0332e215f4b653" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>memoryOverhead</name></member>
      <member refid="classcsl_1_1Abstract_1a4f5ed458ba62f5b4cf61a9e1f8568af1" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>multiplication_own</name></member>
      <member refid="classcsl_1_1Abstract_1af5b62a6308638064c42da80e9cc2cb7e" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1af4fd1b57df371dac7ccfd5a909620e49" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1a96de5935a58a96d4c5b1e47966488923" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1ac99a619abde7e4c58f39e14d4d20fcf5" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1a45206de7c7773b3cb150451ee3eb379e" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1Abstract_1a0d3495220202bd417c1b58249c923f39" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>operator!=</name></member>
      <member refid="classcsl_1_1TensorElement_1a154adda009ceab9ade7bce56d7907728" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>operator&lt;</name></member>
      <member refid="classcsl_1_1Abstract_1a5c1ba8dce7fbc19eb98807bd15a279c9" prot="public" virt="pure-virtual" ambiguityscope="csl::AbstractElement::"><scope>csl::TensorElement</scope><name>operator&lt;</name></member>
      <member refid="classcsl_1_1Abstract_1a6e19587260a07dba65cf2a985e05516b" prot="public" virt="non-virtual" ambiguityscope="csl::AbstractElement::"><scope>csl::TensorElement</scope><name>operator&lt;</name></member>
      <member refid="classcsl_1_1Abstract_1a2a1660498f2638f5e490d6e512eb32f4" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>operator&lt;=</name></member>
      <member refid="classcsl_1_1Abstract_1afbcac6df2fd7ac11f336189cf215124b" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>operator&lt;=</name></member>
      <member refid="classcsl_1_1Abstract_1a59ff2950fc8ca319f87a730450f14545" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>operator=</name></member>
      <member refid="classcsl_1_1TensorElement_1a6ada509cc19d2040553f8f40621914db" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a8334e14cd5789168b037d3888ed60edd" prot="public" virt="virtual" ambiguityscope="csl::AbstractBuildingBlock::"><scope>csl::TensorElement</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a12d929e34039e817e464abc560bd4a9d" prot="public" virt="virtual" ambiguityscope="csl::AbstractBuildingBlock::"><scope>csl::TensorElement</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a1f78f0cce24c93def3050743bc5f2845" prot="public" virt="non-virtual" ambiguityscope="csl::AbstractBuildingBlock::"><scope>csl::TensorElement</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1aed43debcac4a19e0da44986774c522bc" prot="public" virt="non-virtual" ambiguityscope="csl::AbstractBuildingBlock::"><scope>csl::TensorElement</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a2376f08c0aa5ffe783090381d102d3ae" prot="public" virt="non-virtual" ambiguityscope="csl::AbstractBuildingBlock::"><scope>csl::TensorElement</scope><name>operator==</name></member>
      <member refid="classcsl_1_1Abstract_1a485c6f3e10db539a70416cd0766b117d" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>operator&gt;</name></member>
      <member refid="classcsl_1_1Abstract_1ab305bdf49212f03781e7f98024faeb66" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>operator&gt;</name></member>
      <member refid="classcsl_1_1Abstract_1a4c8883df19d7538b68fa96aadac9dfa9" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>operator&gt;=</name></member>
      <member refid="classcsl_1_1Abstract_1a6b931f7b159d57bad26ca9c9ea729aa1" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>operator&gt;=</name></member>
      <member refid="classcsl_1_1Abstract_1aa8331053065d1be2da89e70c45d24863" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>operator[]</name></member>
      <member refid="classcsl_1_1Abstract_1a560aa9993d506551c54a8c02d1445814" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>operator[]</name></member>
      <member refid="classcsl_1_1Abstract_1a75d9abfa88d9d09a89d3a4becd9e6429" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>operatorAppliesOn</name></member>
      <member refid="classcsl_1_1AbstractElement_1a5ad0a45c8a069be5e3e0ce21b784bb0b" prot="protected" virt="non-virtual"><scope>csl::TensorElement</scope><name>parent</name></member>
      <member refid="classcsl_1_1Abstract_1abe9aceabbc0a99642e84c9025dbdc767" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>permut</name></member>
      <member refid="classcsl_1_1TensorElement_1a0b5baffa4b563fd8e2e8ec4ee00446b1" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>print</name></member>
      <member refid="classcsl_1_1TensorElement_1a8c28c7b5335fef612bce15a2a3e64a0c" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>printCode</name></member>
      <member refid="classcsl_1_1Abstract_1a89e45ffc7b65f92e77e592f76f70934c" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>printExplicit</name></member>
      <member refid="classcsl_1_1TensorElement_1a5e4794abc02ba5d8f80f76f64e9cab9c" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>printLaTeX</name></member>
      <member refid="classcsl_1_1Complexified_1a42c425b2145c916331f881f217e14e4b" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>printProp</name></member>
      <member refid="classcsl_1_1TensorElement_1aaddb4d5269b0b77fa8a9361ec0ecd281" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>refresh</name></member>
      <member refid="classcsl_1_1Abstract_1a8aab87c41acafaf1b1837b922495560d" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>regularLiteral</name></member>
      <member refid="classcsl_1_1Abstract_1a2fe749450d2e610199801b189dc3d0f8" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>regularLiteral</name></member>
      <member refid="classcsl_1_1Abstract_1aba5ef083016b2f3d9e6271f864b9b063" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>regularName</name></member>
      <member refid="classcsl_1_1Abstract_1a1a8421d402d5ba82257188b545e8d668" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>regularName</name></member>
      <member refid="classcsl_1_1Abstract_1a0e778c682b6cb02642b90e8ec8765441" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>removeDependency</name></member>
      <member refid="classcsl_1_1TensorElement_1a02fe69a766b8eade9d5de6cbea8054a6" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>replaceIndex</name></member>
      <member refid="classcsl_1_1TensorElement_1a16558db6dbbfcf52c37b52f8a883b5a6" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>replaceIndexInPlace</name></member>
      <member refid="classcsl_1_1TensorElement_1a9ad3c1eabb60fb445f9054699f9d949d" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>replaceIndices</name></member>
      <member refid="classcsl_1_1TensorElement_1a1ca07618e533c2ca4b4cc3646195a64d" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>resetIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1a5c796713828ebfb74a7d8787d7802a76" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>self</name></member>
      <member refid="classcsl_1_1TensorElement_1a44cf39f1c6deadcb0191a78d32c3b441" prot="protected" virt="non-virtual"><scope>csl::TensorElement</scope><name>selfCheckAutoIndices</name></member>
      <member refid="classcsl_1_1TensorElement_1ab0c7c1c3fb0105a70a1c73db895e0317" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>selfCheckIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1aa6a40ceb6eb1aa79711ca126d5bdda02" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>setAllDependencies</name></member>
      <member refid="classcsl_1_1Abstract_1aab2d2ac186b56d17d2cc0a105e145b11" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>setArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a45c3adb7ba4e2b8442247246a3792b44" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>setArgument</name></member>
      <member refid="classcsl_1_1AbstractElement_1ab8f5f04326a3320b48a315ec5cee60d9" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>setCommutable</name></member>
      <member refid="classcsl_1_1AbstractElement_1a7d9bb4605dbd97ea98f721611adadd72" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>setComplexProperty</name></member>
      <member refid="classcsl_1_1Complexified_1a22b60556c965e51ab733e6eb5441783c" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>setConjugated</name></member>
      <member refid="classcsl_1_1Abstract_1aa6a04bb56578e7da143b3cd8d8fb7b26" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>setElementary</name></member>
      <member refid="classcsl_1_1Abstract_1afa50c743b8e7e76e637e98f165ad4e5d" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>setEmpty</name></member>
      <member refid="classcsl_1_1Abstract_1ac318016372d14b795893fe7e59199084" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>setFullyAntiSymmetric</name></member>
      <member refid="classcsl_1_1Abstract_1a4f90ebb7cf7c26782bd36bc2a67fc5d4" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>setFullySymmetric</name></member>
      <member refid="classcsl_1_1TensorElement_1a387f69126ae40d711755945ef023de92" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>setIndexStructure</name></member>
      <member refid="classcsl_1_1Abstract_1a5ecdb6ce7a2d9643da2f6161a06dfbbf" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>setInfBoundary</name></member>
      <member refid="classcsl_1_1AbstractElement_1aed5a0c9faec5b41fb1feb52764c4237f" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>setName</name></member>
      <member refid="classcsl_1_1Abstract_1a70df7be4486affa8dc891e3f25bf499f" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>setOperand</name></member>
      <member refid="classcsl_1_1Abstract_1ae7b8a14fc746ed72e4d5abd63373c5ba" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>setOperandPrivate</name></member>
      <member refid="classcsl_1_1AbstractElement_1af55db25120693bf64ed360105cb4357c" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>setParent</name></member>
      <member refid="classcsl_1_1Abstract_1a3c175411df619e7504feb6d888fc82f1" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>setPoint</name></member>
      <member refid="classcsl_1_1Abstract_1aad7104a5b8855272a92a47c58f29e958" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>setSupBoundary</name></member>
      <member refid="classcsl_1_1Abstract_1aaf7f0692cb84ca861a5b3b641bea518b" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>setValue</name></member>
      <member refid="classcsl_1_1Abstract_1aa49c51bd285830e724f103e9fb61c464" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>setValue</name></member>
      <member refid="classcsl_1_1Abstract_1aa47ddab3aa047e86be34c70358d53548" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>setVariable</name></member>
      <member refid="classcsl_1_1Abstract_1a83fee8ed28079bcac107455d58be9d5d" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>setVectorArgument</name></member>
      <member refid="classcsl_1_1Abstract_1a3794843945b8a39e2c1be073c9bacdf5" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>size</name></member>
      <member refid="classcsl_1_1Abstract_1a4eeedaeaa39e75facf1060dce7c57a8f" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>suppressExponent</name></member>
      <member refid="classcsl_1_1Abstract_1a43520e1d6d5fdad9b50f77c6e027f928" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>suppressTerm</name></member>
      <member refid="classcsl_1_1Abstract_1a4faf1ffd8cb3b6c721e128980c0303d8" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>symmetrise</name></member>
      <member refid="classcsl_1_1Abstract_1a7b83c6a13716688f45b02e6291d39aba" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>tensordot</name></member>
      <member refid="classcsl_1_1TensorElement_1ae0b7c09c0acd3173ba66669d797192c0" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>TensorElement</name></member>
      <member refid="classcsl_1_1TensorElement_1a1b29839ab99dd106e336ce900023d18a" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>TensorElement</name></member>
      <member refid="classcsl_1_1TensorElement_1ac2169c4eabe165be2f0c455f658a0036" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>TensorElement</name></member>
      <member refid="classcsl_1_1TensorElement_1a3bba3e8ce7e864a2921ad91e4019454c" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>TensorElement</name></member>
      <member refid="classcsl_1_1TensorElement_1a4d45c8d308213ea65d46f9aeab883d9f" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>TensorElement</name></member>
      <member refid="classcsl_1_1TensorElement_1a4f78788e311f00a646e933b102fe365c" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>TensorElement</name></member>
      <member refid="classcsl_1_1TensorElement_1ac30dc569c23395720a742624af02b4ba" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>tensorelement_s</name></member>
      <member refid="classcsl_1_1Abstract_1aee4fa41a5e014f067395467542ee8831" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>testDummy</name></member>
      <member refid="classcsl_1_1Abstract_1a9a86d21f5c5f65eb7e524a8f8002c0e7" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>trace</name></member>
      <member refid="classcsl_1_1Abstract_1aacab43e551e9259a39a79378373ce49c" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>trace</name></member>
      <member refid="classcsl_1_1Abstract_1a1e97712696e5c40b28bc1e35987fea94" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>transpose</name></member>
      <member refid="classcsl_1_1Abstract_1a40bdc4c76fdbbf3cbac3af4dce8286ed" prot="public" virt="virtual"><scope>csl::TensorElement</scope><name>~Abstract</name></member>
      <member refid="classcsl_1_1AbstractElement_1a96ee7c198c82450d17ce0f08df2bef00" prot="public" virt="non-virtual"><scope>csl::TensorElement</scope><name>~AbstractElement</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
